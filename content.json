{"meta":{"title":"WenChongAndJiaoKou","subtitle":null,"description":null,"author":"WenChongAndJiaoKou","url":"https://pinksmallfan.github.io/WenChongAndJiaoKou"},"pages":[{"title":"Hello World","date":"2018-10-15T18:27:29.680Z","updated":"2018-10-09T15:07:58.556Z","comments":true,"path":"bak/hello-world.html","permalink":"https://pinksmallfan.github.io/WenChongAndJiaoKou/bak/hello-world.html","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment"}],"posts":[{"title":"Java下Zip处理的工具类","slug":"2018-12-16-Zip处理的工具类","date":"2018-12-16T12:29:34.000Z","updated":"2018-12-16T12:57:39.055Z","comments":true,"path":"2018/12/16/2018-12-16-Zip处理的工具类/","link":"","permalink":"https://pinksmallfan.github.io/WenChongAndJiaoKou/2018/12/16/2018-12-16-Zip处理的工具类/","excerpt":"","text":"简要介绍​ 通过工具类，读取zip压缩文件，获取被压缩的文件内容，工具类忽略压缩文件中含有文件夹的文件，只考虑压缩文件的内容仅限于文件。 Pom实现方式12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091import java.io.*;import java.util.Enumeration;import java.util.HashMap;import java.util.List;import java.util.Map;import org.apache.tools.zip.ZipEntry;import org.apache.tools.zip.ZipFile;/** * 说明: * * zip处理工具类 */public class ZipUtil &#123; private static final int FILE_LIMIT_SIZE = 1000 * 50; /** * 读取zip的文件，并转为map对象 * @param zipFile zip文件 * @return 返回map对象，键为文件名，值为文件 */ public static Map&lt;String, Object&gt; readZip2MapList(File zipFile) throws IOException, Exception &#123; String fileEncode = checkEncoding(zipFile); ZipFile zf = new ZipFile(zipFile, fileEncode); Map&lt;String, Object&gt; fileMap = new HashMap&lt;&gt;(); InputStream is = null; try &#123; Enumeration&lt;ZipEntry&gt; entries = zf.getEntries(); while (entries.hasMoreElements()) &#123; ZipEntry ze = entries.nextElement(); String filePath = ze.getName(); if (ze.isDirectory()) &#123; continue; &#125; is = zf.getInputStream(ze); byte[] fileByteArr = toByteArray(is); if(fileByteArr.length &gt; FILE_LIMIT_SIZE)&#123; throw new Exception(\"文件\" + filePath + \"大小超过\" + FILE_LIMIT_SIZE / 1000 + \"KB\"); &#125;else &#123; fileMap.put(filePath, fileByteArr); &#125; &#125; &#125;finally&#123; if(is != null)&#123; is.close(); &#125; &#125; return fileMap; &#125; /** 检查文件的编码 */ private static String checkEncoding(File file) throws IOException &#123; InputStream is = new FileInputStream(file); byte[] b = new byte[3]; is.read(b); is.close(); if (b[0] == -17 &amp;&amp; b[1] == -69 &amp;&amp; b[2] == -65) return \"UTF-8\"; else return \"GBK\"; &#125; /** * 将inputStream读取位字节 * @param input * @return * @throws IOException */ private static byte[] toByteArray(InputStream input) throws IOException &#123; try &#123; ByteArrayOutputStream output = new ByteArrayOutputStream(); long count = 0L; int n; byte[] buffer = new byte[4096]; for(boolean var5 = false; -1 != (n = input.read(buffer)); count += (long)n) &#123; output.write(buffer, 0, n); &#125; //count =(count &gt; 2147483647L ? -1 : (int)count) ; return output.toByteArray(); &#125; catch (IOException ioe) &#123; throw new IOException(\"Zip读取数据失败：\"+ ioe.getMessage()); &#125; &#125;&#125;","categories":[],"tags":[{"name":"Utils","slug":"Utils","permalink":"https://pinksmallfan.github.io/WenChongAndJiaoKou/tags/Utils/"}]},{"title":"java获取证书对象、摘要、通用名","slug":"2018-12-16-java获取证书对象、摘要、通用名","date":"2018-12-16T08:16:55.000Z","updated":"2018-12-16T13:02:37.181Z","comments":true,"path":"2018/12/16/2018-12-16-java获取证书对象、摘要、通用名/","link":"","permalink":"https://pinksmallfan.github.io/WenChongAndJiaoKou/2018/12/16/2018-12-16-java获取证书对象、摘要、通用名/","excerpt":"","text":"简要介绍​ 通过java的方式来使用PKI常用的API，这里主要实现有：获取证书对象、获取摘要、获取证书CN项 代码构造证书对象1234567891011121314/** * 构造证书对象 * @param data 证书的字节数组 * @return 证书对象 */ public static X509Certificate ParseToCertObj(byte[] data) throws Exception &#123; CertificateFactory cf = null; cf = CertificateFactory.getInstance(\"X.509\"); X509Certificate cert = (X509Certificate) cf.generateCertificate(new ByteArrayInputStream(data)); return cert; &#125; 获取证书摘要12345678910/** * 获取摘要 * @param data 计算摘要值的原文 */ public static String getDigest(byte[] data) throws NoSuchAlgorithmException &#123; MessageDigest digest = MessageDigest.getInstance(\"SHA-1\"); digest.update(data); byte[] dg = digest.digest(); return HexEncoder.encode(dg); &#125; 获取证书CN项1234567891011121314151617181920212223242526String dn = x509certificate.getIssuerDN().getName();/*** 若无CN,依次用OU,O,EMAILADDRESS代替 */ public static String GetCNFromDN(String dn) &#123; int begin = dn.indexOf(\"CN=\"); if (begin &lt; 0) begin = dn.indexOf(\"OU=\"); if (begin &lt; 0) begin = dn.indexOf(\"O=\"); if (begin &lt; 0) begin = dn.indexOf(\"EMAILADDRESS=\"); if (begin &lt; 0) return dn; int begin2 = dn.indexOf(\"=\", begin); int end = dn.indexOf(\",\", begin2); if (end &lt; 0) end = dn.length(); String CN = dn.substring(begin2 + 1, end); // if (CN.startsWith(\"\\\"\") &amp;&amp; CN.endsWith(\"\\\"\")) CN = CN.substring(1, CN.length() - 1); return CN; &#125; all1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556import java.io.ByteArrayInputStream;import java.security.MessageDigest;import java.security.NoSuchAlgorithmException;import java.security.cert.CertificateFactory;import java.security.cert.X509Certificate;public class PKIUtils &#123; /** * 构造证书对象 * @param data 证书的字节数组 * @return 证书对象 */ public static X509Certificate ParseToCertObj(byte[] data) throws Exception &#123; CertificateFactory cf = null; cf = CertificateFactory.getInstance(\"X.509\"); X509Certificate cert = (X509Certificate) cf.generateCertificate(new ByteArrayInputStream(data)); return cert; &#125; /** * 获取摘要 * @param data 计算摘要值的原文 */ public static String getDigest(byte[] data) throws NoSuchAlgorithmException &#123; MessageDigest digest = MessageDigest.getInstance(\"SHA-1\"); digest.update(data); byte[] dg = digest.digest(); return HexEncoder.encode(dg); &#125; // 若无CN,依次用OU,O,EMAILADDRESS代替 public static String GetCNFromDN(String dn) &#123; int begin = dn.indexOf(\"CN=\"); if (begin &lt; 0) begin = dn.indexOf(\"OU=\"); if (begin &lt; 0) begin = dn.indexOf(\"O=\"); if (begin &lt; 0) begin = dn.indexOf(\"EMAILADDRESS=\"); if (begin &lt; 0) return dn; int begin2 = dn.indexOf(\"=\", begin); int end = dn.indexOf(\",\", begin2); if (end &lt; 0) end = dn.length(); String CN = dn.substring(begin2 + 1, end); // if (CN.startsWith(\"\\\"\") &amp;&amp; CN.endsWith(\"\\\"\")) CN = CN.substring(1, CN.length() - 1); return CN; &#125;&#125;","categories":[],"tags":[{"name":"PKI","slug":"PKI","permalink":"https://pinksmallfan.github.io/WenChongAndJiaoKou/tags/PKI/"}]},{"title":"spring-boot2.1+thymeleaf简单的web开发","slug":"2018-12-11-spring-boot2.1+thymeleaf简单的web开发","date":"2018-12-11T07:50:04.000Z","updated":"2018-12-16T13:01:42.744Z","comments":true,"path":"2018/12/11/2018-12-11-spring-boot2.1+thymeleaf简单的web开发/","link":"","permalink":"https://pinksmallfan.github.io/WenChongAndJiaoKou/2018/12/11/2018-12-11-spring-boot2.1+thymeleaf简单的web开发/","excerpt":"","text":"开发工具 IDEA 工程结构 开发流程POM1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.1.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;xx.seal&lt;/groupId&gt; &lt;artifactId&gt;importdatabase&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;importdatabase&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!--可以不用，用于bo的get/set注释--&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.16.10&lt;/version&gt; &lt;/dependency&gt; &lt;!--开发工具-热部署--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; bo12345678910111213141516171819import lombok.Getter;import lombok.Setter;@Getter@Setterpublic class User &#123; private int id; private String userName; private String seal; public User()&#123;&#125; public User(int id, String userName, String seal)&#123; this.id = id; this.userName = userName; this.seal = seal; &#125;&#125; controller123456789101112131415161718192021222324252627282930import xxx.seal.importdatabase.bo.User;import xxx.seal.importdatabase.service.UserService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.GetMapping;import java.util.ArrayList;import java.util.List;@Controllerpublic class UserController &#123; @Autowired UserService userService; @GetMapping(path = &#123;\"/user/list\", \"list\"&#125;) public String getUserList(Model model) throws Exception&#123; List&lt;User&gt; userList = new ArrayList&lt;User&gt;(); for (int i = 0; i &lt;10; i++) &#123; userList.add(new User(i,\"admin\"+i,\"中国广州\")); &#125; model.addAttribute(\"hello\", \"Hello, Spring Boot!\"); model.addAttribute(\"userList\",userService.userList()); return \"list\"; &#125;&#125; service1234567891011121314151617181920212223242526272829303132333435import xxx.seal.importdatabase.bo.User;import org.springframework.stereotype.Service;import java.util.ArrayList;import java.util.List;@Servicepublic class UserService &#123; public List&lt;User&gt; userList()&#123; List&lt;User&gt; users = new ArrayList&lt;User&gt;(); User user1 = new User(); User user2 = new User(); User user3 = new User(); user1.setId(1); user1.setSeal(\"MIXNK\"); user1.setUserName(\"admin\"); users.add(user1); user2.setId(2); user2.setSeal(\"MIXNKaa\"); user2.setUserName(\"aguicode\"); users.add(user2); user3.setId(3); user3.setSeal(\"MIXNKcc\"); user3.setUserName(\"lmg\"); users.add(user3); return users; &#125;&#125; application12345678910import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplicationpublic class ImportdatabaseApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ImportdatabaseApplication.class, args); &#125;&#125; html1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;title&gt;用户列表&lt;/title&gt; &lt;link href=&quot;/css/main.css&quot; rel=&quot;stylesheet&quot; /&gt;&lt;/head&gt;&lt;body&gt;&lt;h1 th:text=&quot;$&#123;hello&#125;&quot;&gt;Hello, Spring Boot!&lt;/h1&gt;&lt;table&gt; &lt;tr&gt; &lt;th&gt;ID&lt;/th&gt; &lt;th&gt;用户名&lt;/th&gt; &lt;th&gt;签章base64编码&lt;/th&gt; &lt;/tr&gt; &lt;tr th:each=&quot;user : $&#123;userList&#125;&quot;&gt; &lt;td th:text=&quot;$&#123;user.id&#125;&quot;&gt;0&lt;/td&gt; &lt;td th:text=&quot;$&#123;user.userName&#125;&quot;&gt;adminSuper&lt;/td&gt; &lt;td th:text=&quot;$&#123;user.seal&#125;&quot;&gt;xxxxxx&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt; 配置application12345678910111213141516# url pathserver.port=8088server.servlet.context-path=/importDatabases# thymeleafspring.thymeleaf.prefix=classpath:/templates/spring.thymeleaf.suffix=.htmlspring.thymeleaf.mode=HTMLspring.thymeleaf.encoding=UTF-8spring.thymeleaf.servlet.content-type=text/html# 开发阶段关闭缓存 (=false)spring.thymeleaf.cache=false#指定某些文件不进行监听，即不会进行热加载spring.devtools.restart.exclude=application.properties log4j1234567891011121314151617181920212223242526272829#等级可分为OFF、FATAL、ERROR、WARN、INFO、DEBUG、ALL#Log4j建议只使用四个级别，优先级从高到低分别是ERROR、WARN、INFO、DEBUG####################################### Set log levels INFO DEBUG######################################log4j.rootLogger=INFO,console,rolling_file####################################### console Appender 设置输出到控制台######################################log4j.appender.console=org.apache.log4j.ConsoleAppenderlog4j.appender.console.Encoding=UTF-8log4j.appender.console.layout=org.apache.log4j.SimpleLayout#######################################rolling_file Appender 设置输出到日志文件#说明：文件大小到达指定尺寸的时候产生一个新的文件######################################log4j.appender.rolling_file=org.apache.log4j.RollingFileAppenderlog4j.appender.rolling_file.Encoding=UTF-8log4j.appender.rolling_file.ImmediateFlush=truelog4j.appender.rolling_file.MaxFileSize=50MBlog4j.appender.rolling_file.MaxBackupIndex=30log4j.appender.rolling_file.File=$&#123;catalina.home&#125;/logs/XXX_log.txtlog4j.appender.rolling_file.layout=org.apache.log4j.PatternLayoutlog4j.appender.rolling_file.layout.ConversionPattern=[%-5p|%d&#123;yyyy-MM-dd HH:mm:ss.S&#125; |%t |%c]- %m%n 启动命令行：mvn springboot-run 页面输入：http://192.168.20.138:8088/importDatabases/user/list","categories":[],"tags":[{"name":"spring boot","slug":"spring-boot","permalink":"https://pinksmallfan.github.io/WenChongAndJiaoKou/tags/spring-boot/"}]},{"title":"mysql5.7免安装与配置","slug":"2018-12-10-mysql5.7安装与配置","date":"2018-12-10T08:20:02.000Z","updated":"2018-12-16T08:16:33.659Z","comments":true,"path":"2018/12/10/2018-12-10-mysql5.7安装与配置/","link":"","permalink":"https://pinksmallfan.github.io/WenChongAndJiaoKou/2018/12/10/2018-12-10-mysql5.7安装与配置/","excerpt":"","text":"解压文件1.svn目录：\\192.168.0.8\\software\\数据库软件\\mysql\\mysql-5.7.18-winx64.zip 2.解压：mysql-5.7.18-winx64安装包，解压结果如下： 3.因为是免安装版本（其实msi安装也一样），所以就只有以上的文件 4.添加一个data文件夹到mysql的根目录下（与bin、docs等同级目录） 安装配置 mysql5.7及以上的版本，如果没有my.default.ini，那么也不需要什么my.ini 环境变量，设置MYSQL_HOME，并添加 ;%MYSQL_HOME%/bin到path上 管理员登录cmd mysqld的安装：mysqld -install（删除mysql：mysqld -remove） 设置密码默认为空（重要）：mysqld –initialize-insecure –user=mysql 开启服务：net start mysql（关闭服务：net stop mysql） 登录mysql：mysql -h localhost -u root -p 退出mysql：在mysql&gt;输入quit 遇到的坑​ 我也是佩服我自己，装一次简简单单的mysql，会遇到那么多问题！无奈，只能一个个解决，不过静下心来解决，会发现自己原本可以快速解决的，而不是踩了一个坑后又一个坑，其实还是没有静下心来思考！ ==系统无法找到指定文件== 原因：重装了mysql，但是安装过程中，一些变量的填写有问题，比如my.ini的地址；也有可能是因为免安装的过程中，没有明确mysqld的目录。 解决方法：运行-regedit、在HKYE_LOCAL_MACHINE/SYSTEM/CurrentControlSet/Services/Mysql，修改ImagePath为mysqld的实际地址，比如说d:/mysql/bin/mnysqld 参考：https://blog.csdn.net/digitalmon/article/details/78152187、http://www.cnblogs.com/mlgjb/p/8761408.html、https://blog.csdn.net/lwl20140904/article/details/80806730 ==mysql服务正在启动或停止中请稍后片刻再试一下== 原因：因为有一些程序占用着mysqld，比如说，windows的【服务】，即服务管理窗口也会占用，所以需要关闭窗口，还需要卸载mysql，接着重新mysqld -remove，然后install就OK 参考：https://blog.csdn.net/qsysz_/article/details/82845152、https://blog.csdn.net/bluefish_flying/article/details/77930375 ==彻底卸载mysql== 1）控制面板-管理工具-服务，停止mysql服务，或者是命令：net stop mysql 2）关闭进程（可以通过taskkill /pid 1688 /F的方式强制删除进程） 3）通过控制面板卸载mysql（如果有mysql字样的话） 4）删除C盘带有mysql和my.ini等字样的文件与文件夹 5）注册表删除mysql，运行-regedit，删除如下： HKEY_LOCAL_MACHINE\\SYSTEM\\ControlSet001\\Services\\Eventlog\\Application\\MySQL文件夹 HKEY_LOCAL_MACHINE\\SYSTEM\\ControlSet002\\Services\\Eventlog\\Application\\MySQL文件夹。 HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\Eventlog\\Application\\MySQL文件夹 参考：https://www.cnblogs.com/Sue_/p/3274063.html ==1067== 原因：my.ini配置的问题 解决方法： 1）如果是5.7及以上的，直接删除my.ini，重新卸载和安装 2）my.ini中engine的，改为default-storage-engine=MyISAM 参考：https://www.cnblogs.com/hoobey/p/5220090.html ==1058== 参考：https://blog.csdn.net/u012586848/article/details/46860839 ==mysql服务无法启动== 原因：mysql免安装中，my.ini中明确有一个data文件夹，但是实际上没有新建这个data文件夹 解决，在mysql根目录（docs、bin等目录同级），创建一个data文件夹 参考：https://www.cnblogs.com/xixihuang/p/5663559.html ==windows服务：被标记为删除== 原因：后台线程未关闭，mysql被占用 解决：通过资源管理器结束进程，关闭服务窗口（可参考==mysql服务正在启动或停止中请稍后片刻再试一下==） 参考：https://blog.csdn.net/iceagezh/article/details/79004443、https://blog.csdn.net/bluefish_flying/article/details/77930375 ==mysql忘记密码== 1）关闭mysql服务（服务管理中停止mysql，或者是命令：net stop mysql） 2）在mysql的目录下，进入bin，打开命令行，输入mysqld –skip-grant-tables，会自动挂起 3）重新打开一个命令行，输入mysql -h localhost -uroot -p 4）选择能够修改用户的数据库：use mysql 5）mysql5.7及以上，修改用户密码：UPDATE user SET authentication_string=PASSWORD(“123456”) WHERE User=”root”; flush privileges 6）删除挂起的命令行，在新开的命令行，输入root/123456 参考：https://www.cnblogs.com/SmartNing/p/5178628.html ==查看文件或文件夹被那个进程占用== 1）打开资源管理器（桌面栏，右键） 2）任务管理器-性能-资源监视器-CPU-关联的句柄 3）输入文件名、文件夹名，进行搜索 参考：https://blog.csdn.net/jlminghui/article/details/78456182 ==mysql初始化timestamp== 原因：mysql的timestamp初始化不允许为不合法的字符 解决：修改sql_mode 1）查看，show variables like ‘sql_mode’; 2）修改，set sessionsql_mode=’ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION’; 参考：https://blog.csdn.net/cuiaamay/article/details/53896623 ==mysql安装缺少C++环境==：https://www.microsoft.com/en-us/download/confirmation.aspx?id=40784 用到的命令关闭防火墙：netsh firewall set opmode disable 杀死某个进程：taskkill /pid 1688 /F","categories":[],"tags":[{"name":"安装","slug":"安装","permalink":"https://pinksmallfan.github.io/WenChongAndJiaoKou/tags/安装/"}]},{"title":"docker的使用","slug":"2018-12-5-docker的使用","date":"2018-12-05T14:49:19.000Z","updated":"2018-12-05T14:56:11.657Z","comments":true,"path":"2018/12/05/2018-12-5-docker的使用/","link":"","permalink":"https://pinksmallfan.github.io/WenChongAndJiaoKou/2018/12/05/2018-12-5-docker的使用/","excerpt":"","text":"docker ps 查看docker下正在运行的镜像（需要注意的是CONTAINER ID） docker exec -it de9fa67527f6 /bash 进入docker对应的CONTAINER ID镜像 docker stop de9fa67527f6 关闭docker对应的CONTAINER ID镜像（例如de9fa67527f6代表的是mysql，那么就是关闭mysql） docker start mysql_5.7.19 在docker启动mysql docker exec -it mysql_5.7.19 bash 在docker启动mysql docker images 查看挂载在docker的所有镜像 docker info 查看docker的详细信息","categories":[],"tags":[{"name":"docker","slug":"docker","permalink":"https://pinksmallfan.github.io/WenChongAndJiaoKou/tags/docker/"}]},{"title":"Linux下最优的tomcat调优","slug":"2018-12-3-Linux下最优的tomcat调优","date":"2018-12-03T07:14:23.000Z","updated":"2018-12-04T16:19:30.877Z","comments":true,"path":"2018/12/03/2018-12-3-Linux下最优的tomcat调优/","link":"","permalink":"https://pinksmallfan.github.io/WenChongAndJiaoKou/2018/12/03/2018-12-3-Linux下最优的tomcat调优/","excerpt":"","text":"Linux系统，参数读取命令 tomcat优化的大致方向，流程 实践-反馈-知识-反馈-实践 笔记 代码流程 Linux系统配置优化建议：https://www.jianshu.com/p/98a14527afdc Tomcat系统配置优化建议：http://blog.sina.com.cn/s/blog_605f5b4f01012ljj.html Tomcat系统参数详解：https://www.cnblogs.com/kismetv/p/7806063.html JVM查看java内存情况：https://www.cnblogs.com/anjijiji/p/6239395.html 远程连接Linux的jconsole：http://elf8848.iteye.com/blog/471676 慢查询：https://www.jianshu.com/p/43091bfa8aa7 计算、IO阻塞两个部分 场景​ 在性能好的服务器机子，可以接纳的并发数大，但是在一些Linux系统，资源有限，可能就没能提供这么大的并发数，这个时候就需要通过Linux系统的配置，来制定一个最优的服务器配置，达到最大可能的并发量。 Linux系统配置配置磁盘1234567df -h # 将磁盘容量通过易读的格式显示df -m # 将通过以mb为单位，显示磁盘容量df -k # 将通过以kb为单位，显示磁盘容量du # 查看当前目录下文件的容量du -a # 查看当前目录下所有文件的容量du -sb /* # 查看当前目录下文件占用的容量，bytes为单位du -sm /* # 查看当前目录下文件占用的容量，mb为单位 示例如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758[root@localhost Desktop]# df -hFilesystem Size Used Avail Use% Mounted on/dev/sda2 18G 2.5G 15G 15% /tmpfs 491M 224K 491M 1% /dev/shm/dev/sda1 283M 36M 232M 14% /boot[root@localhost Desktop]# df -hkFilesystem 1K-blocks Used Available Use% Mounted on/dev/sda2 18208184 2582168 14694432 15% /tmpfs 502384 372 502012 1% /dev/shm/dev/sda1 289293 36855 237078 14% /boot[root@localhost Desktop]# df -hmFilesystem 1M-blocks Used Available Use% Mounted on/dev/sda2 17782 2522 14351 15% /tmpfs 491 1 491 1% /dev/shm/dev/sda1 283 36 232 14% /boot[root@localhost ~]# du -a4 ./.cshrc4 ./.xauthi9aZjs4 ./.bashrc4 ./.bash_logout4 ./.pki/nssdb8 ./.pki4 ./.bash_history4 ./.bash_profile12 ./install.log.syslog4 ./.tcshrc4 ./.xauth7a1Svt4 ./.xauthbyRxSH4 ./anaconda-ks.cfg4 ./.xauthK4fQJz48 ./install.log116 .[root@localhost ~]# du -sm /*8 /bin35 /boot1 /dev40 /etc21 /home170 /lib27 /lib641 /lost+found1 /media1 /mnt1 /optdu: cannot access `/proc/3006/task/3006/fd/4': No such file or directorydu: cannot access `/proc/3006/task/3006/fdinfo/4': No such file or directorydu: cannot access `/proc/3006/fd/4': No such file or directorydu: cannot access `/proc/3006/fdinfo/4': No such file or directory0 /proc1 /root15 /sbin0 /selinux1 /srv0 /sys1 /tmp2083 /usr257 /var 进程12345678910ps -lA # 查看系统所有的进程ps -l # 查看仅自己bash的进程ps aux # 查看系统所有的进程ps aux --sort -pcpu # 根据CPU的占用比例来查看系统所有进程ps aux --sort -pmem # 根据内存的占用比例来查看系统所有进程ps aux --sort -pid # 根据pid由大到小来查看系统所有进程top # 动态查看进程状况top -d 5 # 动态的，每5秒刷新一次，显示进程状况top -d 10 -p 1 # 动态的，每5秒刷新一次，显示PID为1的进程状况kill -9 2333 # 删除pid为2333的进程 示例如下（截取）： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657[root@localhost ~]# ps -lAF S UID PID PPID C PRI NI ADDR SZ WCHAN TTY TIME CMD4 S 0 1 0 0 80 0 - 4841 poll_s ? 00:00:02 init1 S 0 2 0 0 80 0 - 0 kthrea ? 00:00:00 kthreadd1 S 0 3 2 0 -40 - - 0 migrat ? 00:00:00 migration/01 S 0 4 2 0 80 0 - 0 ksofti ? 00:00:00 ksoftirqd/01 S 0 5 2 0 -40 - - 0 cpu_st ? 00:00:00 stopper/05 S 0 6 2 0 -40 - - 0 watchd ? 00:00:00 watchdog/01 S 0 7 2 0 80 0 - 0 worker ? 00:00:00 events/01 S 0 8 2 0 80 0 - 0 worker ? 00:00:00 events/0[root@localhost ~]# ps auxUSER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMANDroot 1 0.1 0.1 19364 1540 ? Ss 14:09 0:02 /sbin/initroot 2 0.0 0.0 0 0 ? S 14:09 0:00 [kthreadd]root 3 0.0 0.0 0 0 ? S 14:09 0:00 [migration/0]root 4 0.0 0.0 0 0 ? S 14:09 0:00 [ksoftirqd/0]root 5 0.0 0.0 0 0 ? S 14:09 0:00 [stopper/0]root 6 0.0 0.0 0 0 ? S 14:09 0:00 [watchdog/0]root 7 0.0 0.0 0 0 ? S 14:09 0:00 [events/0]root 8 0.0 0.0 0 0 ? S 14:09 0:00 [events/0]root 9 0.0 0.0 0 0 ? S 14:09 0:00 [events_long/0]root 10 0.0 0.0 0 0 ? S 14:09 0:00 [events_power_ef]root 11 0.0 0.0 0 0 ? S 14:09 0:00 [cgroup]root 12 0.0 0.0 0 0 ? S 14:09 0:00 [khelper][root@localhost ~]# ps -lF S UID PID PPID C PRI NI ADDR SZ WCHAN TTY TIME CMD4 S 0 2934 2919 0 80 0 - 41308 wait pts/0 00:00:00 su4 S 0 2943 2934 0 80 0 - 27085 wait pts/0 00:00:00 bash4 R 0 3146 2943 0 80 0 - 27033 - pts/0 00:00:00 ps[root@localhost ~]# ps aux --sort -pcpuUSER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMANDroot 2511 0.3 3.6 156432 36860 tty1 Ss+ 14:10 0:08 /usr/bin/Xorg :0 -br -verbose -audit 4 -auth /varroot 1625 0.1 0.8 251432 8348 ? Sl 14:10 0:03 /usr/sbin/vmtoolsdpe 2827 0.1 1.6 269792 16608 ? S 14:11 0:03 /usr/lib/vmware-tools/sbin64/vmtoolsd -n vmusr --pe 2917 0.1 1.4 297200 14544 ? Sl 14:11 0:02 /usr/bin/gnome-terminal -x /bin/sh -c cd '/home/proot 1 0.0 0.1 19364 1540 ? Ss 14:09 0:02 /sbin/initroot 2 0.0 0.0 0 0 ? S 14:09 0:00 [kthreadd]root 3 0.0 0.0 0 0 ? S 14:09 0:00 [migration/0]root 4 0.0 0.0 0 0 ? S 14:09 0:00 [ksoftirqd/0][root@localhost ~]# ps aux --sort -pmemUSER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMANDroot 1 0.0 0.1 19364 1540 ? Ss 14:09 0:02 /sbin/initroot 2 0.0 0.0 0 0 ? S 14:09 0:00 [kthreadd]root 3 0.0 0.0 0 0 ? S 14:09 0:00 [migration/0][root@localhost ~]# toptop - 15:00:30 up 50 min, 4 users, load average: 0.00, 0.02, 0.00Tasks: 143 total, 1 running, 142 sleeping, 0 stopped, 0 zombieCpu(s): 7.1%us, 1.0%sy, 0.0%ni, 91.8%id, 0.0%wa, 0.0%hi, 0.0%si, 0.0%stMem: 1004768k total, 925652k used, 79116k free, 86540k buffersSwap: 2031612k total, 8k used, 2031604k free, 382244k cached PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND 2511 root 20 0 198m 44m 8464 S 5.3 4.5 0:15.03 Xorg 2917 pe 20 0 290m 14m 9756 S 2.0 1.5 0:05.45 gnome-terminal 2771 pe 20 0 404m 12m 9732 S 1.0 1.2 0:01.18 metacity 1625 root 20 0 245m 8348 4812 S 0.7 0.8 0:04.55 vmtoolsd 2791 pe 20 0 921m 21m 14m S 0.7 2.2 0:02.50 nautilus 1694 root 20 0 505m 7884 4780 S 0.3 0.8 0:01.23 ManagementAgent 2755 pe 20 0 494m 11m 7916 S 0.3 1.2 0:00.66 gnome-settings- 2805 pe 20 0 298m 10m 8476 S 0.3 1.1 0:00.48 wnck-applet 2827 pe 20 0 263m 16m 13m S 0.3 1.7 0:03.73 vmtoolsd 1 root 20 0 19364 1540 1228 S 0.0 0.2 0:02.32 init 2 root 20 0 0 0 0 S 0.0 0.0 0:00.00 kthreadd 3 root RT 0 0 0 0 S 0.0 0.0 0:00.00 migration/0 [root@localhost Desktop]# top -d 10 -p 1top - 15:08:31 up 58 min, 4 users, load average: 0.10, 0.03, 0.01Tasks: 1 total, 0 running, 1 sleeping, 0 stopped, 0 zombieCpu(s): 1.1%us, 1.2%sy, 0.0%ni, 96.2%id, 1.5%wa, 0.0%hi, 0.0%si, 0.0%stMem: 1004768k total, 929992k used, 74776k free, 86556k buffersSwap: 2031612k total, 8k used, 2031604k free, 383544k cached PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND 1 root 20 0 19364 1540 1228 S 0.0 0.2 0:02.32 init 系统资源查看1234free -m # 查看内存使用情况(mb)free -b # 查看内存使用情况(byte)free -t # 查看内存使用情况(kb),显示totaluptime # 查看系统启动时间、工作负载 示例结果： 123456789101112131415161718[root@localhost Desktop]# free -m total used free shared buffers cachedMem: 981 918 62 3 85 423-/+ buffers/cache: 410 571 Swap: 1983 0 1983 [root@localhost Desktop]# free -b total used free shared buffers cachedMem: 1028882432 962957312 65925120 4022272 89210880 443887616-/+ buffers/cache: 429858816 599023616 Swap: 2080370688 8192 2080362496 [root@localhost Desktop]# free -t total used free shared buffers cachedMem: 1004768 940388 64380 3928 87120 433484-/+ buffers/cache: 419784 584984 Swap: 2031612 8 2031604 Total: 3036380 940396 2095984[root@localhost Desktop]# uptime 15:44:24 up 1:34, 4 users, load average: 0.00, 0.00, 0.00 网络12345netstat # 监控网络netstat -a # 监控网络所有的连接、监听、Socketnetstat -t # 监控网络中tcp网络数据包netstat -u # 监控网络中udp网络数据包netstat -tlnp # 查看系统上已有监听的网络连接与其PID 示例如下： 123456789[root@localhost Desktop]# netstat -tlnpActive Internet connections (only servers)Proto Recv-Q Send-Q Local Address Foreign Address State PID/Program name tcp 0 0 0.0.0.0:22 0.0.0.0:* LISTEN 2272/sshd tcp 0 0 127.0.0.1:631 0.0.0.0:* LISTEN 2108/cupsd tcp 0 0 127.0.0.1:25 0.0.0.0:* LISTEN 2404/master tcp 0 0 :::22 :::* LISTEN 2272/sshd tcp 0 0 ::1:631 :::* LISTEN 2108/cupsd tcp 0 0 ::1:25 :::* LISTEN 2404/master CPU1234567vmstat # 检查CPU、内存等的信息vmstat -fs # 检查内存相关vmstat -d # 检查系统磁盘的读写状态vmstat 1 3 # 每秒1次，记3次cat /proc/cpuinfo |grep \"physical id\"|sort|uniq|wc -l # 查看系统物理cpu数cat /proc/cpuinfo |grep \"cpu cores\"|wc -l # 查看系统cpu核数 cat /proc/cpuinfo |grep \"processor\"|wc -l # 查看系统cpu总数 示例如下： basic1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859[root@localhost ~]# cat /proc/cpuinfoprocessor : 0vendor_id : GenuineIntelcpu family : 6model : 63model name : Intel(R) Xeon(R) CPU E5-2630 v3 @ 2.40GHzstepping : 2microcode : 0x36cpu MHz : 2400.048cache size : 20480 KBphysical id : 0siblings : 1core id : 0cpu cores : 1apicid : 0initial apicid : 0fpu : yesfpu_exception : yescpuid level : 13wp : yesflags : fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush mmx fxsr sse sse2 ht syscall nx rdtscp lm constant_tsc rep_good nopl pni pclmulqdq ssse3 fma cx16 pcid sse4_1 sse4_2 x2apic movbe popcnt tsc_deadline_timer aes f16c rdrand hypervisor lahf_lm abm fsgsbase tsc_adjust bmi1 avx2 smep bmi2 erms invpcidbogomips : 4800.09clflush size : 64cache_alignment : 64address sizes : 46 bits physical, 48 bits virtualpower management:[root@localhost ~]# cat /proc/cpuinfo |grep &quot;physical id&quot;|sort|uniq|wc -l1[root@localhost ~]# cat /proc/cpuinfo |grep &quot;cpu cores&quot;|wc -l1[root@localhost ~]# cat /proc/cpuinfo |grep &quot;processor&quot;|wc -l1[root@localhost ~]# free -m total used free shared buffers cachedMem: 1783 1701 82 1 0 668-/+ buffers/cache: 1033 750Swap: 3727 1793 1934[root@localhost Desktop]# vmstat 1 3procs -----------memory---------- ---swap-- -----io---- --system-- -----cpu----- r b swpd free buff cache si so bi bo in cs us sy id wa st 0 0 8 68660 88456 429480 0 0 70 36 67 139 1 1 97 1 0 0 0 8 68660 88464 429476 0 0 0 16 57 88 0 0 99 1 0 0 0 8 68660 88464 429480 0 0 0 0 49 99 0 0 100 0 0 [root@localhost Desktop]# vmstat -d disk- ------------reads------------ ------------writes----------- -----IO------ total merged sectors ms total merged sectors ms cur secram0 0 0 0 0 0 0 0 0 0 0ram1 0 0 0 0 0 0 0 0 0 0ram2 0 0 0 0 0 0 0 0 0 0ram3 0 0 0 0 0 0 0 0 0 0loop1 0 0 0 0 0 0 0 0 0 0loop2 0 0 0 0 0 0 0 0 0 0loop3 0 0 0 0 0 0 0 0 0 0loop4 0 0 0 0 0 0 0 0 0 0sr0 0 0 0 0 0 0 0 0 0 0disk- ------------reads------------ ------------writes----------- -----IO------ total merged sectors ms total merged sectors ms cur secsda 27022 8888 969508 131052 5571 56722 498324 895653 0 145 Tomcat系统配置配置 $CATALINA_HOME下bin\\catalina.sh、或者setenv.sh，添加JAVA的堆内存 $CATALINA_HOME下conf\\server.xml，提高连接数 优化 关闭tomcat进程，top查看free的数量，接着设置$CATALINA_HOME/bin/setenv.sh，分配80%的free数（例如2048MB，那么可以参考配置如下） 1234export CATALINA_OPTS=\"$CATALINA_OPTS -Xms1600m\"export CATALINA_OPTS=\"$CATALINA_OPTS -Xmx1600m\"export CATALINA_OPTS=\"$CATALINA_OPTS -XX:MaxPermSize=256m\"export CATALINA_OPTS=\"$CATALINA_OPTS -XX:+PrintGCDetails -Xloggc:../logs/gc.log -XX:+PrintGCTimeStamps\" 关于连接数的建议。当系统资源有限，甚至只有1个CPU，那么这里不建议用来做并发处理！假设，1000并发，那么1个CPU会很累，因为在切换线程的时间，会随着并发数的增加而狂增，时间都花在了切换线程上了，会导致很多线程响应超时！ 需要考虑，程序是以IO上传下载为主，还是计算为主。如果IO为主，可以考虑增加连接数maxThread；如果以计算为主，那么就需要减少maxThread了，为了得到更多的资源处理计算，避免并发数太多，时间与资源都花在线程切换上，导致计算时间不足。 可以参考vmstat -d来查看读写；vmstat -fs查看内存相关","categories":[],"tags":[{"name":"配置","slug":"配置","permalink":"https://pinksmallfan.github.io/WenChongAndJiaoKou/tags/配置/"},{"name":"Linux","slug":"Linux","permalink":"https://pinksmallfan.github.io/WenChongAndJiaoKou/tags/Linux/"},{"name":"Tomcat","slug":"Tomcat","permalink":"https://pinksmallfan.github.io/WenChongAndJiaoKou/tags/Tomcat/"}]},{"title":"","slug":"about/积累方法","date":"2018-11-24T15:30:49.669Z","updated":"2018-11-24T15:41:34.869Z","comments":true,"path":"2018/11/24/about/积累方法/","link":"","permalink":"https://pinksmallfan.github.io/WenChongAndJiaoKou/2018/11/24/about/积累方法/","excerpt":"","text":"完成一个项目，就把流程写下来。 作为领导者，可以试着把自己的想学的技术分配出去 实时复盘，跟进新思想 今晚想熬夜了，想做完规定时间安排的任务","categories":[],"tags":[]},{"title":"R语言的基础学习","slug":"2018-11-22-R语言的基础学习","date":"2018-11-22T14:45:19.000Z","updated":"2018-11-24T12:52:15.364Z","comments":true,"path":"2018/11/22/2018-11-22-R语言的基础学习/","link":"","permalink":"https://pinksmallfan.github.io/WenChongAndJiaoKou/2018/11/22/2018-11-22-R语言的基础学习/","excerpt":"","text":"数据结构五种基本类型字符1x &lt;- \"233\" 数值12x &lt;- 3.14x &lt;- 1 整数1x &lt;- 3L 复数1x &lt;- 1+2i 逻辑1x &lt;- TRUE 向量12345678910111213141516171819# Vector# 三种表达方式x &lt;- vector(\"character\", length=10)x1 &lt;- 1:4x2 &lt;- c(1,2,3,4)x3 &lt;- c(TRUE,10,\"a\")x4 &lt;- c(\"a\",\"b\",\"c\")x5 &lt;- c(TRUE,FALSE)# 转换as.numeric(x2)as.logical(x5)as.character(x4)# 重命名class(x1)names(x2) &lt;- c(\"a\",\"b\",\"c\",\"d\")x2 矩阵矩阵=向量+纬度 1234567891011121314151617# matrix# 创建方法1x &lt;- matrix(1:6, nrow = 3, ncol = 2)# 创建方法2y &lt;- 1:6dim(y) &lt;- c(2,3)# 属性与纬度的查看dim(x)attributes(x)# 矩阵扩展y2 &lt;- matrix(1:6, nrow = 2, ncol = 3)rbind(y,y2)cbind(y,y2)y 数组数组 = 矩阵+n纬度 1234567# 数组x &lt;- array(1:24, dim = c(4,6))xx2 &lt;- array(1:24, dim = c(2,3,4))x2 列表1234567891011# 列表# 可以添加不同类型的变量listvalue &lt;- list(\"a\", 2, 10L, 1+2i, TRUE)listvaluelistvalue2 &lt;- list(c(1,2,3), c(\"a\",\"b\",\"c\"))listvalue2x &lt;- matrix(1:6, nrow = 2, ncol = 3)dimnames(x) &lt;- list(c(\"a\",\"b\"), c(\"c\",\"d\",\"e\"))x 因子1234567891011121314# 因子# 整数向量+标签x &lt;- factor(c(\"female\",\"female\",\"male\",\"female\",\"male\"))xy &lt;- factor(c(\"female\",\"female\",\"male\",\"female\",\"male\"),levels = c(\"male\", 'female'))ytable(x)table(y)unclass(x)class(x)class(unclass(x)) 缺失值NA NaN 123456789# 缺失值x &lt;- c(1, NA, 2, NA, 3)is.na(x)is.nan(x)y &lt;- c(1, NaN, 2, NaN, 3)is.na(y)is.nan(y) 数据框存储表格数据，视为各元素长度相同的列表 1234567891011# 数据框df &lt;- data.frame(id = c(1,2,3,4), name = c(\"a\",\"b\",\"c\",\"d\"), gender=c(TRUE, TRUE, FALSE, FALSE))dfnrow(df)ncol(df)df2 &lt;- data.frame(id = c(1,2,3,4), name = c(\"a\",\"b\",\"c\",\"d\"), score=c(80, 90, 100, 60))df2data.matrix(df2) 日期与时间1234567891011121314151617181920212223242526272829303132333435363738# 日期与时间# characterx &lt;- date()xclass(x)# Datex2 &lt;- Sys.Date()x2class(x2)x3 &lt;- as.Date(\"2018-11-23\")x3class(x3)weekdays(x3)months(x3)quarters(x3)julian(x3)x4 &lt;- as.Date(\"2018-04-25\")x3-x4as.numeric(x3-x4)# -----------------------x &lt;- Sys.time()xclass(x)p &lt;- as.POSIXlt(x)pclass(p)# 获取p下的属性名称names(unclass(p))# 获取p下对应属性的值p$sec 小结 构建子集获取预处理数据 原始数据，经过预处理后的数据 []：提取一个或多个类型相同的元素[[]]：从列表或数据框中提取元素$：按名字从列表或数据框中提取元素 123456789101112131415161718192021# 构建子集x &lt;- 1:10x[1]# 获取大于5的数据x[6:10]x&gt;5x[x&gt;5]# 获取大于5且小于7的数据x[x&gt;5 &amp; x&lt;7]# 获取大于5，与小于3的数据x[x&gt;5 | x&lt;3]y &lt;- 1:4names(y) &lt;- c(\"a\",\"b\",\"c\",\"d\")yy[1]y[\"a\"] 构建矩阵子集12345678910111213141516# 构建矩阵子集x &lt;- matrix(1:6, nrow = 3, ncol = 2)xx[1,2]x[1,]# 获取第1、3行的第2列x[c(1,3), 2]class(x[1,2])# 只显示行x[1,2]# 将行和列都显示出来x[1,2, drop=FALSE] 构建数据框的子集123456789101112131415161718192021# 构建数据框的子集x &lt;- data.frame(v1=1:5, v2=6:10, v3=11:15)xx$v1x$v1[c(1,3)]x[,2]x[,\"v2\"]x[1,\"v2\"]x[(x$v1&lt;4 &amp; x$v2&gt;7),]x$v1&lt;4which(x$v1&lt;4)x[x$v1&lt;4,]x[which(x$v1&lt;4),]# 方法2subset(x, x$v1&gt;3) 构建列表的子集12345678910111213141516171819202122232425262728293031# 构建矩列表子集x &lt;- list(id=1:4, height=170, gender=\"male\")x[1]x[\"id\"]x[[1]]x[[\"id\"]]x$idx[c(1,3)]y &lt;- list(a = list(4,3,2,1), b=c(\"Monday\", \"Tuesday\"))yy[[1]]# 获取第一个列表中含有列表的元素y[[1]][2]# 获取第一个列表中含有列表的对应值y[[1]][[2]]y[[c(1,3)]]y[[c(2,2)]]# 列表的不完全匹配z &lt;- list(abcdefg=1:10, abcd=1:4)z$abcdefgz$abcdez[[\"abcde\"]]z[[\"abcde\", exact = FALSE]] 处理缺失值123456789101112131415161718192021# 处理缺失值x &lt;- c(1, NA, 2, NA, 3)is.na(x)# 获取不是缺失值的值x[!is.na(x)]y &lt;- c(\"a\", \"b\", NA, \"c\", NA)z &lt;- complete.cases(x,y)zx[z]y[z]# 数据集library(datasets)head(airquality)g &lt;- complete.cases(airquality)g# 获取没有缺失值的前1-10行数据airquality[g,][1:10,] 向量化操作12345678910111213141516171819# 向量化操作x &lt;- 1:5y &lt;- 6:10z &lt;- x+yzx*yy/xx &lt;- matrix(1:4, nrow=2, ncol=2)y &lt;- matrix(rep(2,4), nrow=2, ncol=2)xyx*yy/x# 矩阵乘法x %*% y 小结 R语言函数lapplylapply-可以循环处理列表中的每一个元素-lapply（参数）：lapply（列表，函数/函数名，其他参数）-总是返回一个列表-sapply：简化结果·结果列表元素长度均为1，返回向量·结果列表元素长度相同且大于1，返回矩阵 123456789101112131415161718192021# lapply函数# 获取函数参数值str(lapply)x &lt;- list(a=1:10, b=c(11,21,31,41,51))# 求列表中的平均值lapply(x, mean)x &lt;- 1:4lapply(x,runif)# 依次循环获取x &lt;- list(a = matrix(1:6, 2,3), b = matrix(4:7,2,2))lapply(x, function(m) m[1,])x &lt;- list(a=1:10, b=c(11,21,31,41,51))# 求列表中的平均值lapply(x, mean)# 简化理解sapply(x, mean) apply-沿着数组的某一维度处理数据·例如：将函数用于矩阵的行或列·虽然与for/while循环的效率相似，但是只用一句话就可以完成-apply（参数）：apply（数组，维度，函数/函数名） 123456789101112131415161718192021222324# apply函数x &lt;- matrix(1:16, 4, 4)x# 行apply(x, 1, mean)rowMeans(x)apply(x, 1, sum)rowSums(x)# 列apply(x, 2, mean)colMeans(x)apply(x, 2, sum)colSums(x)x&lt;-matrix(rnorm(100),10,10)x&lt;-matrix(1:8,2,4)apply(x,1,quantile,probs=c(0.25,0.75))x&lt;-array(rnorm(2*3*4), c(2,3,4))apply(x,c(1,2),mean)apply(x,c(1,3),mean)apply(x,c(2,3),mean) mapply123456789101112# mapplylist(rep(1,4),rep(2,3),rep(3,2),rep(4,1))mapply(rep, 1:4, 4:1)s &lt;- function(n ,mean, std)&#123; rnorm(n ,mean, std)&#125;s(4, 0 ,1)mapply(s, 1:5, 5:1, 2)list(s(1,5,2), s(2,4,2), s(3,3,2), s(4,2,2), s(5,1,2)) tapply123456# tapplyx&lt;-c(rnorm(5),runif(5),rnorm(5,1))f&lt;-gl(3,5)tapply(x,f,mean)tapply(x,f,mean,simplify=FALSE) split12 参考视频：https://www.imooc.com/learn/546","categories":[],"tags":[{"name":"R语言","slug":"R语言","permalink":"https://pinksmallfan.github.io/WenChongAndJiaoKou/tags/R语言/"}]},{"title":"实践路线（微服务预习）","slug":"微服务预习","date":"2018-11-15T16:08:08.000Z","updated":"2018-11-15T16:11:31.038Z","comments":true,"path":"2018/11/16/微服务预习/","link":"","permalink":"https://pinksmallfan.github.io/WenChongAndJiaoKou/2018/11/16/微服务预习/","excerpt":"","text":"实践路线（github）github管理项目，呈现一个项目学习路线的面貌。打造个人品牌 [x] 【宿舍】使用SpringBoot快速构建RESTful API应用 [ ] 【公司】业务平台Spring改为SpringBoot项目 [ ] 【公司】SpringBoot的单元测试 [x] 【宿舍】SpringBoot的热部署等配置 [ ] 【宿舍】SpringCloud的初体验 [ ] 【公司】建立activeMQ，并与redis做结合 [ ] 【公司】将SpringBoot项目拆分为微服务 [ ] 【宿舍】实现将微服务注册到EurkaServer上 [ ] 【宿舍】SpringBoot容错处理搭建Hystrix [ ] 【宿舍】使用Ribbin实现客户端负载均衡 [ ] 【宿舍】实现Hystrix Dashboard可视化监控数据 [ ] 【公司】Elasticsearch日志存储系统搭建 [ ] 【公司】Logstash日志收集系统搭建 [ ] 【公司】Kiaabna日志查询系统搭建 [ ] 【宿舍】ELK日志中心搭建 [ ] 【宿舍】自主搭建系统监控中心 [ ] 【宿舍】Dubbo的初体验 [ ] 【宿舍】jenkins的持续集成搭建 [ ] 【宿舍】Docker镜像下载与构建 [ ] 【宿舍】使用Docker Registry打造私有镜像仓库 [ ] 【宿舍】使用Spring Cloud Bus实现配置的自动刷新 方式 3天制实现以上功能的每一个点 第一天，学习理论知识，并找如何搭建（前提：在公司也需要储备学习资源） 第二天，实践为主，完成以上的搭建任务（前提：在公司查看其他人怎么实现） 第三天，完善实践，标注学习日期，课本回顾（前提：完成实践内容） 传统单体架构及其面临的挑战传统单体架构分析​ 一个典型的单体应用就是将所有的业务场景的表示层、业务逻辑层和数据访问层放在一个工程中，最终经过编译、打包，部署在一台服务器上。例如典型的J2EE工程，它是将表示层的JSP、业务逻辑层的Service、Controller和数据访问层的Dao，打成war包，部署在Tomcat、Jetty或者其他Servlet容器中运行。 ​ 在一个小型应用的初始阶段，访问量较小，应用只需要一台服务器就能够部署所有的资源，例如将应用程序、数据库、文件资源等部署在同一台服务器上。最典型的就是LAMP系统，即服务器采用Linux系统，开发应用程序的语言为PHP，部署在Apache服务器上，采用MySQL数据库。在应用程序的初始阶段，采用这种架构的性价比是非常高的，开发速度快，开发成本低，只需要一台廉价的服务器。 单体架构的优势 开发特别快 开发初期，成本低，性价比高 根据MVC等标准风格，功能层次拆分清楚 部署简单，直接一个war包就能解决 技术单一，项目不需要复杂的技术栈，往往一套就可以开发完 单体架构局限性与面临的挑战 复杂性 ​ 整个项目包含的模块非常多，模块的边界模糊，依赖关系不清晰，代码质量参差不齐……整个项目非常复杂。每次修改代码都心惊胆战，甚至添加一个简单的功能，或者修改一个BUG都会造成隐含的缺陷。 开发效率 ​ 单体式架构下的组织通常来说技术选型非常单一，团队技术能力相对单薄，团队的吸引力一般。 ​ 整个系统一个团队。如果系统变得庞大，成员就需要学习大量的代码和领域知识，团队内的沟通和协作也变得低效。 稳定性 ​ 某个功能模块出现bug，或者某个库出现问题，都可能导致整个进程宕机，影响整体的应用。 部署与运维成本 ​ 传统的单体架构，一长串的本地接口或者方法调用，冗长而臃肿，往往是一个人负责整个的开发和维护。随着业务的发展和需求的变化，本地代码的不断迭代和变更，会导致只有原来的开发者才能理解接口的逻辑顺序，调用关系和功能需求，一旦开发者离职，那么功能模块运维就会非常困难。 ​ 测试、部署成本高，系统中任何功能的改变，都需要整个系统重新测试并部署。 新功能交付 ​ 直接本地API接口调用，不存在业务的拆分和相互调用，不需要依赖其他功能模块，这样子，开发只需要对自己开发的模块负责。这会导致代码重复率变高，功能变更或者新需求的加入会变得困难。 扩展能力 ​ 单体应用作为一个强耦合的整体，无法根据业务功能伸缩。只能再整体的系统进行扩展，而无法针对某一个功能模块按照需求扩展，比如计算密集型服务，IO密集型服务。 ​ 单体应用往往使用统一的技术平台或方案解决所有问题，团队的每个成员都必须使用相同的开发语言和架构，想要引入新的框架或技术平台非常困难。 如何解决上述问题？ 拆分 ​ 将应用进行水平和垂直的拆分，可以按照功能、技术群进行拆分（例如：商品中心、订单中心、审计）。 解耦 ​ 通过服务化和订阅、发布机制对应用调用关系解耦，支持服务的自动注册和发现 透明 ​ 通过服务注册中心管理服务的发布和消费、调用关系 独立 ​ 服务可以独立打包、发布、部署、启停、扩容和升级，核心服务独立集群部署 分层 ​ 梳理和抽取核心应用、公共应用，作为独立的服务下沉到核心和公共能力层，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求 结合某案例分析传统单体架构面临问题【案例】单体架构拆分服务水平拆分​ 按照数据的查询、存储、展示、采集的方向来进行拆分。 数据模型能否彻底分开，决定了微服务的边界功能是否彻底划清。 实践过程中强烈推荐的原则是一个微服务对应一个库 随着微服务规模壮大，可以针对性的做读写分离；如果单表数据庞大，可以分表来解决。 服务水平拆分面临问题 对于无法修改的遗留系统，推荐采用绞杀者模式：在遗留系统外面增加新的功能做成微服务方式，而不是直接修改原有系统，逐步的实现对老系统替换 规范整个系统而非微服务的日志体系，采用标准的日志格式非常便于后续的日志聚合检索，便于整体的视角分析、监控、查看系统； 同时做两件不可控的事情（微服务改造、新技术的冲击）注定项目成功概率较低，千万避免自己重复发明轮子，尽量选择市面上成熟的开源技术框架进行支撑，比如Spring Boot、Spring Cloud、Netflix、WildFly Swarm、Docker、Kubernetes等框架； 服务垂直拆分​ 按照展示层、应用层、领域层、基础设施层进行拆分。 服务拆分之后各模块间通信与交互服务的设计原则 复用性 耦合性 服务编排 自治 无状态 自动发现 服务拆分后面临挑战 调用性能 ​ 在服务化之前，业务通常都是本地API调用，本地方法调用性能损耗较小。服务化之后，服务提供者和消费者之间采用远程网络通信，增加了额外的性能损耗。 线性扩展 ​ 服务监控 故障定位 ​ 在分布式环境下，如何快速有效的进行故障问题定界定位 日志搜索 ​ 在分布式环境下，如何方便的进行对服务调用日志做高效的检索 流控 ​ 服务化、分布式部署之后，有逻辑关联关系的多个数据库操作被打散成各自独立的服务实例上去，引入分布式环境下的事务一致性问题 客户端需求和每个微服务暴露的细粒度API不匹配 微服务使用的RPC私有协议，不是浏览器友好或防火墙友好的 微服务难以重构。随着时间推移，我们可能想要更改系统划分成服务的方式。如果客户端与微服务直接通信，那么执行这类重构就非常困难了 微服务架构综述什么是微服务？​​ 简而言之，微服务架构风格的开发方法，是以开发一组小型服务的方式来开发一个独立的应用系统的。其中每个小型服务都运行在自己的进程中，并经常采用HTTP资源API轻量的机制来相互通信。 ​ 这些服务围绕业务功能进行构建，并能通过全自动的部署机制来进行独立部署。这些微服务可以使用不同的语言来编写，并且可以使用不同的数据存储技术。对这些微服务我们仅做最低限度的集中管理。 ​ 每个微服务可独立运行在自己的进程里； ​ 一系列独立运行的微服务共同构建起整个系统； ​ 服务为独立的业务开发，一个微服务只关注某个特定的功能，如订单管理、用户管理等； ​ 微服务之间通过一些轻量的通信机制进行通信，如REST API进行调用； ​ 使用不同的语言与存储技术； ​ 全自动的部署机制； 微服务架构出处：微服务架构 网关集群：数据的聚合、实现对接入客户端的身份认证、防报文重放与防数据篡改、功能调用的业务鉴权、响应数据的脱敏、流量与并发控制等 业务集群：一般情况下移动端访问和浏览器访问的网关需要隔离，防止业务耦合 Local Cache：由于客户端访问业务可能需要调用多个服务聚合，所以本地缓存有效的降低了服务调用的频次，同时也提示了访问速度。本地缓存一般使用自动过期方式，业务场景中允许有一定的数据延时。 服务层：原子服务层，实现基础的增删改查功能，如果需要依赖其他服务需要在Service层主动调用 Remote Cache：访问DB前置一层分布式缓存，减少DB交互次数，提升系统的TPS DAL：数据访问层，如果单表数据量过大则需要通过DAL层做数据的分库分表处理。 MQ：消息队列用来解耦服务之间的依赖，异步调用可以通过MQ的方式来执行 数据库主从：服务化过程中毕竟的阶段，用来提升系统的TPS 微服务架构优点​ 易于开发和维护。一个微服务只关注一个特定的业务功能，所以它的业务清晰、代码量较少。开发和维护单个微服务相对比较简单，整个应用是由若干个微服务构建而成，所以整个应用也会维持在可控状态； ​ 单个微服务启动较快。单个微服务代码量较少，所以启动会比较快；​ 修改容易部署。单体应用只要有修改，就要重新部署整个应用，微服务解决了这样的问题。一般来说，对某个微服务进行修改，只需要重新部署这个服务即可； ​ 技术栈不受限。在微服务中，我们可以结合项目业务及团队的特点，合理地选择技术栈； 出处：微服务优势 1、降低复杂度 将原来偶合在一起的复杂业务拆分为单个服务，规避了原本复杂度无止境的积累。每一个微服务专注于单一功能，并通过定义良好的接口清晰表述服务边界。每个服务开发者只专注服务本身，通过使用缓存、DAL等各种技术手段来提升系统的性能，而对于消费方来说完全透明。 2、可独立部署 由于微服务具备独立的运行进程，所以每个微服务可以独立部署。当业务迭代时只需要发布相关服务的迭代即可，降低了测试的工作量同时也降低了服务发布的风险。 3、容错 在微服务架构下，当某一组件发生故障时，故障会被隔离在单个服务中。 通过限流、熔断等方式降低错误导致的危害，保障核心业务正常运行。 4、扩展 单块架构应用也可以实现横向扩展，就是将整个应用完整的复制到不同的节点。当应用的不同组件在扩展需求上存在差异时，微服务架构便体现出其灵活性，因为每个服务可以根据实际需求独立进行扩展。 微服务架构面临的挑战有哪些？​ ​ 运维要求较高。更多的服务意味着更多的运维投入。在单体架构中只需要保证一个应用的正常运行；而在微服务中，需要保证几十甚至几百个服务的正常运行与协作，带来了巨大的挑战； ​ 分布式固有的复杂性。使用微服务构建的是分布式系统。对于一个分布式系统，系统容错、网络延迟、分布式事务等都带来了巨大的挑战；​ 成本高。微服务之间通过接口进行通信。如果修改某个微服务的API，可能所有使用了该接口的微服务都需要做调整； ​ 重复劳动。很多服务可能都会使用到相同的功能。而这个功能并没有达到分解为一个微服务的程度，这个时候，可能各个服务都会开发这一功能，导致代码重复。 微服务生命周期与交付流程 微服务管理规范​ 微服务带来的依赖管理问题，我们可以通过平台提供的API管理能力来解决。说到API管理，那首先就用提到服务契约。平台开发工具中提供了方便的服务发布能力，能够快速的将业务功能对外发布，生成服务的规格契约，当然也可以先设计服务契约，在根据契约来生成服务的默认实现代码。 ​ 这里强调一下，我们提到的服务契约是一个很重要的东西，他有点类似web service的wsdl描述，主要描述服务接口的输入输出规格标准和其他一些服务调用集成相关的规格内容。 微服务框架对比Spring Cloud与Dubbo 性能对比图片出处 ​ Spring Cloud 抛弃了 Dubbo 的 RPC 通信，采用的是基于 HTTP 的 REST 方式。严格来说，这两种方式各有优劣。虽然从一定程度上来说，基于 HTTP 的 REST 方式牺牲了服务调用的性能，但也避免了上面提到的原生 RPC 带来的问题。而且 REST 相比 RPC 更为灵活，服务提供方和调用方的依赖只依靠一纸契约，不存在代码级别的强依赖，这在强调快速演化的微服务环境下，显得更加合适。 服务对比图片出处 Dubbo 专注 RPC 和服务治理，Spring Cloud 则是一个微服务架构生态 组件对比出处：组件对比 Dubbo组件运行流程 gateWay:前置网关，具体业务操作，gateWay通过dubbo提供的负载均衡机制自动完成 Service：原子服务，只提供该业务相关的原子服务 Zookeeper：原子服务注册到zk上 Spring Could组件运行流程 所有请求都统一通过 API 网关（Zuul）来访问内部服务。 网关接收到请求后，从注册中心（Eureka）获取可用服务。 由 Ribbon 进行均衡负载后，分发到后端的具体实例。 微服务之间通过 Feign 进行通信处理业务。 服务依赖方式出处：服务依赖方式 Dubbo： ​ 因此需要为每个微服务定义了各自的interface接口，并通过持续集成发布到私有仓库中，调用方应用对微服务提供的抽象接口存在强依赖关系，开发、测试、集成环境都需要严格的管理版本依赖。 通过maven的install &amp; deploy命令把interface和Model层发布到仓库中，服务调用方只需要依赖interface和model层即可。在开发调试阶段只发布Snapshot版本。等到服务调试完成再发布Release版本，通过版本号来区分每次迭代的版本。通过xml配置方式即可方面接入dubbo，对程序无入侵。 Spring Cloud： ​ 服务提供方和服务消费方通过json方式交互，因此只需要定义好相关json字段即可，消费方和提供方无接口依赖。通过注解方式来实现服务配置，对于程序有一定入侵。 对比： ​ Dubbo服务依赖略重，需要有完善的版本管理机制，但是程序入侵少。而Spring Cloud通过Json交互，省略了版本管理的问题，但是具体字段含义需要统一管理，自身Rest API方式交互，为跨平台调用奠定了基础。 微服务架构及常用组件微服务开发之DubboDubbo介绍Dubbo 是一个分布式服务框架，是国内互联网公司开源做的比较不错的阿里开放的微服务化治理框架，致力于提供高性能和透明化的RPC远程服务调用方案，以及SOA服务治理方案。 其核心部分包含（官网）: 远程通讯: 提供对多种基于长连接的NIO框架抽象封装，包括多种线程模型，序列化，以及“请求-响应”模式的信息交换方式； 集群容错: 提供基于接口方法的透明远程过程调用，包括多协议支持，以及软负载均衡，失败容错，地址路由，动态配置等集群支持； 自动发现: 基于注册中心目录服务，使服务消费方能动态的查找服务提供方，使地址透明，使服务提供方可以平滑增加或减少机器。 为什么选择Dubbo? Dubbo 支持 RPC 调用，服务之间的调用性能会很好。 支持多种序列化协议，如 Hessian、HTTP、WebService。 Dobbo Admin后台管理功能强大，提供了路由规则、动态配置、访问控制、权重调节、均衡负载等功能。 在国内影响力比较大，中文社区文档较为全面。 阿里最近重启维护。 Dubbo架构剖析出处：结构剖析 Dubbo 核心部件（如下图）: Provider： 暴露服务的提供方，可以通过jar或者容器的方式启动服务 Consumer：调用远程服务的服务消费方。 Registry： 服务注册中心和发现中心。 Monitor： 统计服务和调用次数，调用时间监控中心。（dubbo的控制台页面中可以显示，目前只有一个简单版本） Container：服务运行的容器。 流程详解： 0 服务容器负责启动，加载，运行服务提供者（Standalone 容器）。 1 服务提供者在启动时，向注册中心注册自己提供的服务（Zookeeper/Redis）。 2 服务消费者在启动时，向注册中心订阅自己所需的服务。 3 注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。 4 服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。 5 服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心（根据数据可以动态调整权重）。 Dubbo优缺点分析出处：Dubbo 优缺点分析 Registry 严重依赖第三方组件（zookeeper 或者 redis），当这些组件出现问题时，服务调用很快就会中断。 Dubbo 只支持 RPC 调用。使得服务提供方（抽象接口）与调用方在代码上产生了强依赖，服务提供者需要不断将包含抽象接口的 jar 包打包出来供消费者使用。一旦打包出现问题，就会导致服务调用出错，并且以后发布部署会成很大问题（太强的依赖关系）。 另外，以后要兼容 .NET Core 服务，Dubbo RPC 本身不支持跨语言（可以用跨语言 RPC 框架解决，比如 Thrift、gRPC（重复封装了），或者自己再包一层 REST 服务，提供跨平台的服务调用实现，但相对麻烦很多） Dubbo 只是实现了服务治理，其他微服务框架并未包含，如果需要使用，需要结合第三方框架实现（比如分布式配置用淘宝的 Diamond、服务跟踪用京东的 Hydra，但使用相对麻烦些），开发成本较高，且风险较大。 社区更新不及时（虽然最近在疯狂更新），但也难免阿里以后又不更新了，就尴尬了。 主要是国内公司使用，但阿里内部使用 HSF，相对于 Spring Cloud，企业应用会差一些。 Dubbo调用地址与负载均衡出处：Dubbo的URL参数 name desc mock 配置此method在客户端调用时是直接调用，还是强制使用mock，还是调用失败后使用mock mock 配置此method在客户端调用时是直接调用，还是强制使用mock，还是调用失败后使用mock retries 调用Provider失败后的重试其他Provider的次数 forks 并发调用时Provider的个数 timeout 调用的Provider的超时时间，毫秒 merger MergeableClusterInvoker调用时，指定的merge方式或者merge方法 reference.filter 用于Consumer端控制、指定过滤器名称 service.filter 用于Provider端控制、指定过滤器名称 accesslog 用于控制AccessLogFilter是否加载进FilterChain中 actives 用于控制ActiveLimitFilter是否加载进FilterChain中 cache 用于控制CacheFilter是否加载进FilterChain中 deprecated 用于控制DeprecatedFilter是否加载进FilterChain中 executes 用于控制ExecuteLimitFilter是否加载进FilterChain中，以及指定信号量初始值单个Provider最大可并发数 generic 用于控制GenericImplFilter是否加载进FilterChain中 token 用于控制TokenFilter是否加载进FilterChain中 tps 用于控制TpsLimitFilter是否加载进FilterChain中 validation 用于控制ValidationFilter是否加载进FilterChain中 invoker.listener 用于控制invoker过程中的监听器名称 exporter.listener 用于控制export过程中的监听器名称 async Consumer端控制本地调用是否是异步调用 return Consumer端控制本地调用是否不需要调用返回值 connections 用于控制Consumer在调用多个Provider时，自身的connneticon是否共享或最大个数 codec 指定编码器 heartbeat 指定是否发送心跳，以及心跳的发送间隔 exchanger 指定exchanger扩展点的实现类 heartbeat.timeout 心跳超时时间 sent Consumer端发送时，Consumer的等待超时时间 codec 指定编码器 dispather 指定分发器 channel.handler 控制、指定handler处理器 threadname Provider端指定的线程池扩展点中线程名称 threads Provider端指定的线程池扩展点中核心线程数和最大线程数的数量 queues Provider端指定的线程池扩展点中队列的大小，0为使用SynchronousQueue，小于0为无限 dump.directory Provider端线程池线程越界时，jstack命令dump线程文件快照存储的路径 corethreads Provider端指定的线程池扩展点中cache/limited线程池核心线程数 alive Provider端指定的线程池扩展点中cache线程池线程空闲时间，毫秒 connect.queue.capacity Provider端dispatcher为connection时，指定线程池队列容量 connect.queue.warning.size Provider端dispatcher为connection时，指定线程池队列容量告警阈值 出处：负载均衡策略 Dubbo提供了多种均衡策略，缺省为random随机调用。 均衡策略 描述 Random LoadBalance 随机，按权重设置随机概率。在一个截面上碰撞的概率高，但调用量越大分布越均匀，而且按概率使用权重后也比较均匀，有利于动态调整提供者权重。 RoundRobin LoadBalance 轮循，按公约后的权重设置轮循比率。存在慢的提供者累积请求问题，比如：第二台机器很慢，但没挂，当请求调到第二台时就卡在那，久而久之，所有请求都卡在调到第二台上。 LeastActive LoadBalance 最少活跃调用数，相同活跃数的随机，活跃数指调用前后计数差。使慢的提供者收到更少请求，因为越慢的提供者的调用前后计数差会越大。 ConsistentHash LoadBalance 一致性Hash，相同参数的请求总是发到同一提供者。当某一台提供者挂时，原本发往该提供者的请求，基于虚拟节点，平摊到其它提供者，不会引起剧烈变动 Dubbo高可用机制Dubbo管控台与监控出处：Dubbo管控台和监控中心 管理控制台Dubbo-Admin管理控制台是一个可以直观看到并管理生产者消费者的平台.Dubbo-Admin本身就是一个java项目. 下载地址: https://github.com/alibaba/dubbo 在dubbo-admin上用mvn package就可以了 打好包后我们需要将war包解压缩到tomcat webapps的ROOT目录下.并更改配置文件,启动tomcat 配置文件: 123456#zookeeper地址dubbo.registry.address=zookeeper://127.0.0.1:2181 #管理员密码 管理账号rootdubbo.admin.root.password=root#访客密码dubbo.admin.guest.password=guest 验证是否安装成功,访问http://localhost:8080 出现如下页面证明安装成功 Dubbo监控中心Dubbo监控中心monitor主要是用来计数的,它所处的位置如下图,比如某个生产者被访问了多少次,当然官方提供的是一个简易的监控中心,我们也可以利用官方给出的api定制自己的监控中心. 基于Dubbo的项目应用案例分析【案例】安装 1tar -xzvf dubbo-monitor-simple-2.5.3-assembly.tar.gz 更改dubbo-monitor-simple-2.5.3-assembly/dubbo-monitor-simple-2.5.3/conf下的dubbo.properties 12345678910111213141516dubbo.container=log4j,spring,registry,jettydubbo.application.name=simple-monitordubbo.application.owner=#dubbo.registry.address=multicast://224.5.6.7:1234#zookeeper地址dubbo.registry.address=zookeeper://127.0.0.1:2181 #dubbo.registry.address=redis://127.0.0.1:6379#dubbo.registry.address=dubbo://127.0.0.1:9090dubbo.protocol.port=7070#注意这里,因为我们的管理控制台用tomcat启动,tomcat默认端口8080,所以这里我们用8090,可以看出官方给的简易监控中心使用jetty启动的.dubbo.jetty.port=8090 dubbo.jetty.directory=$&#123;user.home&#125;/monitordubbo.charts.directory=$&#123;dubbo.jetty.directory&#125;/chartsdubbo.statistics.directory=$&#123;user.home&#125;/monitor/statisticsdubbo.log4j.file=logs/dubbo-monitor-simple.logdubbo.log4j.level=WARN 接下来我们启动,进入dubbo-monitor-simple-2.5.3-assembly/dubbo-monitor-simple-2.5.3/bin目录,通过如下命令启动 12start.sh #linuxstart.bat #windows 访问:http://localhost:8090 如下页面启动成功: 微服务之Spring CloudSpring Cloud介绍​ 基于 Spring boot ​ 云服务、分布式框架集合 ​ Spring Cloud，来源于 Spring Source ，具有 Spring 社区的强大背书外，还有 Netflix 强大的后盾与技术输出。Netflix 作为一家成功实践微服务架构的互联网公司，在几年前就把几乎整个微服务框架栈开源贡献给了社区，这些框架开源的整套微服务架构套件是 Spring Cloud 的核心。 为什么选择Spring Cloud？出处：Spring Cloud优缺点 有强大的 Spring 社区、Netflix 等公司支持，并且开源社区贡献非常活跃。 标准化的将微服务的成熟产品和框架结合一起，Spring Cloud 提供整套的微服务解决方案，开发成本较低，且风险较小。 基于 Spring Boot，具有简单配置、快速开发、轻松部署、方便测试的特点。 支持 REST 服务调用，相比于 RPC，更加轻量化和灵活（服务之间只依赖一纸契约，不存在代码级别的强依赖），有利于跨语言服务的实现，以及服务的发布部署。另外，结合 Swagger，也使得服务的文档一体化。 提供了 Docker 及 Kubernetes 微服务编排支持。 国内外企业应用非常多，经受了大公司的应用考验（比如 Netfilx 公司），以及强大的开源社区支持。 Spring Cloud架构剖析出处：Spring Colud完整技术与组件架构 常用组件： Eureka: 服务注册发现框架； Zuul: 服务网关； Karyon: 服务端框架； Ribbon: 客户端框架； Hystrix: 服务容错组件； Archaius: 服务配置组件； Servo: Metrics组件； Blitz4j: 日志组件 流程： 请求统一通过 API 网关（Zuul）来访问内部服务。 网关接收到请求后，从注册中心（Eureka）获取可用服务。 由 Ribbon 进行均衡负载后，分发到后端具体实例。 微服务之间通过 Feign 进行通信处理业务。 Hystrix 负责处理服务超时熔断。 Turbine 监控服务间的调用和熔断相关指标。 Spring Cloud的工具框架出处：工具框架 Spring Cloud Config 配置中心，利用 Git 集中管理程序的配置。 Spring Cloud Netflix 集成众多Netflix的开源软件。 Spring Cloud Netflix Eureka 服务中心（类似于管家的概念，需要什么直接从这里取，就可以了），一个基于 REST 的服务，用于定位服务，以实现云端中间层服务发现和故障转移。 Spring Cloud Netflix Hystrix 熔断器，容错管理工具，旨在通过熔断机制控制服务和第三方库的节点，从而对延迟和故障提供更强大的容错能力。 Spring Cloud Netflix Zuul 网关，是在云平台上提供动态路由，监控，弹性，安全等边缘服务的框架。Web 网站后端所有请求的前门。 Spring Cloud Netflix Archaius 配置管理 API，包含一系列配置管理API，提供动态类型化属性、线程安全配置操作、轮询框架、回调机制等功能。 Spring Cloud Netflix Ribbon 负载均衡。 Spring Cloud Netflix Fegin REST客户端。 Spring Cloud Bus 消息总线，利用分布式消息将服务和服务实例连接在一起，用于在一个集群中传播状态的变化。 Spring Cloud for Cloud Foundry 利用 Pivotal Cloudfoundry 集成你的应用程序。 Spring Cloud Cloud Foundry Service Broker 为建立管理云托管服务的服务代理提供了一个起点。 Spring Cloud Cluster 集群工具，基于 Zookeeper, Redis, Hazelcast, Consul 实现的领导选举和平民状态模式的抽象和实现。 Spring Cloud Consul 基于 Hashicorp Consul 实现的服务发现和配置管理。 Spring Cloud Security 安全控制，在 Zuul 代理中为 OAuth2 REST 客户端和认证头转发提供负载均衡。 Spring Cloud Sleuth 分布式链路监控，SpringCloud 应用的分布式追踪系统，和 Zipkin，HTrace，ELK 兼容。 Spring Cloud Data Flow 一个云本地程序和操作模型，组成数据微服务在一个结构化的平台上。 Spring Cloud Stream 消息组件，基于 Redis，Rabbit，Kafka 实现的消息微服务，简单声明模型用以在 Spring Cloud 应用中收发消息。 Spring Cloud Stream App Starters 基于 Spring Boot 为外部系统提供 Spring 的集成。 Spring Cloud Task 短生命周期的微服务，为 Spring Booot 应用简单声明添加功能和非功能特性。 Spring Cloud Task App Starters。 Spring Cloud Zookeeper 服务发现和配置管理基于 Apache Zookeeper。 Spring Cloud for Amazon Web Services 快速和亚马逊网络服务集成。 Spring Cloud Connectors 便于PaaS应用在各种平台上连接到后端像数据库和消息经纪服务。 Spring Cloud Starters （项目已经终止并且在 Angel.SR2 后的版本和其他项目合并） Spring Cloud CLI 命令行工具，插件用 Groovy 快速的创建 Spring Cloud 组件应用。 Spring Cloud优缺点分析出处：Spring Cloud优缺点 支持 REST 服务调用，可能因为接口定义过轻，导致定义文档与实际实现不一致导致服务集成时的问题（可以使用统一文档和版本管理解决，比如 Swagger）。 另外，REST 服务调用性能会比 RPC 低一些（但也不是强绑定） Spring Cloud 整合了大量组件，相关文档比较复杂，需要针对性的进行阅读。 Spring Cloud负载均衡出处：SppringCloud负载均衡实践 出处：SpringCloud负载均衡策略 策略接口 描述 IRule 这是所有负载均衡策略的父接口，里边的核心方法就是choose方法，用来选择一个服务实例。 AbstractLoadBalancerRule AbstractLoadBalancerRule是一个抽象类，里边主要定义了一个ILoadBalancer，就是我们上文所说的负载均衡器，负载均衡器的功能我们在上文已经说的很详细了，这里就不再赘述，这里定义它的目的主要是辅助负责均衡策略选取合适的服务端实例。 RandomRule 看名字就知道，这种负载均衡策略就是随机选择一个服务实例，看源码我们知道，在RandomRule的无参构造方法中初始化了一个Random对象，然后在它重写的choose方法又调用了choose(ILoadBalancer lb, Object key)这个重载的choose方法，在这个重载的choose方法中，每次利用random对象生成一个不大于服务实例总数的随机数，并将该数作为下标所以获取一个服务实例。 RoundRobinRule RoundRobinRule这种负载均衡策略叫做线性负载均衡策略，也就是我们在上文所说的BaseLoadBalancer负载均衡器中默认采用的负载均衡策略。这个类的choose(ILoadBalancer lb, Object key)函数整体逻辑是这样的：开启一个计数器count，在while循环中遍历服务清单，获取清单之前先通过incrementAndGetModulo方法获取一个下标，这个下标是一个不断自增长的数先加1然后和服务清单总数取模之后获取到的（所以这个下标从来不会越界），拿着下标再去服务清单列表中取服务，每次循环计数器都会加1，如果连续10次都没有取到服务，则会报一个警告No available alive servers after 10 tries from load balancer: XXXX。 RetryRule 看名字就知道这种负载均衡策略带有重试功能。首先RetryRule中又定义了一个subRule，它的实现类是RoundRobinRule，然后在RetryRule的choose(ILoadBalancer lb, Object key)方法中，每次还是采用RoundRobinRule中的choose规则来选择一个服务实例，如果选到的实例正常就返回，如果选择的服务实例为null或者已经失效，则在失效时间deadline之前不断的进行重试（重试时获取服务的策略还是RoundRobinRule中定义的策略），如果超过了deadline还是没取到则会返回一个null。 WeightedResponseTimeRule WeightedResponseTimeRule是RoundRobinRule的一个子类，在WeightedResponseTimeRule中对RoundRobinRule的功能进行了扩展，WeightedResponseTimeRule中会根据每一个实例的运行情况来给计算出该实例的一个权重，然后在挑选实例的时候则根据权重进行挑选，这样能够实现更优的实例调用。WeightedResponseTimeRule中有一个名叫DynamicServerWeightTask的定时任务，默认情况下每隔30秒会计算一次各个服务实例的权重，权重的计算规则也很简单，如果一个服务的平均响应时间越短则权重越大，那么该服务实例被选中执行任务的概率也就越大。 ClientConfigEnabledRoundRobinRule ClientConfigEnabledRoundRobinRule选择策略的实现很简单，内部定义了RoundRobinRule，choose方法还是采用了RoundRobinRule的choose方法，所以它的选择策略和RoundRobinRule的选择策略一致，不赘述。 BestAvailableRule BestAvailableRule继承自ClientConfigEnabledRoundRobinRule，它在ClientConfigEnabledRoundRobinRule的基础上主要增加了根据loadBalancerStats中保存的服务实例的状态信息来过滤掉失效的服务实例的功能，然后顺便找出并发请求最小的服务实例来使用。然而loadBalancerStats有可能为null，如果loadBalancerStats为null，则BestAvailableRule将采用它的父类即ClientConfigEnabledRoundRobinRule的服务选取策略（线性轮询）。 PredicateBasedRule PredicateBasedRule是ClientConfigEnabledRoundRobinRule的一个子类，它先通过内部定义的一个过滤器过滤出一部分服务实例清单，然后再采用线性轮询的方式从过滤出来的结果中选取一个服务实例。 ZoneAvoidanceRule ZoneAvoidanceRule是PredicateBasedRule的一个实现类，只不过这里多一个过滤条件，ZoneAvoidanceRule中的过滤条件是以ZoneAvoidancePredicate为主过滤条件和以AvailabilityPredicate为次过滤条件组成的一个叫做CompositePredicate的组合过滤条件，过滤成功之后，继续采用线性轮询的方式从过滤结果中选择一个出来。 Spring Cloud管理与监控出处：SpringCloud管理与监控的实践 微服务开发之Spring Boot什么是SpringBoot？出处：SpringBoot概念 Spring boot的技术栈 SpringBoot适应场景出处：SpringBoot应用场景 SpringBoot优势出处：Spring boot浅谈 Spring boot能够使编码变精简、配置变简单、部署变快捷、监控变容易 Spring boot默认快速启动一个web容器，不需要外置web容器，将注意力集中在编码上，而不是配置容器等方面上。 Spring boot是Spring框架扬长避短的杰作，简化了spring冗余的配置，从xml配置到java Config配置，从setBean的方式配置到自动注解，从多个properties+xml到只要一个yml就完成了配置。 Spring boot 默认配置；额很多框架的使用方式，整合了所有框架 Spring boot能够对主流开发的框架，进行无配置集成，提高了开发、部署的效率，不用再花额外的时间，研究不同框架的整合与集成上 Spring boot支持的配置文件application.yml，减少了传统的properties的链式麻烦 Spring boot提供了热部署，实时刷新后台服务，能将服务改动后的效果，呈现出来 Spring boot一键启动，只需要一个jar、war，甚至一段代码就可以了，不需要预部署应用服务器 configprops：属性配置、dump：线程工作状态、env/name：环境变量、metrics/name：JVM性能指标、mapping：RESTful path与服务类的映射关系 SpringBoot的包版本管理pom?? 12345678910111213spring-boot-dependenciesspring-boot-parentspring-boot-toolsspring-bootspring-boot-testspring-boot-autoconfigurespring-boot-test-autoconfigurespring-boot-actuatorspring-boot-devtoolsspring-boot-docsspring-boot-startersspring-boot-actuator-docsspring-boot-cli 出处：SpringBoot Module spring-bootSpringBoot核心工程。 spring-boot-starters是SpringBoot的启动服务工程。 spring-boot-autoconfigure是SpringBoot实现自动配置的核心工程。 spring-boot-actuator提供SpringBoot应用的外围支撑性功能。 比如： Endpoints，SpringBoot应用状态监控管理 HealthIndicator，SpringBoot应用健康指示表 提供metrics支持 提供远程shell支持 spring-boot-tools提供了SpringBoot开发者的常用工具集。诸如，spring-boot-gradle-plugin，spring-boot-maven-plugin就是这个工程里面的。 spring-boot-cli是Spring Boot命令行交互工具，可用于使用Spring进行快速原型搭建。你可以用它直接运行Groovy脚本。如果你不喜欢Maven或Gradle，Spring提供了CLI（Command Line Interface）来开发运行Spring应用程序。你可以使用它来运行Groovy脚本，甚至编写自定义命令。 SpringBoot自动配置出处：SpringBoot自动部署 、SpringBoot官方文档 ​ Spring Boot spring-boot-autoconfigure 依赖做了很多默认的配置项，即应用默认值。这种模式叫做 “自动配置”。Spring Boot 自动配置会根据添加的依赖，自动加载依赖相关的配置属性并启动依赖。例如默认用的内嵌式容器是 Tomcat ，端口默认设置为 8080。 ​ 为什么需要自动配置？顾名思义，自动配置的意义是利用这种模式代替了配置 XML 繁琐模式。以前使用 Spring MVC ，需要进行配置组件扫描、调度器、视图解析器等，使用 Spring Boot 自动配置后，只需要添加 MVC 组件即可自动配置所需要的 Bean。所有自动配置的实现都在 spring-boot-autoconfigure 依赖中，包括 Spring MVC 、Data 和其它框架的自动配置。 ​ Spring Boot的自动配置会尝试根据你添加进来的jar依赖来自动配置你的Spring应用。例如，如果HSQLDB在你的classpath路径上，你没有手动配置任何数据库连接实体类，我们还会自动配置内存数据库。 你可以有选择的实现自动配置，可以向 @Configuration上添加@EnableAutoConfiguration或者@SpringBootApplication注解来实现。 逐步覆盖自动配置 ​ 自动配置是非入侵式的，任何时候你都可以使用你自定义的配置来覆盖自动配置的特定部分。例如，如果你要添加自己的DataSource bean，默认的内嵌数据库会无效。 ​ 如果你需要查找当前应用的自动配置，你可以启动应用时加上–debug开关。它会为核心日志记录器开启debug日志记录，并且会打印自动配置日志信息到控制台。 禁用特定自动配置 12345678@EnableAutoConfiguration的排除属性来禁用它们。import org.springframework.boot.autoconfigure.*;import org.springframework.boot.autoconfigure.jdbc.*;import org.springframework.context.annotation.*;@Configuration@EnableAutoConfiguration(exclude=&#123;DataSourceAutoConfiguration.class&#125;) public class MyConfiguration &#123;&#125; 如果这个类不在classpath路径下，你可以使用该注解的excludeName属性以及指定全限定名 来替代。最终，你也可以控制自动配置类的列表来额除spring.autoconfigure.exclude属性。 你可以通过注解级别以及使用属性来定义排除项。 Starter 组件 Spring Boot 提供了很多 “开箱即用” 的 Starter 组件。Starter 组件是可被加载在应用中的 Maven 依赖项。只需要在 Maven 配置中添加对应的依赖配置，即可使用对应的 Starter 组件。例如，添加 spring-boot-starter-web 依赖，就可用于构建 REST API 服务，其包含了 Spring MVC 和 Tomcat 内嵌容器等。 一个完整的 Starter 组件包括以下两点： 提供自动配置功能的自动配置模块。 提供依赖关系管理功能的组件模块，即封装了组件所有功能，开箱即用 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051spring-boot-starterspring-boot-starter-activemqspring-boot-starter-actuatorspring-boot-starter-amqpspring-boot-starter-aopspring-boot-starter-artemisspring-boot-starter-batchspring-boot-starter-cachespring-boot-starter-cloud-connectorsspring-boot-starter-data-cassandraspring-boot-starter-data-couchbasespring-boot-starter-data-elasticsearchspring-boot-starter-data-jpaspring-boot-starter-data-ldapspring-boot-starter-data-mongodbspring-boot-starter-data-mongodb-reactivespring-boot-starter-data-neo4jspring-boot-starter-data-redisspring-boot-starter-data-restspring-boot-starter-data-solrspring-boot-starter-freemarkerspring-boot-starter-groovy-templatesspring-boot-starter-hateoasspring-boot-starter-integrationspring-boot-starter-jdbcspring-boot-starter-jerseyspring-boot-starter-jettyspring-boot-starter-jooqspring-boot-starter-jta-atomikosspring-boot-starter-jta-bitronixspring-boot-starter-jta-narayanaspring-boot-starter-log4j2spring-boot-starter-loggingspring-boot-starter-mailspring-boot-starter-mobilespring-boot-starter-mustachespring-boot-starter-parentspring-boot-starter-reactor-nettyspring-boot-starter-securityspring-boot-starter-social-facebookspring-boot-starter-social-linkedinspring-boot-starter-social-twitterspring-boot-starter-testspring-boot-starter-thymeleafspring-boot-starter-tomcatspring-boot-starter-undertowspring-boot-starter-validationspring-boot-starter-webspring-boot-starter-web-servicesspring-boot-starter-webfluxspring-boot-starter-websocket 自动部署的一些不足： ​ Spring Boot 工程添加某些 Starter 组件依赖，但不想触发组件自动配置​ Spring Boot 配置多个不同数据源配置时，比如使用 XML 配置多数据源，但其默认数据源配置会触发自动配置出现问题。 SpringBoot热部署机制出处：SpringBoot热部署 原理： ​ spring-boot-devtools 是一个为开发者服务的模块，其中最重要的功能就是自动应用代码更改到最新的App上面去。原理 是在发现代码有更改之后，重新启动应用，但是速度比手动停止后再启动还要更快，更快指的不是节省出来的手动操作的时间。 ​ 其深层原理是使用了两个ClassLoader，一个Classloader加载那些不会改变的类（第三方的jar包），另外一个ClassLoader加载会更改的类，称为restart ClassLoader ​ 这样在有代码更改的时候，，原来的restart ClassLoader被丢弃，重新创建一个restart ClassLoader，由于需要加载的类相比较少，所以实现了更快的重启时间（5秒左右） 123456789101112131415161718192021&lt;!-- 添加spring boot devtools --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;scope&gt;true&lt;/scope&gt;&lt;/dependency&gt;&lt;!-- 添加plugin --&gt;&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;!-- fork:如果没有该配置，这个devtools不会起作用，即应用不会restart --&gt; &lt;fork&gt;true&lt;/fork&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 出处：热部署与热加载的区别 ​ 热部署就是在服务器运行时重新部署项目，——生产环境 ​ 热加载即在在运行时重新加载class，从而升级应用。——开发环境 热加载的实现原理主要依赖java的类加载机制，在实现方式可以概括为在容器启动的时候起一条后台线程，定时的检测类文件的时间戳变化，如果类的时间戳变掉了，则将类重新载入。 对比反射机制，反射是在运行时获取类信息，通过动态的调用来改变程序行为； 热加载则是在运行时通过重新加载改变类信息，直接改变程序行为。 热部署原理类似，但它是直接重新加载整个应用，这种方式会释放内存，比热加载更加干净彻底，但同时也更费时间。 如何自定义配置参数？出处：SpringBoot自定义配置参数 yml 12345678# 测试中使用的作者信息author: # 姓名 name: xxx # 性别 # gender: man # 年龄 age: 22 外部化配置出处：SpringBoot自定义配置参数 实体类 1234567891011121314151617181920212223/** * 配置文件对应的实体 */@Componentpublic class AuthorValue &#123; /** * 用户名 */ /* * 通过 value 注解获取 properties 文件中的内容 * $&#123;属性的全称&#125; */ @Value(\"$&#123;author.name&#125;\") private String name; /* * 若配置文件中没有配置相应的属性, 而在类中又通过 @Value的形式获取, 系统启动时会报错 * 所以, 我们可以通过设定默认值的形式避免这样的问题 */ @Value(\"$&#123;author.age:10&#125;\") private Integer age; // getter and setter&#125; 测试类 1234567891011121314151617/** * 通过 value 的方式获取配置文件内容的测试方法 */@RunWith(SpringRunner.class)@SpringBootTestpublic class AuthorValueTest &#123; @Autowired private AuthorValue authorValue; @Test public void getUserMessage()&#123; Integer age = 10; Assert.assertEquals(authorValue.getName(), \"xxx\"); Assert.assertEquals(authorValue.getAge(), age); &#125;&#125; @ConfigurationProperties 直接封装对象 12345678910111213141516/** * 配置文件对应的实体 */@Component@ConfigurationProperties(prefix = \"author\")public class AuthorObject &#123; /** * 用户名 */ private String name; /** * 年龄 */ private Integer age; // getter and setter&#125; 多环境配置出处：SpringBoot多环境配置 一个yml文件 123456789101112131415161718192021spring: profiles: active: dev---#开发环境配置spring: profiles: devserver: port: 1000---#测试环境配置spring: profiles: stgserver: port: 1001---#生产环境配置spring: profiles: prdserver: port: 1002 多个yml文件（比较实用） application.yml 123spring: profiles: active: dev application-dev.yml 12server: port: 1000 application-test.yml 12server: port: 1001 application-prd.yml 12server: port: 1002 Spring Boot常用注解出处：SprintBoot常用注解 Spring Boot发布之jar与war出处：SpringBoot发布中jar与war的区别 jar包：直接通过内置tomcat运行，不需要额外安装tomcat。如需修改内置tomcat的配置，只需要在spring boot的配置文件中配置。内置tomcat没有自己的日志输出，全靠jar包应用输出日志。但是比较方便，快速，比较简单。 war包：传统的应用交付方式，需要安装tomcat，然后放到waeapps目录下运行war包，可以灵活选择tomcat版本，可以直接修改tomcat的配置，有自己的tomcat日志输出，可以灵活配置安全策略。相对打成jar包来说没那么快速方便 生产级特性出处：SpringBoot生产级特性 12345 &lt;!-- 监控 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;&lt;/dependency&gt; endpoint我们可以通过一系列的HTTP请求获得应用程序的相关信息，这些请求就是endpoint，具体有如下几个 12345678910autoconfig : 获取自动配置信息beans ：获取Spring Bean基本信息configprops ：获取配置项信息dump ： 获取当前线程基本信息env ：获取环境变量信息health ： 获取健康检查信息info ： 获取应用的基本信息metrics ： 获取性能指标信息mappings ： 获取请求映射信息trace ： 获取请求调用信息 可以通过application.properties配置文件进行精准控制 1234567891011# 放弃安全限制management.security.enabled=false# 关闭一个endpoint：beansendpoints.beans.enabled=false# 关闭所有endpoint，仅打开beansendpoints.enable=falseendpoints.beans.enabled=false# 修改endpoint名称endpoints.beans.id=mybeans# 修改请求路径endpoints.beans.path=/endpoints/mybeans 信息聚合12345678910&lt;!-- actuator聚合插件 /actuator --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-hateoas&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- actuator聚合图形化插件 /actuator --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.data&lt;/groupId&gt; &lt;artifactId&gt;spring-data-rest-hal-browser&lt;/artifactId&gt;&lt;/dependency&gt; 应用信息通过/info可以查看应用信息，信息可以在application.properties文件中配置 1234567info.app.name=应用名称，使用POM中的信息，@project.modelVersion@info.app.description=对应用的描述info.app.version=1.0.0# 自定义用户信息info.user.name=hutouinfo.user.sex=男info.user.age=22 健康检查1234# 暴露磁盘空间信息endpoints.health.sensitive=true# 健康信息缓存时间，设置太短会影响性能endpoints.health.time-to-live=500 spring boot提供了很多内置的监控检查功能，都放置在：org.springframework.boot.actuate.health包下 123456ApplicationHealthIndicatorDiskSpaceHealthIndicatorDataSourceHealthIndicator 检查数据库连接MailHealthIndicator 检查邮件服务器MongoHealthIndicator 检查MongoDB数据库.... 跨域访问123## 跨域访问endpoints.cors.allowed-origins=http://www.baidu.comendpoints.cors.allowed-methods=GET,PUT,POST,DELETE 在应用中增加@CrossOrigin注解来实现跨域 123456789101112/** 自定义配置*/@Configuration@EnableWebMvcpublic class WebConfig extends WebMvcConfigurerAdapter&#123; @Override public void addCorsMappings(CorsRegistry registry) &#123; registry.addMapping(\"/**\") .allowedOrigins(\"http://www.baidu.com\") .allowedMethods(\"GET\",\"PUT\",\"POST\",\"DELETE\"); &#125;&#125; 监控出处：SpringBoot监控 spring-boot-actuator模块提供了一个监控和管理生产环境的模块，可以使用http、jmx、ssh、telnet等拉管理和监控应用。审计（Auditing）、健康（health）、数据采集（metrics gathering）会自动加入到应用里面。 12345&lt;!-- 添加依赖 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;&lt;/dependency&gt; 【实战】使用SpringBoot快速构建RESTful API应用微服务之注册中心服务调用端与服务提供端之间透明通信如何实现服务的动态注册与发现注册中心引入注册中心之zookeeper注册中心底层实现剖析SpringCloud之注册中心EurkaEurka介绍与原理分析【实战】实现将微服务注册到EurkaServer上微服务之负载均衡负载均衡应用场景常用的负载均衡实现方案客户端负载均衡服务端负载均衡【实战】使用Ribbin实现客户端负载均衡微服务之容错处理雪崩效应场景分析如何应对雪崩效应下的容错处理Spring Cloud体系下之容错处理解决方案断路器Hystrix应用如何接入Hystrix如何监控Hystrix状态【实战】实现Hystrix Dashboard可视化监控数据微服务之网关微服务网关定义微服务网关引入能解决什么问题SpringCloud之微服务网关zuul如何编写zuul微服务网关zuul过滤器的应用zuul的容错与回退处理【实战】使用zuul聚合微服务微服务之配置中心服务配置中心介绍与应用场景分析微服务配置之Ansible如何管理微服务中的配置Spring Cloud下之微服务配置解决方案Spring Cloud ConfigConfig Server与Config Client的实现Config Server仓库配置与应用流程如何实现配置端点的刷新如何确保配置中心内容的安全性？如何实现配置刷新后自动下发？【实战】使用Spring Cloud Config打造微服务配置中心微服务之封装容器化技术Docker简介Docker架构剖析虚拟机与Docker的对比Docker的优点Docker安装系统要求Docker的安装与卸载Docker镜像常用命令Docker容器常用命令如何配置Docker镜像地址Docker镜像下载与构建使用Docker Registry打造私有镜像仓库微服务部署持续集成Jenkins简介使用Jenkins实现自动化发布搭建版本控制系统搭建Jenkins持续集成系统持续集成实现自动化构建微服务日志为什么需要搭建应用日志中心开源日志中心ELK介绍日志存储系统之Elasticsearch日志收集系统之Logstash日志查询系统之KibanaELK日志中心搭建微服务监控Spring Boot自带的开源监控系统Spring Boot Admin自主搭建系统监控中心分布式调用链中心开源调用链中心Zipkin微服务调用链追踪Spring Cloud Sleuth简介Spring Cloud Sleuth与Zipkin结合应用微服务之异步化使用MQ实现异步调用分布式事务解决方案剖析Spring Cloud Bus的应用【实战】使用Spring Cloud Bus实现配置的自动刷新微服务测试Spring Boot单元测试Service层测试REST API测试【综合案例】 某大型的跨境电商项目【综合案例】 某服务治理平台参考 单体架构简介：http://book.51cto.com/art/201803/567370.htm 单体架构到微服务的演进：https://my.oschina.net/zhanghaiyang/blog/725728 从单体架构迁移微服务：http://www.infoq.com/cn/news/2016/08/Monomer-architecture-Micro-servi 单体与微服务架构：https://blog.csdn.net/hu_zhiting/article/details/77036914 微服务的4大设计原则和19个解决方案：https://juejin.im/entry/59bf30876fb9a00a583176a1 微服务对比：https://segmentfault.com/a/1190000010953144","categories":[{"name":"微服务","slug":"微服务","permalink":"https://pinksmallfan.github.io/WenChongAndJiaoKou/categories/微服务/"}],"tags":[{"name":"计划","slug":"计划","permalink":"https://pinksmallfan.github.io/WenChongAndJiaoKou/tags/计划/"}]},{"title":"about","slug":"about/about","date":"2018-11-15T14:33:34.855Z","updated":"2018-11-15T14:33:57.984Z","comments":true,"path":"2018/11/15/about/about/","link":"","permalink":"https://pinksmallfan.github.io/WenChongAndJiaoKou/2018/11/15/about/about/","excerpt":"","text":"blog","categories":[],"tags":[]},{"title":"不成文规定","slug":"每天一篇(大纲)","date":"2018-11-14T15:52:45.173Z","updated":"2018-11-15T16:07:44.173Z","comments":true,"path":"2018/11/14/每天一篇(大纲)/","link":"","permalink":"https://pinksmallfan.github.io/WenChongAndJiaoKou/2018/11/14/每天一篇(大纲)/","excerpt":"","text":"不成文规定：离职or求职期间才可以公布到blog上，暂时存放到自己的本地目录下。不公开！ PKI 内容分解 ASN.1 语法 证书编码、格式 数字证书的概念 数字证书的信息：基本项、扩展项 数字签名 证书验证 证书申请与签发的流程 PKI应用（这个需要模糊化，不能涉及公司） 证书与CA的关系 CRL OCSP 时间戳 RSA 加密、公开密钥 （可以看教科书+阮一峰） 密钥的生命周期 （http://www.docin.com/p-743210632.html） SHA1、MD5、SHA256等算法原理 -&gt;这部分可以等刷LintCode到某种层次的时候开始自己造个轮子玩一玩（估计需要2年时间，才有这个能力 P1的结构 P7的结构，SignedData,2018年10月30日 java基础分解 HashMap的源码（bolg） ArrayList对比LinkList（bolg） 锁 equals wait() 与sleep()和notify() 的区别 抽象类和接口的区别 生产者消费者 单向链表 InputStream 和reader流的区别 单例模式 设计模式 java进阶分解 GC机制 内存模型 高并发 连接池 JVM 线程同步 Java的IO java调用jdbc连接数据库 preStatement和Statement的区别 Spring如何实现事务 HTTP2.0与1.0的区别 java技术经验分解 JAVA_GC日志分析，2018年10月30日 跳过导航链接一个不错的测试并发Java代码 JAVA命令行工具的使用 lombok介绍 BTrace介绍 ActiveMQ_基础学习 Maven私服-nexus简介 配置Linux的DNS Wireshark使用分享 RMI结合Spring使用 chrome浏览器插件postman测试接口 Java下HttpClient访问https的两种方式 Spring事务管理介绍 Spring事务管理基本使用 常见开源协议大白话说明 mysql Innodb 表空间初步认识 docker基本知识以及应用 六种方式实现hibernate查询 java 客户端-服务端 证书信任 使用Toad比对数据库 OpenSSL部分使用方法 微服务培训课程实战 【案例】结合某案例分析传统单体架构面临问题 【案例】基于Dubbo的项目应用案例分析 【实战】使用SpringBoot快速构建RESTful API应用 【实战】实现将微服务注册到EurkaServer上 【实战】使用Ribbin实现客户端负载均衡 【实战】实现Hystrix Dashboard可视化监控数据 【实战】使用zuul聚合微服务 【实战】使用Spring Cloud Config打造微服务配置中心 【实战】使用Spring Cloud Bus实现配置的自动刷新 【综合案例】 某大型的跨境电商项目 【综合案例】 某服务治理平台 分解 Dubbo与Spring Cloud","categories":[],"tags":[{"name":"Other","slug":"Other","permalink":"https://pinksmallfan.github.io/WenChongAndJiaoKou/tags/Other/"}]},{"title":"实验吧（Decode）","slug":"2018-11-11-实验吧（Decode）","date":"2018-11-11T15:04:00.000Z","updated":"2018-11-15T16:12:05.776Z","comments":true,"path":"2018/11/11/2018-11-11-实验吧（Decode）/","link":"","permalink":"https://pinksmallfan.github.io/WenChongAndJiaoKou/2018/11/11/2018-11-11-实验吧（Decode）/","excerpt":"","text":"题目Decode 0x253464253534253435253335253433253661253435253737253464253531253666253738253464253434253637253462253466253534253662253462253464253534253435253738253433253661253435253737253466253531253666253738253464253434253435253462253464253534253435253332253433253661253435253738253464253531253666253738253464253534253535253462253464253534253431253330253433253661253435253737253465253531253666253738253464253661253435253462253466253534253633253462253464253534253435253737253433253661253662253334253433253661253662253333253433253661253435253738253465253431253364253364 解题思路首先，查看这段编码，有什么异常，我们可以发现253x出现得比较频繁，16进制25转为十进制为37，在ASCII即%，那么可以想到的是URL 十六进制转ASCII编码123456789hex16=253464253534253435253335253433253661253435253737253464253531253666253738253464253434253637253462253466253534253662253462253464253534253435253738253433253661253435253737253466253531253666253738253464253434253435253462253464253534253435253332253433253661253435253738253464253531253666253738253464253534253535253462253464253534253431253330253433253661253435253737253465253531253666253738253464253661253435253462253466253534253633253462253464253534253435253737253433253661253662253334253433253661253662253333253433253661253435253738253465253431253364253364d = [chr(int(b, 16)) for b in [hex16[i:i+2] for i in range(0, len(hex16), 2)]]# ['%', '4', 'd', '%', '5', '4', '%', '4', '5', '%', '3', '5', '%', '4', '3', '%', '6', 'a', '%', '4', '5', '%', '7', '7', '%', '4', 'd', '%', '5', '1', '%', '6', 'f', '%', '7', '8', '%', '4', 'd', '%', '4', '4', '%', '6', '7', '%', '4', 'b', '%', '4', 'f', '%', '5', '4', '%', '6', 'b', '%', '4', 'b', '%', '4', 'd', '%', '5', '4', '%', '4', '5', '%', '7', '8', '%', '4', '3', '%', '6', 'a', '%', '4', '5', '%', '7', '7', '%', '4', 'f', '%', '5', '1', '%', '6', 'f', '%', '7', '8', '%', '4', 'd', '%', '4', '4', '%', '4', '5', '%', '4', 'b', '%', '4', 'd', '%', '5', '4', '%', '4', '5', '%', '3', '2', '%', '4', '3', '%', '6', 'a', '%', '4', '5', '%', '7', '8', '%', '4', 'd', '%', '5', '1', '%', '6', 'f', '%', '7', '8', '%', '4', 'd', '%', '5', '4', '%', '5', '5', '%', '4', 'b', '%', '4', 'd', '%', '5', '4', '%', '4', '1', '%', '3', '0', '%', '4', '3', '%', '6', 'a', '%', '4', '5', '%', '7', '7', '%', '4', 'e', '%', '5', '1', '%', '6', 'f', '%', '7', '8', '%', '4', 'd', '%', '6', 'a', '%', '4', '5', '%', '4', 'b', '%', '4', 'f', '%', '5', '4', '%', '6', '3', '%', '4', 'b', '%', '4', 'd', '%', '5', '4', '%', '4', '5', '%', '7', '7', '%', '4', '3', '%', '6', 'a', '%', '6', 'b', '%', '3', '4', '%', '4', '3', '%', '6', 'a', '%', '6', 'b', '%', '3', '3', '%', '4', '3', '%', '6', 'a', '%', '4', '5', '%', '7', '8', '%', '4', 'e', '%', '4', '1', '%', '3', 'd', '%', '3', 'd']\"a=''for j in range(len(d)): a+=d[j]a# %4d%54%45%35%43%6a%45%77%4d%51%6f%78%4d%44%67%4b%4f%54%6b%4b%4d%54%45%78%43%6a%45%77%4f%51%6f%78%4d%44%45%4b%4d%54%45%32%43%6a%45%78%4d%51%6f%78%4d%54%55%4b%4d%54%41%30%43%6a%45%77%4e%51%6f%78%4d%6a%45%4b%4f%54%63%4b%4d%54%45%77%43%6a%6b%34%43%6a%6b%33%43%6a%45%78%4e%41%3d%3d ASCII编码转URL编码12345from urllib.parse import unquotea='%4d%54%45%35%43%6a%45%77%4d%51%6f%78%4d%44%67%4b%4f%54%6b%4b%4d%54%45%78%43%6a%45%77%4f%51%6f%78%4d%44%45%4b%4d%54%45%32%43%6a%45%78%4d%51%6f%78%4d%54%55%4b%4d%54%41%30%43%6a%45%77%4e%51%6f%78%4d%6a%45%4b%4f%54%63%4b%4d%54%45%77%43%6a%6b%34%43%6a%6b%33%43%6a%45%78%4e%41%3d%3d'test=unquote(a,'utf-8')test# 'MTE5CjEwMQoxMDgKOTkKMTExCjEwOQoxMDEKMTE2CjExMQoxMTUKMTA0CjEwNQoxMjEKOTcKMTEwCjk4Cjk3CjExNA==' Base64值解码12345 import base64test = 'MTE5CjEwMQoxMDgKOTkKMTExCjEwOQoxMDEKMTE2CjExMQoxMTUKMTA0CjEwNQoxMjEKOTcKMTEwCjk4Cjk3CjExNA=='data = base64.b64decode(test)datab'119\\n101\\n108\\n99\\n111\\n109\\n101\\n116\\n111\\n115\\n104\\n105\\n121\\n97\\n110\\n98\\n97\\n114' ASCII编码对比ASCII表，可得 welcometoshiyanbar b = 123bin(int(b))‘0b1111011’oct(int(b))‘0o173’hex(int(b))‘0x7b’int(b)","categories":[{"name":"实验吧","slug":"实验吧","permalink":"https://pinksmallfan.github.io/WenChongAndJiaoKou/categories/实验吧/"}],"tags":[{"name":"密码学","slug":"密码学","permalink":"https://pinksmallfan.github.io/WenChongAndJiaoKou/tags/密码学/"},{"name":"other","slug":"other","permalink":"https://pinksmallfan.github.io/WenChongAndJiaoKou/tags/other/"}]},{"title":"实验吧（我喜欢的培根）","slug":"2018-11-11-实验吧（我喜欢的培根）","date":"2018-11-11T14:34:08.000Z","updated":"2018-11-15T16:12:16.411Z","comments":true,"path":"2018/11/11/2018-11-11-实验吧（我喜欢的培根）/","link":"","permalink":"https://pinksmallfan.github.io/WenChongAndJiaoKou/2018/11/11/2018-11-11-实验吧（我喜欢的培根）/","excerpt":"","text":"题目我喜欢的培根，key: CTF{} 1-- --- .-. ... . ..--.- .. ... ..--.- -.-. --- --- .-.. ..--.- -... ..- - ..--.- -... .- -.-. --- -. ..--.- .. ... ..--.- -.-. --- --- .-.. . .-. ..--.- -.. -.-. -.-. -.. -.-. -.-. -.-. -.. -.. -.. -.-. -.. -.-. -.-. -.-. -.. -.. -.-. -.-. -.-. -.-. -.-. -.-. -.-. -.-. -.-. -.. -.. -.-. -.. -.-. -.-. -.-. -.-. -.. -.-. -.-. -.-. -.-. -.-. / -.-. -.. -.-. -.-. -.-. -.. -.-. -.-. -.. -.-. / -.-. -.-. -.-. -.. -.-. -.-. -.. -.. -.. -.-. -.-. -.. -.. -.. -.-. -.-. -.. -.-. -.. -.. 解题思路莫斯密码自己编写一个morse解码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#!/usr/bin/env python# -*- coding: utf-8 -*-'''&#123;Title:MorseCodeAuthor:PinkSmallFanType:cryptoDetail:莫斯密码&#125;'''def morse(lstr): flag = '' data = lstr.split(' ') dict = &#123;'.-': 'A', '-...': 'B', '-.-.': 'C', '-..':'D', '.':'E', '..-.':'F', '--.': 'G', '....': 'H', '..': 'I', '.---':'J', '-.-': 'K', '.-..': 'L', '--': 'M', '-.': 'N', '---': 'O', '.--.': 'P', '--.-': 'Q', '.-.': 'R', '...': 'S', '-': 'T', '..-': 'U', '...-': 'V', '.--': 'W', '-..-': 'X', '-.--': 'Y', '--..': 'Z', '.----': '1', '..---': '2', '...--': '3', '....-': '4', '.....': '5', '-....': '6', '--...': '7', '---..': '8', '----.': '9', '-----': '0', '..--..': '?', '-..-.': '/', '-.--.-': '()', '-....-': '-', '.-.-.-': '.' &#125;; for item in data: flag+=dict[item] return flagdef main(lstr): print(lstr) result = morse(lstr) print(result) return result# example# print('helloworld')# abc='-- --- .-. ... . ..--.- .. ... ..--.- -.-. --- --- .-.. ..--.- -... ..- - ..--.- -... .- -.-. --- -. ..--.- .. ... ..--.- -.-. --- --- .-.. . .-. ..--.- -.. -.-. -.-. -.. -.-. -.-. -.-. -.. -.. -.. -.-. -.. -.-. -.-. -.-. -.. -.. -.-. -.-. -.-. -.-. -.-. -.-. -.-. -.-. -.-. -.. -.. -.-. -.. -.-. -.-. -.-. -.-. -.. -.-. -.-. -.-. -.-. -.-. / -.-. -.. -.-. -.-. -.-. -.. -.-. -.-. -.. -.-. / -.-. -.-. -.-. -.. -.-. -.-. -.. -.. -.. -.-. -.-. -.. -.. -.. -.-. -.-. -.. -.-. -.. -..'# main(abc)# result为MORSE..--.-IS..--.-COOL..--.-BUT..--.-BACON..--.-IS..--.-COOLER..--.-DCCDCCCDDDCDCCCDDCCCCCCCCCDDCDCCCCDCCCCC/CDCCCDCCDC/CCCDCCDDDCCDDDCCDCDD 培根密码 A/a aaaaa H/h aabbb O/o abbba V/v babab B/b aaaab I/i abaaa P/p abbbb W/w babba C/c aaaba J/j abaab Q/q baaaa X/x babbb D/d aaabb K/k ababa R/r baaab Y/y bbaaa E/e aabaa L/l ababb S/s baaba Z/z bbaab F/f aabab M/m abbaa T/t baabb G/g aabba N/n abbab U/u babaa 将DCCDCCCDDDCDCCCDDCCCCCCCCCDDCDCCCCDCCCCC/CDCCCDCCDC/CCCDCCDDDCCDDDCCDCDD去掉反斜杠，五个为一组，D-&gt;a，C-&gt;b，进行培根密码解密 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#!/usr/bin/env python# -*- coding: utf-8 -*-'''&#123;Title:PeigenCodeAuthor:PinkSmallFanType:cryptoDetail:培根密码&#125;'''def peigenDe(lstr): dict = &#123;'aaaaa': 'A', 'aaaab': 'B', 'aaaba': 'C', 'aaabb': 'D', 'aabaa': 'E', 'aabab': 'F', 'aabba': 'G', 'aabbb': 'H', 'abaaa': 'I', 'abaab': 'J', 'ababa': 'K', 'ababb': 'L', 'abbaa': 'M', 'abbab': 'N', 'abbba': 'O', 'abbbb': 'P', 'baaaa': 'Q', 'baaab': 'R', 'baaba': 'S', 'baabb': 'T', 'babaa': 'U', 'babab': 'V', 'babba': 'W', 'babbb': 'X', 'bbaaa': 'Y', 'bbaab': 'Z' &#125;; size = len(lstr) lenght = 5 returnStr = '' for i in range(round(size/lenght)): result=lstr[lenght*i:lenght*(i+1)].lower() returnStr += dict[result] return returnStrdef main(lstr): print(lstr) result = peigenDe(lstr) print(result) return result# example# data = 'baabaaabbbabaaabbaaaaaaaaabbabaaaabaaaaaabaaabaabaaaabaabbbaabbbaababb'# main(data)# SHIYANBAISCOOL PS：注意，之前含有的反斜杠，为空格，需要额外添加空格 最后大小写试一试就ok啦~","categories":[{"name":"实验吧","slug":"实验吧","permalink":"https://pinksmallfan.github.io/WenChongAndJiaoKou/categories/实验吧/"}],"tags":[{"name":"密码学","slug":"密码学","permalink":"https://pinksmallfan.github.io/WenChongAndJiaoKou/tags/密码学/"},{"name":"other","slug":"other","permalink":"https://pinksmallfan.github.io/WenChongAndJiaoKou/tags/other/"}]},{"title":"实验吧（困在栅栏里的爱）","slug":"2018-11-11-实验吧（困在栅栏里的爱）","date":"2018-11-11T08:56:50.000Z","updated":"2018-11-15T16:12:10.682Z","comments":true,"path":"2018/11/11/2018-11-11-实验吧（困在栅栏里的爱）/","link":"","permalink":"https://pinksmallfan.github.io/WenChongAndJiaoKou/2018/11/11/2018-11-11-实验吧（困在栅栏里的爱）/","excerpt":"","text":"困在栅栏里的爱题目最近一直在好奇一个问题，QWE到底等不等于ABC？ -.- .. –.- .-.. .– - ..-. -.-. –.- –. -. … — — flag格式：CTF{xxx} 题目地址：http://www.shiyanbar.com/ctf/1917 解题思路莫斯密码自己编写一个morse解码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#!/usr/bin/env python# -*- coding: utf-8 -*-'''&#123;Title:MorseCodeAuthor:PinkSmallFanType:cryptoDetail:莫斯密码&#125;'''def morse(lstr): flag = '' data = lstr.split(' ') dict = &#123;'.-': 'A', '-...': 'B', '-.-.': 'C', '-..':'D', '.':'E', '..-.':'F', '--.': 'G', '....': 'H', '..': 'I', '.---':'J', '-.-': 'K', '.-..': 'L', '--': 'M', '-.': 'N', '---': 'O', '.--.': 'P', '--.-': 'Q', '.-.': 'R', '...': 'S', '-': 'T', '..-': 'U', '...-': 'V', '.--': 'W', '-..-': 'X', '-.--': 'Y', '--..': 'Z', '.----': '1', '..---': '2', '...--': '3', '....-': '4', '.....': '5', '-....': '6', '--...': '7', '---..': '8', '----.': '9', '-----': '0', '..--..': '?', '-..-.': '/', '-.--.-': '()', '-....-': '-', '.-.-.-': '.' &#125;; for item in data: flag+=dict[item] return flagdef main(lstr): print(lstr) result = morse(lstr) print(result) return result# example# print('helloworld')# abc='-.- .. --.- .-.. .-- - ..-. -.-. --.- --. -. ... --- ---'# main(abc)# result为KIQLWTFCQGNSOO 替换密码qwe替换abc，即键盘的qwert…键盘从上到下，从左到右转换 12345678910111213141516171819202122232425262728#!/usr/bin/env python# -*- coding: utf-8 -*-'''&#123;Title:QWECodeAuthor:PinkSmallFanType:cryptoDetail:替换密码&#125;'''def qweDecode(lstr): qweData = 'QWERTYUIOPASDFGHJKLZXCVBNM' abcData = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' returnStr = '' for data in lstr: returnStr += abcData[qweData.index(data.upper())] return returnStrdef main(lstr): print(lstr) result = qweDecode(lstr) print(result) return result# example# data='KIQLWTFCQGNSOO'# main(data)# RHASBENVAOYLII 栏删密码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#!/usr/bin/env python# -*- coding: utf-8 -*-'''&#123;Title:FenceCodeAuthor:PinkSmallFanType:cryptoDetail:栏删密码&#125;'''def fenceDecode(lstr): decodeStr = '' returnStr = '' fenceSize = 1 encodeSize = len(lstr) for r in range(round(encodeSize/2)): fenceSize = r+1 decodeStr = '' for f in range(fenceSize): for e in range(encodeSize): if((f + e) % fenceSize == 0): decodeStr += lstr[e] returnStr += str(fenceSize) + ':' + decodeStr + '\\n' return returnStrdef main(lstr): print(lstr) result = fenceDecode(lstr) print(result) return resultdef myround(num): return int(num)+int(2*num)%2# example# data='RHASBENVAOYLII'# main(data)# RHASBENVAOYLII# 1:RHASBENVAOYLII# 2:RABNAYIHSEVOLI# 3:RSNOIAEALHBVYI# 4:RBAISVLANYHEOI# 5:REYBOSAIAVIHNL# 6:RNIELBYSOAAHVI# 7:RVNIEIBLSYAOHA# test# print(myround(6.9/2))# print(format(5/2, '.1f'))# print(round(2.5)) 倒序可以找到栏删密码中，第二个合适，即ILOVESHIYANBAR，接着大小写都试一下，就完成啦~","categories":[{"name":"实验吧","slug":"实验吧","permalink":"https://pinksmallfan.github.io/WenChongAndJiaoKou/categories/实验吧/"}],"tags":[{"name":"密码学","slug":"密码学","permalink":"https://pinksmallfan.github.io/WenChongAndJiaoKou/tags/密码学/"},{"name":"other","slug":"other","permalink":"https://pinksmallfan.github.io/WenChongAndJiaoKou/tags/other/"}]},{"title":"RSA","slug":"2018-11-9-RSA","date":"2018-11-09T15:42:42.000Z","updated":"2018-11-15T16:12:43.059Z","comments":true,"path":"2018/11/09/2018-11-9-RSA/","link":"","permalink":"https://pinksmallfan.github.io/WenChongAndJiaoKou/2018/11/09/2018-11-9-RSA/","excerpt":"","text":"Pythongmpy2引用 import gmpy2divm(…)divm(a, b, m) returns x such that b x == a modulo m. Raises a ZeroDivisionError exception if no such value x exists.invert(…)invert(x, m) returns y such that x y == 1 modulo m, or 0 if no such y exists. mpz(…) mpz() returns a new mpz object set to 0. mpz(n) returns a new mpz object from a numeric value n. If n is not an integer, it will be truncated to an integer. mpz(s[, base=0]) returns a new mpz object from a string s made of digits in the given base. If base = 0, thn binary, octal, or hex Python strings are recognized by leading 0b, 0o, or 0x characters. Otherwise the string is assumed to be decimal. Values for base can range between 2 and 62. 常用例子123456789# 已知p、q、e，求dimport gmpy2p =gmpy2.mpz(17)q =gmpy2.mpz(5)e =gmpy2.mpz(7)phi_n= (p - 1) * (q - 1)d = gmpy2.invert(e, phi_n)print(\"d is:\")print (d) pow引用 pow(…)pow(x, y, m) returns n such that x ^ y == 1 modulo m. Raises a ZeroDivisionError exception if no such value n exists. 常用例子1234567891011import gmpy2p =gmpy2.mpz(9648423029010515676590551740010426534945737639235739800643989352039852507298491399561035009163427050370107570733633350911691280297777160200625281665378483)q =gmpy2.mpz(11874843837980297032092405848653656852760910154543380907650040190704283358909208578251063047732443992230647903887510065547947313543299303261986053486569407)e =gmpy2.mpz(65537)phi_n= (p - 1) * (q - 1)n=p*qd = gmpy2.invert(e, phi_n)c=gmpy2.mpz(83208298995174604174773590298203639360540024871256126892889661345742403314929861939100492666605647316646576486526217457006376842280869728581726746401583705899941768214138742259689334840735633553053887641847651173776251820293087212885670180367406807406765923638973161375817392737747832762751690104423869019034)m=pow(c,d,n)print(\"Message is :\")print(m) 引用地址","categories":[],"tags":[{"name":"密码学","slug":"密码学","permalink":"https://pinksmallfan.github.io/WenChongAndJiaoKou/tags/密码学/"}]},{"title":"微服务实践笔记","slug":"2018-11-8-微服务实践笔记","date":"2018-11-08T15:51:02.000Z","updated":"2018-12-13T16:35:48.822Z","comments":true,"path":"2018/11/08/2018-11-8-微服务实践笔记/","link":"","permalink":"https://pinksmallfan.github.io/WenChongAndJiaoKou/2018/11/08/2018-11-8-微服务实践笔记/","excerpt":"","text":"【宿舍】使用SpringBoot快速构建RESTful API应用 【公司】业务平台Spring改为SpringBoot项目 【公司】SpringBoot的单元测试 【宿舍】SpringBoot的热部署等配置 【宿舍】SpringCloud的初体验 【公司】建立activeMQ，并与redis做结合 【公司】将SpringBoot项目拆分为微服务 【宿舍】实现将微服务注册到EurkaServer上 【宿舍】SpringBoot容错处理搭建Hystrix 【宿舍】使用Ribbin实现客户端负载均衡 【宿舍】实现Hystrix Dashboard可视化监控数据 【公司】Elasticsearch日志存储系统搭建 【公司】Logstash日志收集系统搭建 【公司】Kiaabna日志查询系统搭建 【宿舍】ELK日志中心搭建 【宿舍】自主搭建系统监控中心 【宿舍】Dubbo的初体验 【宿舍】jenkins的持续集成搭建 【宿舍】Docker镜像下载与构建 【宿舍】使用Docker Registry打造私有镜像仓库 【宿舍】使用Spring Cloud Bus实现配置的自动刷新 SpringBoot快速构建RESTful API应用搭建SpringBoot项目pom依赖1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;net.spring&lt;/groupId&gt; &lt;artifactId&gt;example&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;example&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.0.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.restdocs&lt;/groupId&gt; &lt;artifactId&gt;spring-restdocs-mockmvc&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; bo实体类123456789101112131415161718public class User &#123; private long id; private String content; public User(long id, String content)&#123; this.id=id; this.content=content; &#125; public long getId()&#123; return id; &#125; public String getContent()&#123; return content; &#125;&#125; Control层(REST, GET/POST/PUT/DELETE)1234567891011121314151617181920212223242526272829303132333435363738394041424344@RestControllerpublic class UserController &#123; private static final String template = \"Hello, %s\"; private final AtomicLong counter = new AtomicLong(); @RequestMapping(\"/greeting\") public User greeting(@RequestParam(value = \"name\", defaultValue = \"world\")String name)&#123; return new User(counter.incrementAndGet(), String.format(template, name)); &#125; @GetMapping(\"/users\") public ResponseEntity&lt;List&lt;User&gt;&gt; getUser()&#123; List&lt;User&gt; users = new ArrayList&lt;&gt;(); users.add(new User(1, \"Bob\")); //counter.incrementAndGet() users.add(new User(2, \"Tom\")); return new ResponseEntity&lt;&gt;(users, HttpStatus.OK); &#125; @PostMapping(\"/register\") public ResponseEntity&lt;String&gt; register(@Valid User user, BindingResult bindingResult) &#123; if(bindingResult.hasErrors())&#123; return new ResponseEntity&lt;&gt;(bindingResult.getFieldError().getDefaultMessage(), HttpStatus.BAD_REQUEST); &#125; return new ResponseEntity&lt;&gt;(\"success\", HttpStatus.OK); &#125; @PutMapping(\"/update\") public ResponseEntity&lt;User&gt; updateUser(User user)&#123; User uUser = user; return new ResponseEntity&lt;&gt;(uUser, HttpStatus.OK); &#125; @DeleteMapping(\"/delete\") public ResponseEntity deleteUser(long id) &#123; return new ResponseEntity(HttpStatus.OK); &#125;&#125; 测试例程12345678910111213141516171819202122232425262728293031323334353637public class testUser &#123; private final MockMvc mockMvc = MockMvcBuilders.standaloneSetup(new UserController()).build(); @Test public void testGetUsers() throws Exception&#123; mockMvc.perform(MockMvcRequestBuilders.get(\"/users\")) .andExpect(MockMvcResultMatchers.status().isOk()) .andExpect(MockMvcResultMatchers.content().json(\"[&#123;\\\"id\\\":1,\\\"content\\\":\\\"Bob\\\"&#125;,&#123;\\\"id\\\":2,\\\"content\\\":\\\"Tom\\\"&#125;]\")); &#125; @Test public void testRegister() throws Exception &#123; mockMvc.perform(MockMvcRequestBuilders.post(\"/register\") .param(\"id\", \"1\") .param(\"content\", \"gaga\")) .andExpect(MockMvcResultMatchers.status().isOk()) .andExpect(MockMvcResultMatchers.content().string(\"success\")); &#125; @Test public void testUpdateUser() throws Exception &#123; mockMvc.perform(MockMvcRequestBuilders.put(\"/update\") .param(\"id\", \"1\") .param(\"content\", \"tt\")) .andExpect(MockMvcResultMatchers.status().isOk()) .andExpect(MockMvcResultMatchers.content().string(\"&#123;\\\"id\\\":1,\\\"content\\\":\\\"tt\\\"&#125;\")); &#125; @Test public void testDelete() throws Exception &#123; mockMvc.perform(MockMvcRequestBuilders.delete(\"/delete\") .param(\"id\",\"1\")) .andExpect(MockMvcResultMatchers.status().isOk()) .andExpect(MockMvcResultMatchers.content().string(\"\")); &#125;&#125; SpringBoot的热部署等配置pom依赖123456&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;scope&gt;true&lt;/scope&gt;&lt;/dependency&gt; 在bulid节点修改为 123456789101112&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;!-- fork:如果没有该配置，这个devtools不会起作用，即应用不会restart --&gt; &lt;fork&gt;true&lt;/fork&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 编辑器的自动构建IDEA file ，Settings ，Build ,Execution,Deplment (ctrl+shift+alt+S)，选择Compiler，对“Build project automaticaly”打钩。 Shift+ALT+Ctrl+/ ，选择Registry，修改默认注册关系，找“complier.automake.allow.when.app.running”，打钩后选择Close eclipse 导航栏，选择Build ，勾选Build Automaticaly Spring Cloud搭建Eureka搭建一个maven主工程projectIDEA File-new-project 选择maven项目 搭建一个服务注册中心的model工程IDEA File-new-model 选择Spring initialir项目 选择Cloud Discovery-Eureka Server PS:因人而异， Group：com.example、Artifact：eurekaserver POM1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.example&lt;/groupId&gt; &lt;artifactId&gt;eurekaserver&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;eurekaserver&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot eurekaServer&lt;/description&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.0.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;spring-cloud.version&gt;Greenwich.M1&lt;/spring-cloud.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt; &lt;version&gt;2.0.2.RELEASE&lt;/version&gt; &lt;!-- Version is important --&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;!-- fork:如果没有该配置，这个devtools不会起作用，即应用不会restart --&gt; &lt;fork&gt;true&lt;/fork&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;repositories&gt; &lt;repository&gt; &lt;id&gt;spring-milestones&lt;/id&gt; &lt;name&gt;Spring Milestones&lt;/name&gt; &lt;url&gt;https://repo.spring.io/milestone&lt;/url&gt; &lt;snapshots&gt; &lt;enabled&gt;false&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/repository&gt; &lt;/repositories&gt;&lt;/project&gt; 启动服务注册中心 在对应Eurekaserver的Application中添加注解@EnableEurekaServer 启动应用 打开网页：http://localhost:8080 可以看到DS Replicas有一个localhost的工程 配置服务注册中心 将resources资源目录下，默认的application.properties改为application.yml 指定server 设置eureka.client.registerWithEureka与eureka.client.fetchRegistry为false 重新启动服务注册中心 可以看到DS Replicas，No instances available application.yml 1234567891011server: port: 8761eureka: instance: hostname: localhost client: registerWithEureka: false fetchRegistry: false serviceUrl: defaultZone: http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/ eurekaServerApplication(src-main-java下) 1234567891011121314package com.example.eurekaserver;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;@EnableEurekaServer@SpringBootApplicationpublic class EurekaserverApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(EurekaserverApplication.class, args); &#125;&#125; 搭建一个服务提供者的model工程IDEA File-new-model 选择Spring initialir项目 选择Cloud Discovery-Eureka Client POM1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.example&lt;/groupId&gt; &lt;artifactId&gt;eurekaclient&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;eurekaclient&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.0.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;spring-cloud.version&gt;Greenwich.M1&lt;/spring-cloud.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt; &lt;version&gt;2.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;!-- fork:如果没有该配置，这个devtools不会起作用，即应用不会restart --&gt; &lt;fork&gt;true&lt;/fork&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;repositories&gt; &lt;repository&gt; &lt;id&gt;spring-milestones&lt;/id&gt; &lt;name&gt;Spring Milestones&lt;/name&gt; &lt;url&gt;https://repo.spring.io/milestone&lt;/url&gt; &lt;snapshots&gt; &lt;enabled&gt;false&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/repository&gt; &lt;/repositories&gt;&lt;/project&gt; 配置服务提供者 将resources资源目录下，默认的application.properties改为application.yml 指定server 重新启动服务提供者（前提是已启动了服务注册中心） 可以看到DS Replicas，SERVICE-HELLOCLIENT application.yml 1234567891011eureka: instance: hostname: localhost client: serviceUrl: defaultZone: http://$&#123;eureka.instance.hostname&#125;:8761/eureka/spring: application: name: service-helloClientserver: port: 8762 eurekaClientApplication(src-main-java下) 1234567891011121314151617181920212223242526package com.example.eurekaclient;import org.springframework.beans.factory.annotation.Value;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.netflix.eureka.EnableEurekaClient;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.bind.annotation.RestController;@EnableEurekaClient@SpringBootApplication@RestControllerpublic class EurekaclientApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(EurekaclientApplication.class, args); &#125; @Value(\"$&#123;server.port&#125;\") String port; @RequestMapping(\"helloClient\") public String helloClient(@RequestParam String name) &#123; return \"helloWorld,client:\"+name+\", port:\"+port; &#125;&#125; 启动服务提供者 启动服务提供者，8762端口启用 url输入：http://localhost:8762/helloClient?name=PinkSmallFan 显示：helloWorld,client:PinkSmallFan, port:8762 搭建一个负载均衡ribbonIDEA 将一个实例配置为多个实例 1）选择应用运行的“Edit configuration” 2）在对应Spring Boot上，选择对应的项目，并取消“Single instance only” 3）启动项目 4）项目启动成功后，修改对应的端口 5）再次启动（两个不同端口的实例） 搭建一个spring-boot工程（参考搭建服务提供者） pom继承父类pom文件 POM123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.example&lt;/groupId&gt; &lt;artifactId&gt;eurekaribbon&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;eurekaribbon&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;parent&gt; &lt;groupId&gt;com.example&lt;/groupId&gt; &lt;artifactId&gt;eurekaserver&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;spring-cloud.version&gt;Greenwich.M1&lt;/spring-cloud.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-ribbon&lt;/artifactId&gt; &lt;version&gt;2.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;repositories&gt; &lt;repository&gt; &lt;id&gt;spring-milestones&lt;/id&gt; &lt;name&gt;Spring Milestones&lt;/name&gt; &lt;url&gt;https://repo.spring.io/milestone&lt;/url&gt; &lt;snapshots&gt; &lt;enabled&gt;false&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/repository&gt; &lt;/repositories&gt;&lt;/project&gt; 配置服务消费者 将resources资源目录下，默认的application.properties改为application.yml 指定server 重新启动服务消费者者（前提是已启动了服务注册中心、服务提供者） 可以看到DS Replicas，SERVICE-HELLOCLIENT，SERVICE-RIBBON application.yml 1234567891011eureka: instance: hostname: localhost client: serviceUrl: defaultZone: http://$&#123;eureka.instance.hostname&#125;:8761/eureka/spring: application: name: service-ribbonserver: port: 8764 eurekaRibbonApplication(src-main-java下) 1234567891011121314151617181920212223242526package com.example.eurekaribbon;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.client.discovery.EnableDiscoveryClient;import org.springframework.cloud.client.loadbalancer.LoadBalanced;import org.springframework.cloud.netflix.eureka.EnableEurekaClient;import org.springframework.context.annotation.Bean;import org.springframework.web.client.RestTemplate;@EnableDiscoveryClient@EnableEurekaClient@SpringBootApplicationpublic class EurekaribbonApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(EurekaribbonApplication.class, args); &#125; @Bean @LoadBalanced RestTemplate restTemplate() &#123; return new RestTemplate(); &#125;&#125;// 这里选用了默认的策略：ZoneAvoidanceRule，复合判断server所在区域的性能和server的可用性选择server 配置一个Service 12345678910111213141516package com.example.eurekaribbon;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import org.springframework.web.client.RestTemplate;@Servicepublic class TestService &#123; @Autowired RestTemplate restTemplate; public String hello(String name) &#123; return restTemplate.getForObject(\"http://SERVICE-HELLOCLIENT/helloClient?name=\"+name, String.class); &#125;&#125; 配置一个Controller 12345678910111213141516171819package com.example.eurekaribbon;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.bind.annotation.RestController;@RestControllerpublic class TestController &#123; @Autowired TestService testService; @GetMapping(value=\"/helloClient\") public String helloClient(@RequestParam String name)&#123; return testService.hello(name); &#125;&#125; 配置负载均衡策略启动服务消费者 启动服务消费者者，8764端口启用 url输入：http://localhost:8764/helloClient?name=PinkSmallFan 多次访问，交替显示： helloWorld,client:PinkSmallFan, port:8762 helloWorld,client:PinkSmallFan, port:8763 搭建一个服务消费者feignIDEA 将一个实例配置为多个实例 1）选择应用运行的“Edit configuration” 2）在对应Spring Boot上，选择对应的项目，并取消“Single instance only” 3）启动项目 搭建一个spring-boot工程 pom继承父类pom文件 POM123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.example&lt;/groupId&gt; &lt;artifactId&gt;eurekafeign&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;eurekafeign&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;parent&gt; &lt;groupId&gt;com.example&lt;/groupId&gt; &lt;artifactId&gt;eurekaserver&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;spring-cloud.version&gt;Greenwich.M1&lt;/spring-cloud.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt; &lt;version&gt;2.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.ecwid&lt;/groupId&gt; &lt;artifactId&gt;ecwid-mailchimp&lt;/artifactId&gt; &lt;version&gt;2.0.1.0&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;repositories&gt; &lt;repository&gt; &lt;id&gt;spring-milestones&lt;/id&gt; &lt;name&gt;Spring Milestones&lt;/name&gt; &lt;url&gt;https://repo.spring.io/milestone&lt;/url&gt; &lt;snapshots&gt; &lt;enabled&gt;false&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/repository&gt; &lt;/repositories&gt;&lt;/project&gt; 配置服务消费者 将resources资源目录下，默认的application.properties改为application.yml 指定server 重新启动服务消费者者（前提是已启动了服务注册中心、服务提供者） 可以看到DS Replicas，SERVICE-HELLOCLIENT，SERVICE-RIBBON，SERVICE-FEIGN application.yml 1234567891011eureka: instance: hostname: localhost client: serviceUrl: defaultZone: http://$&#123;eureka.instance.hostname&#125;:8761/eureka/spring: application: name: service-feignserver: port: 8765 eurekaFeignApplication(src-main-java下) 123456789101112131415161718package com.example.eurekafeign;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.client.discovery.EnableDiscoveryClient;import org.springframework.cloud.netflix.eureka.EnableEurekaClient;import org.springframework.cloud.openfeign.EnableFeignClients;@SpringBootApplication@EnableEurekaClient@EnableFeignClients@EnableDiscoveryClientpublic class EurekafeignApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(EurekafeignApplication.class, args); &#125;&#125; 定义一个对外的接口，对应client的 123456789101112131415161718192021package com.example.eurekafeign;import org.springframework.cloud.openfeign.FeignClient;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import org.springframework.web.bind.annotation.RequestParam;@FeignClient(value = \"service-helloClient\")public interface TestServiceInterface &#123; @RequestMapping(value = \"/helloClient\", method = RequestMethod.GET) String sayHello(@RequestParam(value = \"name\") String name);&#125;/** in client@Value(\"$&#123;server.port&#125;\") String port; @RequestMapping(\"helloClient\") public String helloClient(@RequestParam String name) &#123; return \"helloWorld,client:\"+name+\", port:\"+port; &#125;*/ 配置一个Controller 123456789101112131415161718package com.example.eurekafeign;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.bind.annotation.RestController;@RestControllerpublic class TestController &#123; @Autowired TestServiceInterface service; @GetMapping(value = \"/helloClient\") public String sayHello(@RequestParam String name) &#123; return service.sayHello(name); &#125;&#125; 启动服务消费者 启动服务消费者者Feign，8765端口启用 url输入：http://localhost:8765/helloClient?name=PinkSmallFan 多次访问，交替显示： helloWorld,client:PinkSmallFan, port:8762 helloWorld,client:PinkSmallFan, port:8763 添加一个断路器Hystrix在ribbon上使用断路器pom添加依赖节点123456&lt;!--hystrix 断路器--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt; &lt;version&gt;2.0.2.RELEASE&lt;/version&gt;&lt;/dependency&gt; 配置断路器 Application上添加EnableHystrix注释 12@EnableHystrixpublic class EurekaribbonApplication&#123;...&#125; Service层添加注释，与对应短路后的处理方法 12345678910111213141516171819202122package com.example.eurekaribbon;import com.netflix.hystrix.contrib.javanica.annotation.HystrixCommand;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import org.springframework.web.client.RestTemplate;@Servicepublic class TestService &#123; @Autowired RestTemplate restTemplate; @HystrixCommand(fallbackMethod=\"helloError\") public String hello(String name) &#123; return restTemplate.getForObject(\"http://SERVICE-HELLOCLIENT/helloClient?name=\"+name, String.class); &#125; public String helloError(String name)&#123; return \"hello,\"+name+\",sorry, it's error now!\"; &#125;&#125; 启动服务消费者ribbon 启动服务消费者者 Ribbon，8764端口启用 url输入：http://localhost:8764/helloClient?name=PinkSmallFan 多次访问，交替显示： helloWorld,client:PinkSmallFan, port:8762 helloWorld,client:PinkSmallFan, port:8763 关闭一个client工程（8763），再次访问http://localhost:8764/helloClient?name=PinkSmallFan 多次访问，交替显示： helloWorld,client:PinkSmallFan, port:8762 hello,PinkSmallFan,sorry, it’s error now! 关闭一个client工程（8762），再次访问http://localhost:8764/helloClient?name=PinkSmallFan 多次访问，显示： hello,PinkSmallFan,sorry, it’s error now! 在feign上使用断路器配置启动断路器在application.yml上添加开启feign的hystrix功能（默认是关闭的） 123feign: hystrix: enabled: true 断路时的实现接口​ 新建一个类TestServiceHystrix，实现TestServiceInterface接口，用于在断路时的显示 12345678@Componentpublic class TestServiceHystrix implements TestServiceInterface &#123; @Override public String sayHello(String name) &#123; return \"hello,\"+name+\",error now.\"; &#125;&#125; 配置fallback在TestServiceInterface接口上添加fallback的注解 12@FeignClient(value = \"service-helloClient\", fallback = TestServiceHystrix.class)public interface TestServiceInterface &#123;...&#125; 启动服务消费者Feign 启动服务消费者者Feign，8765端口启用，client未启动 url输入：http://localhost:8765/helloClient?name=PinkSmallFan 多次访问，显示： hello,PinkSmallFan,error now. 开启一个client工程（8762），再次访问http://localhost:8765/helloClient?name=PinkSmallFan 多次访问，显示： helloWorld,client:PinkSmallFan, port:8762 搭建一个路由网关IDEA 搭建一个spring-boot工程（参考搭建服务提供者），选择zuul pom继承父类pom文件 POM12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.example&lt;/groupId&gt; &lt;artifactId&gt;eurekazuul&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;eurekazuul&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;spring-cloud.version&gt;2.0.2.RELEASE&lt;/spring-cloud.version&gt; &lt;!--Greenwich.M3--&gt; &lt;/properties&gt; &lt;parent&gt; &lt;groupId&gt;com.example&lt;/groupId&gt; &lt;artifactId&gt;eurekaserver&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;version&gt;2.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;version&gt;2.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-zuul&lt;/artifactId&gt; &lt;version&gt;2.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;version&gt;2.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;repositories&gt; &lt;repository&gt; &lt;id&gt;spring-milestones&lt;/id&gt; &lt;name&gt;Spring Milestones&lt;/name&gt; &lt;url&gt;https://repo.spring.io/milestone&lt;/url&gt; &lt;snapshots&gt; &lt;enabled&gt;false&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/repository&gt; &lt;/repositories&gt;&lt;/project&gt; 配置服务 将resources资源目录下，默认的application.properties改为application.yml 指定server application.yml 1234567891011121314151617181920eureka: instance: hostname: localhost client: serviceUrl: defaultZone: http://$&#123;eureka.instance.hostname&#125;:8761/eureka/spring: application: name: service-zuulserver: port: 8767zuul: routes: api-a: path: /api_a/** serviceId: service-ribbon api-b: path: /api_b/** serviceId: service-feign eurekazuulApplication(src-main-java下) 123456789101112131415161718package com.example.eurekazuul;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.client.discovery.EnableDiscoveryClient;import org.springframework.cloud.netflix.eureka.EnableEurekaClient;import org.springframework.cloud.netflix.zuul.EnableZuulProxy;@SpringBootApplication@EnableZuulProxy@EnableEurekaClient@EnableDiscoveryClientpublic class EurekazuulApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(EurekazuulApplication.class, args); &#125;&#125; 修改版本兼容zuul将eurekaserver中pom.xml的parent节点，springboot版本调至2.0.2，兼容zuul的问题（2.1的bug） 123456&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.2.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;/parent&gt; 启动服务提供者 启动服务提供者，8767端口启用 url输入：http://localhost:8767/api_b/helloClient?name=PinkSmallFan 显示：helloWorld,client:PinkSmallFan, port:8762 搭建分布式配置中心（server）IDEA 搭建一个spring-boot工程（参考搭建服务提供者），选择server config pom继承父类pom文件 POM1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.example&lt;/groupId&gt; &lt;artifactId&gt;eurekaconfigserver&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;eurekaconfigserver&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.1.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;spring-cloud.version&gt;Greenwich.M3&lt;/spring-cloud.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-config-server&lt;/artifactId&gt; &lt;version&gt;2.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;version&gt;2.0.2.RELEASE&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;repositories&gt; &lt;repository&gt; &lt;id&gt;spring-milestones&lt;/id&gt; &lt;name&gt;Spring Milestones&lt;/name&gt; &lt;url&gt;https://repo.spring.io/milestone&lt;/url&gt; &lt;snapshots&gt; &lt;enabled&gt;false&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/repository&gt; &lt;/repositories&gt;&lt;/project&gt; 配置服务 将resources资源目录下，默认的application.properties改为application.yml 指定server application.yml 123456789101112131415161718spring: application: name: config-server profiles: active: native cloud: config: server: native: search-locations: classpath:/config git: uri: https://github.com/forezp/SpringcloudConfig/ searchPaths: respo username: your username password: your password label: masterserver: port: 8768 在resources资源下添加config文件夹 添加eurekaconfigclient-dev.yml和eurekaconfigclient-pro.yml 1234env: name: dev password: 12345678 123env: name: pro password: 123456 6.eurekaconfigserverApplication(src-main-java下) 1234567891011121314package com.example.eurekaconfigserver;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.config.server.EnableConfigServer;@SpringBootApplication@EnableConfigServerpublic class EurekaconfigserverApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(EurekaconfigserverApplication.class, args); &#125;&#125; 启动服务配置 启动服务提供者，8768端口启用 url输入：http://localhost:8768/eurekaconfigclient/dev 显示：{“name”:”eurekaconfigclient”,”profiles”:[“dev”],”label”:null,”version”:null,”state”:null,”propertySources”:[{“name”:”classpath:/config/eurekaconfigclient-dev.yml”,”source”:{“env.name”:”dev”,”env.password”:12345678}}]} 搭建分布式配置中心（client）IDEA 搭建一个spring-boot工程（参考搭建服务提供者），选择client config pom继承父类pom文件 POM1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.example&lt;/groupId&gt; &lt;artifactId&gt;eurekaconfigclient&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;eurekaconfigclient&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.2.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;spring-cloud.version&gt;Greenwich.M3&lt;/spring-cloud.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt; &lt;version&gt;2.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;version&gt;2.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;version&gt;2.0.2.RELEASE&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;repositories&gt; &lt;repository&gt; &lt;id&gt;spring-milestones&lt;/id&gt; &lt;name&gt;Spring Milestones&lt;/name&gt; &lt;url&gt;https://repo.spring.io/milestone&lt;/url&gt; &lt;snapshots&gt; &lt;enabled&gt;false&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/repository&gt; &lt;/repositories&gt;&lt;/project&gt; 配置服务 将resources资源目录下，默认的application.properties改为bootstrap.yml。不能为application.yml 指定server bootstrap.yml（bootstrap是系统级别，不可覆盖不可更改；application是应用级别，可被覆盖与替换） 1234567891011spring: application: name: eurekaconfigclient cloud: config: profile: dev uri: http://localhost:8768 label: masterserver: port: 8861 eurekaconfigclientApplication(src-main-java下) 123456789101112131415161718192021222324package com.example.eurekaconfigclient;import org.springframework.beans.factory.annotation.Value;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;@SpringBootApplication@RestControllerpublic class EurekaconfigclientApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(EurekaconfigclientApplication.class, args); &#125; @Value(\"$&#123;env.password&#125;\") String password; @RequestMapping(value = \"/getPassword\") public String getPassword() &#123; return password; &#125;&#125; 启动服务配置 启动服务提供者，8861端口启用 url输入：http://localhost:8861/getPassword 显示：12345678 分布式配置中心集群管理流程 Eureka搭建（已搭建，可以忽略） config-server，pom上添加eureka-client 1234567891011 &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;version&gt;2.0.2.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;version&gt;2.0.2.RELEASE&lt;/version&gt;&lt;/dependency&gt; config-server，在application.yml上添加eureka节点 1234eureka: client: serviceUrl: defaultZone: http://localhost:8761/eureka/ config-server，在EurekaconfigserverApplication上添加注释：@EnableEurekaClient config-client，pom上添加eureka-client 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;version&gt;2.0.2.RELEASE&lt;/version&gt;&lt;/dependency&gt; config-client，在bootstarp.yml上添加/修改eureka节点 123456789101112131415161718eureka: client: serviceUrl: defaultZone: http://localhost:8761/eureka/spring: application: name: eurekaconfigclient cloud: config: profile: dev # uri: http://localhost:8768 # label: master discovery: enabled: true serviceId: config-serverserver: port: 8861 config-client，在EurekaconfigserverApplication上添加注释：@EnableEurekaClient、@EnableDiscoveryClient、@RefreshScope 重新启动分布式配置中心（server和client），打开eureka的注册中心，http://localhost:8761，会发现分布式配置中心已经关联到注册中心，打开网址：http://localhost:8861/getPassword，会显示“12345678” 分布式配置中心集成RabbitMQ搭建RabbitMQ： RabbitMQ下载地址：http://www.rabbitmq.com/download.html Github地址：https://github.com/rabbitmq/rabbitmq-server/releases erlang下载地址：http://www.erlang.org/downloads 安装erlang和RabbitMQ 配置环境变量: ERLANG_HOME与RABBITMQ_SERVER（;%ERLANG_HOME%\\bin;%RABBITMQ_SERVER%,并将这两个添加到PATH路径） cmd下输入erl，如果有版本号，并进入erl环境，待输入，那么证明erlang安装成功 在rabbitmq的sbin目录，输入./rabbitmq-plugins enable rabbitmq_management 在rabbitmq的sbin目录，双击rabbitmq-server.bat 访问http://localhost:15672，如果有页面产生，输入账号/密码：guest/guest，进入后台服务","categories":[{"name":"微服务","slug":"微服务","permalink":"https://pinksmallfan.github.io/WenChongAndJiaoKou/categories/微服务/"}],"tags":[]},{"title":"Base64编码","slug":"2018-11-7-Base64编码","date":"2018-11-07T08:01:36.000Z","updated":"2018-11-07T14:27:25.740Z","comments":true,"path":"2018/11/07/2018-11-7-Base64编码/","link":"","permalink":"https://pinksmallfan.github.io/WenChongAndJiaoKou/2018/11/07/2018-11-7-Base64编码/","excerpt":"","text":"伪代码流程代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199/** * Base64编解码器 */public class Base64Encoder&#123; private static final byte[] encodingTable = &#123; (byte) 'A', (byte) 'B', (byte) 'C', (byte) 'D', (byte) 'E', (byte) 'F', (byte) 'G', (byte) 'H', (byte) 'I', (byte) 'J', (byte) 'K', (byte) 'L', (byte) 'M', (byte) 'N', (byte) 'O', (byte) 'P', (byte) 'Q', (byte) 'R', (byte) 'S', (byte) 'T', (byte) 'U', (byte) 'V', (byte) 'W', (byte) 'X', (byte) 'Y', (byte) 'Z', (byte) 'a', (byte) 'b', (byte) 'c', (byte) 'd', (byte) 'e', (byte) 'f', (byte) 'g', (byte) 'h', (byte) 'i', (byte) 'j', (byte) 'k', (byte) 'l', (byte) 'm', (byte) 'n', (byte) 'o', (byte) 'p', (byte) 'q', (byte) 'r', (byte) 's', (byte) 't', (byte) 'u', (byte) 'v', (byte) 'w', (byte) 'x', (byte) 'y', (byte) 'z', (byte) '0', (byte) '1', (byte) '2', (byte) '3', (byte) '4', (byte) '5', (byte) '6', (byte) '7', (byte) '8', (byte) '9', (byte) '+', (byte) '/' &#125;; /* * set up the decoding table. */ private static final byte[] decodingTable; static &#123; decodingTable = new byte[128]; for (int i = 'A'; i &lt;= 'Z'; i++) &#123; decodingTable[i] = (byte) (i - 'A'); &#125; for (int i = 'a'; i &lt;= 'z'; i++) &#123; decodingTable[i] = (byte) (i - 'a' + 26); &#125; for (int i = '0'; i &lt;= '9'; i++) &#123; decodingTable[i] = (byte) (i - '0' + 52); &#125; decodingTable['+'] = 62; decodingTable['/'] = 63; &#125; /** * BASE64编码 * @param date : 二进制数组 * @return 包含BASE64编码后的字符串 */ public static String encode(byte[] data) &#123; byte[] bytes; int modulus = data.length % 3; if (modulus == 0) &#123; bytes = new byte[4 * data.length / 3]; &#125; else &#123; bytes = new byte[4 * ((data.length / 3) + 1)]; &#125; int dataLength = (data.length - modulus); int a1, a2, a3; for (int i = 0, j = 0; i &lt; dataLength; i += 3, j += 4) &#123; a1 = data[i] &amp; 0xff; a2 = data[i + 1] &amp; 0xff; a3 = data[i + 2] &amp; 0xff; bytes[j] = encodingTable[(a1 &gt;&gt;&gt; 2) &amp; 0x3f]; bytes[j + 1] = encodingTable[((a1 &lt;&lt; 4) | (a2 &gt;&gt;&gt; 4)) &amp; 0x3f]; bytes[j + 2] = encodingTable[((a2 &lt;&lt; 2) | (a3 &gt;&gt;&gt; 6)) &amp; 0x3f]; bytes[j + 3] = encodingTable[a3 &amp; 0x3f]; &#125; /* * process the tail end. */ int b1, b2, b3; int d1, d2; switch (modulus) &#123; case 0: /* nothing left to do */ break; case 1: d1 = data[data.length - 1] &amp; 0xff; b1 = (d1 &gt;&gt;&gt; 2) &amp; 0x3f; b2 = (d1 &lt;&lt; 4) &amp; 0x3f; bytes[bytes.length - 4] = encodingTable[b1]; bytes[bytes.length - 3] = encodingTable[b2]; bytes[bytes.length - 2] = (byte) '='; bytes[bytes.length - 1] = (byte) '='; break; case 2: d1 = data[data.length - 2] &amp; 0xff; d2 = data[data.length - 1] &amp; 0xff; b1 = (d1 &gt;&gt;&gt; 2) &amp; 0x3f; b2 = ((d1 &lt;&lt; 4) | (d2 &gt;&gt;&gt; 4)) &amp; 0x3f; b3 = (d2 &lt;&lt; 2) &amp; 0x3f; bytes[bytes.length - 4] = encodingTable[b1]; bytes[bytes.length - 3] = encodingTable[b2]; bytes[bytes.length - 2] = encodingTable[b3]; bytes[bytes.length - 1] = (byte) '='; break; &#125; return new String(bytes); &#125; /** * 判断字符串是否base64字符串 * @param str : 字符串 * @return boolean */ public static boolean isbase64str(String str) &#123; for(int i=0;i&lt;str.length();i++) &#123; char t= str.charAt(i); if(t&gt;='A' &amp;&amp; t&lt;='Z')continue; if(t&gt;='a' &amp;&amp; t&lt;='z')continue; if(t&gt;='0' &amp;&amp; t&lt;='9')continue; switch(t)&#123; case '+': case '/': case '=': case ' ': case '\\t': case '\\n': case '\\f': case '\\r': continue; default: return false; &#125; &#125; return true; &#125; /** * BASE64解码 * @param base64 : base64字符串 * @return 解码后的原始二进制数据 */ public static byte[] decode(String base64) &#123; base64= base64.replaceAll(\"\\\\s\",\"\"); //去除所有空格 \"[ \\t\\n\\x0B\\f\\r]\" byte[] data= base64.getBytes(); byte[] bytes; byte b1, b2, b3, b4; if(data[data.length - 2] == '=') &#123; bytes = new byte[(((data.length / 4) - 1) * 3) + 1]; &#125;else if (data[data.length - 1] == '=') &#123; bytes = new byte[(((data.length / 4) - 1) * 3) + 2]; &#125;else &#123; bytes = new byte[((data.length / 4) * 3)]; &#125; for (int i = 0, j = 0; i &lt; data.length - 4; i += 4, j += 3) &#123; b1 = decodingTable[data[i]]; b2 = decodingTable[data[i + 1]]; b3 = decodingTable[data[i + 2]]; b4 = decodingTable[data[i + 3]]; bytes[j] = (byte) ((b1 &lt;&lt; 2) | (b2 &gt;&gt; 4)); bytes[j + 1] = (byte) ((b2 &lt;&lt; 4) | (b3 &gt;&gt; 2)); bytes[j + 2] = (byte) ((b3 &lt;&lt; 6) | b4); &#125; if (data[data.length - 2] == '=') &#123; b1 = decodingTable[data[data.length - 4]]; b2 = decodingTable[data[data.length - 3]]; bytes[bytes.length - 1] = (byte) ((b1 &lt;&lt; 2) | (b2 &gt;&gt; 4)); &#125; else if (data[data.length - 1] == '=') &#123; b1 = decodingTable[data[data.length - 4]]; b2 = decodingTable[data[data.length - 3]]; b3 = decodingTable[data[data.length - 2]]; bytes[bytes.length - 2] = (byte) ((b1 &lt;&lt; 2) | (b2 &gt;&gt; 4)); bytes[bytes.length - 1] = (byte) ((b2 &lt;&lt; 4) | (b3 &gt;&gt; 2)); &#125; else &#123; b1 = decodingTable[data[data.length - 4]]; b2 = decodingTable[data[data.length - 3]]; b3 = decodingTable[data[data.length - 2]]; b4 = decodingTable[data[data.length - 1]]; bytes[bytes.length - 3] = (byte) ((b1 &lt;&lt; 2) | (b2 &gt;&gt; 4)); bytes[bytes.length - 2] = (byte) ((b2 &lt;&lt; 4) | (b3 &gt;&gt; 2)); bytes[bytes.length - 1] = (byte) ((b3 &lt;&lt; 6) | b4); &#125; return bytes; &#125;&#125;","categories":[],"tags":[{"name":"密码学","slug":"密码学","permalink":"https://pinksmallfan.github.io/WenChongAndJiaoKou/tags/密码学/"}]},{"title":"python常用","slug":"2018-11-4-python常用","date":"2018-11-04T09:24:34.000Z","updated":"2018-11-04T22:04:40.468Z","comments":true,"path":"2018/11/04/2018-11-4-python常用/","link":"","permalink":"https://pinksmallfan.github.io/WenChongAndJiaoKou/2018/11/04/2018-11-4-python常用/","excerpt":"","text":"常用函数12ord() # 将char数据转为ASCII数据，例如：'0'转为48,ord('0')chr() # 将ASCII数据转为char数据，例如：65转为'A',chr(65)","categories":[],"tags":[{"name":"python","slug":"python","permalink":"https://pinksmallfan.github.io/WenChongAndJiaoKou/tags/python/"}]},{"title":"实验吧（困在栅栏里的凯撒）","slug":"2018-11-4-实验吧(困在栅栏里的凯撒)","date":"2018-11-04T07:58:54.000Z","updated":"2018-11-15T16:12:31.058Z","comments":true,"path":"2018/11/04/2018-11-4-实验吧(困在栅栏里的凯撒)/","link":"","permalink":"https://pinksmallfan.github.io/WenChongAndJiaoKou/2018/11/04/2018-11-4-实验吧(困在栅栏里的凯撒)/","excerpt":"","text":"困在栅栏里的凯撒题目 小白发现了一段很6的字符：NlEyQd{seft} 解题思路​ 顾名思义，先栅栏，后凯撒 栅栏（FenceCode） 12341：NEQ&#123;etlydsf&#125;2：Ny&#123;flQstEde&#125;3：NQeldfE&#123;tys&#125;4：N&#123;lsEeyfQtd&#125; 凯撒（CaeserCode） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291：OFR&#123;fumzetg&#125;2：Oz&#123;gmRtuFef&#125;3：ORfmegF&#123;uzt&#125;4：O&#123;mtFfzgRue&#125;1：PGS&#123;gvnafuh&#125;2：Pa&#123;hnSuvGfg&#125;3：PSgnfhG&#123;vau&#125;4：P&#123;nuGgahSvf&#125;1：QHT&#123;hwobgvi&#125;2：Qb&#123;ioTvwHgh&#125;3：QThogiH&#123;wbv&#125;4：Q&#123;ovHhbiTwg&#125;1：RIU&#123;ixpchwj&#125;2：Rc&#123;jpUwxIhi&#125;3：RUiphjI&#123;xcw&#125;4：R&#123;pwIicjUxh&#125;1：SJV&#123;jyqdixk&#125;2：Sd&#123;kqVxyJij&#125;3：SVjqikJ&#123;ydx&#125;4：S&#123;qxJjdkVyi&#125;1：TKW&#123;kzrejyl&#125;2：Te&#123;lrWyzKjk&#125;3：TWkrjlK&#123;zey&#125;4：T&#123;ryKkelWzj&#125;1：ULX&#123;lasfkzm&#125;2：Uf&#123;msXzaLkl&#125;3：UXlskmL&#123;afz&#125;4：U&#123;szLlfmXak&#125;1：VMY&#123;mbtglan&#125;2：Vg&#123;ntYabMlm&#125;3：VYmtlnM&#123;bga&#125;4：V&#123;taMmgnYbl&#125;1：WNZ&#123;ncuhmbo&#125;2：Wh&#123;ouZbcNmn&#125;3：WZnumoN&#123;chb&#125;4：W&#123;ubNnhoZcm&#125;1：XOA&#123;odvincp&#125;2：Xi&#123;pvAcdOno&#125;3：XAovnpO&#123;dic&#125;4：X&#123;vcOoipAdn&#125;1：YPB&#123;pewjodq&#125;2：Yj&#123;qwBdePop&#125;3：YBpwoqP&#123;ejd&#125;4：Y&#123;wdPpjqBeo&#125;1：ZQC&#123;qfxkper&#125;2：Zk&#123;rxCefQpq&#125;3：ZCqxprQ&#123;fke&#125;4：Z&#123;xeQqkrCfp&#125;1：ARD&#123;rgylqfs&#125;2：Al&#123;syDfgRqr&#125;3：ADryqsR&#123;glf&#125;4：A&#123;yfRrlsDgq&#125;1：BSE&#123;shzmrgt&#125;2：Bm&#123;tzEghSrs&#125;3：BEszrtS&#123;hmg&#125;4：B&#123;zgSsmtEhr&#125;1：CTF&#123;tianshu&#125;2：Cn&#123;uaFhiTst&#125;3：CFtasuT&#123;inh&#125;4：C&#123;ahTtnuFis&#125;1：DUG&#123;ujbotiv&#125;2：Do&#123;vbGijUtu&#125;3：DGubtvU&#123;joi&#125;4：D&#123;biUuovGjt&#125;1：EVH&#123;vkcpujw&#125;2：Ep&#123;wcHjkVuv&#125;3：EHvcuwV&#123;kpj&#125;4：E&#123;cjVvpwHku&#125;1：FWI&#123;wldqvkx&#125;2：Fq&#123;xdIklWvw&#125;3：FIwdvxW&#123;lqk&#125;4：F&#123;dkWwqxIlv&#125;1：GXJ&#123;xmerwly&#125;2：Gr&#123;yeJlmXwx&#125;3：GJxewyX&#123;mrl&#125;4：G&#123;elXxryJmw&#125;1：HYK&#123;ynfsxmz&#125;2：Hs&#123;zfKmnYxy&#125;3：HKyfxzY&#123;nsm&#125;4：H&#123;fmYyszKnx&#125;1：IZL&#123;zogtyna&#125;2：It&#123;agLnoZyz&#125;3：ILzgyaZ&#123;otn&#125;4：I&#123;gnZztaLoy&#125;1：JAM&#123;aphuzob&#125;2：Ju&#123;bhMopAza&#125;3：JMahzbA&#123;puo&#125;4：J&#123;hoAaubMpz&#125;1：KBN&#123;bqivapc&#125;2：Kv&#123;ciNpqBab&#125;3：KNbiacB&#123;qvp&#125;4：K&#123;ipBbvcNqa&#125;1：LCO&#123;crjwbqd&#125;2：Lw&#123;djOqrCbc&#125;3：LOcjbdC&#123;rwq&#125;4：L&#123;jqCcwdOrb&#125;1：MDP&#123;dskxcre&#125;2：Mx&#123;ekPrsDcd&#125;3：MPdkceD&#123;sxr&#125;4：M&#123;krDdxePsc&#125;1：NEQ&#123;etlydsf&#125;2：Ny&#123;flQstEde&#125;3：NQeldfE&#123;tys&#125;4：N&#123;lsEeyfQtd&#125; 就可以看到答案是：CTF{tianshu}","categories":[{"name":"实验吧","slug":"实验吧","permalink":"https://pinksmallfan.github.io/WenChongAndJiaoKou/categories/实验吧/"}],"tags":[{"name":"密码学","slug":"密码学","permalink":"https://pinksmallfan.github.io/WenChongAndJiaoKou/tags/密码学/"},{"name":"other","slug":"other","permalink":"https://pinksmallfan.github.io/WenChongAndJiaoKou/tags/other/"},{"name":"实验吧","slug":"实验吧","permalink":"https://pinksmallfan.github.io/WenChongAndJiaoKou/tags/实验吧/"}]},{"title":"Java WebService服务端与客户端的搭建","slug":"2018-11-2-Java-WebService服务端与客户端的搭建","date":"2018-11-02T01:29:00.000Z","updated":"2018-11-02T13:02:00.830Z","comments":true,"path":"2018/11/02/2018-11-2-Java-WebService服务端与客户端的搭建/","link":"","permalink":"https://pinksmallfan.github.io/WenChongAndJiaoKou/2018/11/02/2018-11-2-Java-WebService服务端与客户端的搭建/","excerpt":"","text":"服务端最简单的WebService服务端流程 搭建一个web工程 在web工程建立包（这里我命名为xx.xxaa，其他也没关系） 在web工程建立一个类，并命名（这里我命名为ServiceServer，其他也没关系） 编写main方法，开启服务 1234567891011121314151617181920import javax.jws.WebService;import javax.xml.ws.Endpoint;@WebServicepublic class ServiceServer &#123; /** * 客户端将会调用的方法（服务端被调用的方法） * @param something * @return */ public String serverPrint(String something)&#123; return \"Server print: \"+something; &#125; public static void main(String[] args)&#123; Endpoint.publish(\"http://127.0.0.1:9991/Service/ServiceServer\", new ServiceServer()); System.out.print(\"service open success! Enjoy it...\"); &#125;&#125; 打开网址：http://127.0.0.1:9991/Service/ServiceServer?wsdl 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!-- Published by JAX-WS RI (http://jax-ws.java.net). RI's version is JAX-WS RI 2.2.9-b130926.1035 svn-revision#5f6196f2b90e9460065a4c2f4e30e065b245e51e. --&gt;&lt;!-- Generated by JAX-WS RI (http://jax-ws.java.net). RI's version is JAX-WS RI 2.2.9-b130926.1035 svn-revision#5f6196f2b90e9460065a4c2f4e30e065b245e51e. --&gt;&lt;definitions xmlns:wsu=\"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd\" xmlns:wsp=\"http://www.w3.org/ns/ws-policy\" xmlns:wsp1_2=\"http://schemas.xmlsoap.org/ws/2004/09/policy\" xmlns:wsam=\"http://www.w3.org/2007/05/addressing/metadata\" xmlns:soap=\"http://schemas.xmlsoap.org/wsdl/soap/\" xmlns:tns=\"http://service.netcaaa.netca.net/\" xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\" xmlns=\"http://schemas.xmlsoap.org/wsdl/\" targetNamespace=\"http://service.xxaa.xx/\" name=\"ServiceServerService\"&gt;&lt;types&gt;&lt;xsd:schema&gt;&lt;xsd:import namespace=\"http://service.xxaa.xx/\" schemaLocation=\"http://127.0.0.1:9991/Service/ServiceServer?xsd=1\"/&gt;&lt;/xsd:schema&gt;&lt;/types&gt;&lt;message name=\"serverPrint\"&gt;&lt;part name=\"parameters\" element=\"tns:serverPrint\"/&gt;&lt;/message&gt;&lt;message name=\"serverPrintResponse\"&gt;&lt;part name=\"parameters\" element=\"tns:serverPrintResponse\"/&gt;&lt;/message&gt;&lt;portType name=\"ServiceServer\"&gt;&lt;operation name=\"serverPrint\"&gt;&lt;input wsam:Action=\"http://service.xxaa.xx/ServiceServer/serverPrintRequest\" message=\"tns:serverPrint\"/&gt;&lt;output wsam:Action=\"http://service.xxaa.xx/ServiceServer/serverPrintResponse\" message=\"tns:serverPrintResponse\"/&gt;&lt;/operation&gt;&lt;/portType&gt;&lt;binding name=\"ServiceServerPortBinding\" type=\"tns:ServiceServer\"&gt;&lt;soap:binding transport=\"http://schemas.xmlsoap.org/soap/http\" style=\"document\"/&gt;&lt;operation name=\"serverPrint\"&gt;&lt;soap:operation soapAction=\"\"/&gt;&lt;input&gt;&lt;soap:body use=\"literal\"/&gt;&lt;/input&gt;&lt;output&gt;&lt;soap:body use=\"literal\"/&gt;&lt;/output&gt;&lt;/operation&gt;&lt;/binding&gt;&lt;service name=\"ServiceServerService\"&gt;&lt;port name=\"ServiceServerPort\" binding=\"tns:ServiceServerPortBinding\"&gt;&lt;soap:address location=\"http://127.0.0.1:9991/Service/ServiceServer\"/&gt;&lt;/port&gt;&lt;/service&gt;&lt;/definitions&gt; 客户端流程 搭建一个普通的Project工程 在Project工程建立一个类，并命名（这里我命名为ServiceClient，其他也没关系） cmd编译Service开启服务，提供的Web服务描述语言，生成对应客户端的代码（解析WSDL、生成代码、编译代码） 123# wsimport -s /project/src -p package.client -keep http://127.0.0.1:9991/Service/ServiceServer?wsdlwsimport -s C:/WebServiceProject/src -p xx.xxaa.client -keep http://127.0.0.1:9991/Service/ServiceServer?wsdl 编写main方法，连接服务 123456789101112131415161718package net.netca.netcaaa.test;import xx.xxaa.client.ServiceServer;import xx.xxaa.client.ServiceServerService;public class ServiceClient &#123; public static void main(String[] args) &#123; // 请求服务 ServiceServer server = new ServiceServerService().getServiceServerPort(); // 调用服务 String printData = server.serverPrint(\"2018年11月2日09:51:45\"); System.out.println(printData); &#125;&#125;// 打印内容如下：// Server print: 2018年11月2日09:51:45 ###","categories":[],"tags":[{"name":"java","slug":"java","permalink":"https://pinksmallfan.github.io/WenChongAndJiaoKou/tags/java/"}]},{"title":"R语言下order、rank、sort的使用","slug":"R语言下order、rank、sort的使用","date":"2018-11-01T07:51:38.000Z","updated":"2018-11-04T02:30:25.060Z","comments":true,"path":"2018/11/01/R语言下order、rank、sort的使用/","link":"","permalink":"https://pinksmallfan.github.io/WenChongAndJiaoKou/2018/11/01/R语言下order、rank、sort的使用/","excerpt":"","text":"sort、rank、order的定义 sort：对一个向量x的排序 rank：对排序的结果，进行原数组1到n的排名 order：对sort排序后的数组，对应原数组数组的位置 举例123456z&lt;-c(9,2,14,6,3,1) # 一共6个数sort(z) # 输出 1,2,3,6,9,14rank(z) # 输出 5,2,6,4,3,1 (9,2,14,6,3,1)的排名，9排名第5；14排名第6order(z) # 输出 6,2,5,4,1,3 (1,2,3,6,9,14)在(9,2,14,6,3,1)的位置# order，比如(1,2,3,6,9,14)中的1在(9,2,14,6,3,1)是第6位，(1,2,3,6,9,14)中的14在(9,2,14,6,3,1)是第3位order(z,decreasing = TRUE) # 输出3,1,4,5,2,6,为order排序的反排序","categories":[],"tags":[{"name":"R","slug":"R","permalink":"https://pinksmallfan.github.io/WenChongAndJiaoKou/tags/R/"},{"name":"生信","slug":"生信","permalink":"https://pinksmallfan.github.io/WenChongAndJiaoKou/tags/生信/"}]},{"title":"JAVA_GC日志分析","slug":"JAVA_GC日志分析","date":"2018-10-30T09:33:21.000Z","updated":"2018-11-15T16:24:04.437Z","comments":true,"path":"2018/10/30/JAVA_GC日志分析/","link":"","permalink":"https://pinksmallfan.github.io/WenChongAndJiaoKou/2018/10/30/JAVA_GC日志分析/","excerpt":"","text":"配置Windows1set \"JAVA_OPTS=%JAVA_OPTS% -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -Xloggc:%CATALINA_HOME%/logs/tomcat_gc.log\" Linux12 日志打印1234567891011121314151617181920212223242526272829Java HotSpot(TM) 64-Bit Server VM (25.92-b14) for windows-amd64 JRE (1.8.0_92-b14), built on Mar 31 2016 21:03:04 by \"java_re\" with MS VC++ 10.0 (VS2010)Memory: 4k page, physical 8281844k(2149156k free), swap 16563688k(2821648k free)CommandLine flags: -XX:InitialHeapSize=132509504 -XX:MaxHeapSize=2120152064 -XX:+PrintGC -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:-UseLargePagesIndividualAllocation -XX:+UseParallelGC 0.752: [GC (Allocation Failure) [PSYoungGen: 33280K-&gt;5088K(38400K)] 33280K-&gt;8036K(125952K), 0.0060004 secs] [Times: user=0.00 sys=0.02, real=0.01 secs] 1.066: [GC (Allocation Failure) [PSYoungGen: 38368K-&gt;5101K(38400K)] 41316K-&gt;14206K(125952K), 0.0067035 secs] [Times: user=0.08 sys=0.05, real=0.01 secs] 1.295: [GC (Allocation Failure) [PSYoungGen: 38381K-&gt;5103K(38400K)] 47486K-&gt;20597K(125952K), 0.0056209 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 1.568: [GC (Allocation Failure) [PSYoungGen: 38383K-&gt;5101K(71680K)] 53877K-&gt;22063K(159232K), 0.0047853 secs] [Times: user=0.00 sys=0.01, real=0.00 secs] 1.842: [GC (Allocation Failure) [PSYoungGen: 71661K-&gt;5094K(71680K)] 88623K-&gt;26332K(159232K), 0.0054331 secs] [Times: user=0.00 sys=0.00, real=0.01 secs] 2.036: [GC (Allocation Failure) [PSYoungGen: 71654K-&gt;9722K(145920K)] 92892K-&gt;30967K(233472K), 0.0070884 secs] [Times: user=0.05 sys=0.08, real=0.01 secs] 2.536: [GC (Allocation Failure) [PSYoungGen: 142842K-&gt;12793K(145920K)] 164087K-&gt;40684K(233472K), 0.0160709 secs] [Times: user=0.13 sys=0.00, real=0.02 secs] 2.951: [GC (Allocation Failure) [PSYoungGen: 145913K-&gt;17389K(278528K)] 173804K-&gt;52575K(366080K), 0.0191865 secs] [Times: user=0.06 sys=0.00, real=0.02 secs] 3.876: [GC (Allocation Failure) [PSYoungGen: 278509K-&gt;22517K(283648K)] 313695K-&gt;68138K(371200K), 0.0283277 secs] [Times: user=0.06 sys=0.01, real=0.03 secs] 4.712: [GC (Allocation Failure) [PSYoungGen: 283637K-&gt;26941K(444416K)] 329258K-&gt;75433K(531968K), 0.0244180 secs] [Times: user=0.03 sys=0.00, real=0.02 secs] 5.929: [GC (Allocation Failure) [PSYoungGen: 441661K-&gt;32745K(447488K)] 490153K-&gt;97742K(535040K), 0.0445053 secs] [Times: user=0.01 sys=0.02, real=0.04 secs] 6.643: [GC (Allocation Failure) [PSYoungGen: 447465K-&gt;43506K(610816K)] 512462K-&gt;139231K(706560K), 0.1259313 secs] [Times: user=0.11 sys=0.02, real=0.13 secs] 6.769: [Full GC (Ergonomics) [PSYoungGen: 43506K-&gt;5558K(610816K)] [ParOldGen: 95725K-&gt;95741K(160256K)] 139231K-&gt;101300K(771072K), [Metaspace: 15778K-&gt;15778K(1064960K)], 0.1242255 secs] [Times: user=0.88 sys=0.02, real=0.12 secs] 8.180: [GC (Allocation Failure) [PSYoungGen: 572854K-&gt;61409K(628736K)] 668596K-&gt;183826K(788992K), 0.1223716 secs] [Times: user=0.08 sys=0.03, real=0.12 secs] 10.120: [GC (Allocation Failure) [PSYoungGen: 628705K-&gt;49902K(585728K)] 751122K-&gt;174795K(745984K), 0.0286591 secs] [Times: user=0.03 sys=0.02, real=0.03 secs] 11.454: [GC (Metadata GC Threshold) [PSYoungGen: 278885K-&gt;9853K(607232K)] 403778K-&gt;139883K(767488K), 0.0074279 secs] [Times: user=0.08 sys=0.00, real=0.01 secs] 11.461: [Full GC (Metadata GC Threshold) [PSYoungGen: 9853K-&gt;0K(607232K)] [ParOldGen: 130030K-&gt;35015K(113664K)] 139883K-&gt;35015K(720896K), [Metaspace: 26949K-&gt;26949K(1073152K)], 0.0459526 secs] [Times: user=0.16 sys=0.02, real=0.05 secs] 14.681: [GC (Allocation Failure) [PSYoungGen: 524288K-&gt;20133K(600064K)] 559303K-&gt;55157K(713728K), 0.0090754 secs] [Times: user=0.00 sys=0.00, real=0.01 secs] 21.688: [GC (Metadata GC Threshold) [PSYoungGen: 332707K-&gt;7017K(604160K)] 367730K-&gt;59045K(717824K), 0.0103632 secs] [Times: user=0.13 sys=0.00, real=0.01 secs] 21.698: [Full GC (Metadata GC Threshold) [PSYoungGen: 7017K-&gt;0K(604160K)] [ParOldGen: 52028K-&gt;49336K(140288K)] 59045K-&gt;49336K(744448K), [Metaspace: 45055K-&gt;45018K(1089536K)], 0.1324701 secs] [Times: user=0.77 sys=0.00, real=0.13 secs] 27.316: [GC (Allocation Failure) [PSYoungGen: 525312K-&gt;4448K(608256K)] 574648K-&gt;53793K(748544K), 0.0027460 secs] [Times: user=0.01 sys=0.00, real=0.00 secs] 29.158: [GC (Allocation Failure) [PSYoungGen: 537952K-&gt;1568K(610304K)] 587297K-&gt;54126K(750592K), 0.0024272 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 41.077: [GC (Allocation Failure) [PSYoungGen: 535072K-&gt;752K(609792K)] 587630K-&gt;54484K(750080K), 0.0019681 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 43.047: [GC (Allocation Failure) [PSYoungGen: 538864K-&gt;752K(611840K)] 592596K-&gt;54492K(752128K), 0.0017160 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 55.079: [GC (Allocation Failure) [PSYoungGen: 538864K-&gt;752K(610816K)] 592604K-&gt;54500K(751104K), 0.0017559 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 57.078: [GC (Allocation Failure) [PSYoungGen: 545008K-&gt;704K(613888K)] 598756K-&gt;54452K(754176K), 0.0023127 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 参考 https://www.cnblogs.com/Vince-blogs/p/8484640.html","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://pinksmallfan.github.io/WenChongAndJiaoKou/tags/Java/"}]},{"title":"网易入职路线","slug":"网易入职路线","date":"2018-10-27T12:10:45.000Z","updated":"2018-11-14T15:52:15.224Z","comments":true,"path":"2018/10/27/网易入职路线/","link":"","permalink":"https://pinksmallfan.github.io/WenChongAndJiaoKou/2018/10/27/网易入职路线/","excerpt":"","text":"基本知识必知必会 DB额外素质 所有技能汇总 精通java编程，熟悉java sdk提供的主要能力; 理解java运行时工作原理，熟悉jvm性能调优，能够充分利用java特性支持框架与程序库的设计开发; 熟悉多线程编程，熟练使用java并发包下的各项常用基础设施; 熟悉网络编程，能够熟练使用java nio开发高并发、高吞吐量的服务; 熟悉常用网络协议，如TCP/IP, HTTP; 能够熟练使用linux，能够利用常用的工具对程序进行跟踪诊断; 有分布式系统开发经验，对消息服务、负载均衡、高可用机制等有深入理解，有开放平台开发经验者优先； 具备良好学习、沟通能力及团队协作精神，对工作积极严谨，勇于承担压力。 参与公众号、小程序、小游戏等微信相关产品开发； 参与Web业务系统开发； 精通Web系统开发； 精通Java语言，及Spring、MyBatis/Hibernate等后端框架框架； 熟悉数据库相关技术，熟悉MySQL和Oracle，版本，字段区别，熟悉SQL性能优化 熟练使用Spring相关技术，例如Spring Boot、Spring Cloud、Spring Security等； 熟练使用Memcached、MongoDB、RabbitMQ等中间件； 优秀的沟通协作和逻辑分析能力，能对团队成员进行开发和技术指导。 熟悉Spring/Netty/Rabbitmq/Hystrix等； 熟悉Nginx/Tomcat等web服务器； redis持久化策略，redis五种数据结构？ZSET怎么实现 怎么分析生产环境GC情况？（jconsole、jvisualvm、runtime包、dump日志）？说下分析GC日志 MQ、MQ怎么保证恰好被消费一次？如果多次消费怎么保证幂等？因为上游业务bug或者其他问题不断的收到同一条消息怎么保证消费者的业务不受影响？ dubbo也就是RPC的完整流程是怎么样的（序列化、传输、动态代理……），dubbo的优点是什么？为什么要用dubbo？没有rpc的时候是怎么做的？all in one 这种模式有什么优点？dubbo的消费者为什么也要注册到zookeeper？只有提供者注册服务不行吗？dubbo为什么用hessian?jdk的序列化有什么问题？xml、json为啥不行？dubbo网络传输是怎么实现的？ mongdb实现细节","categories":[],"tags":[{"name":"other","slug":"other","permalink":"https://pinksmallfan.github.io/WenChongAndJiaoKou/tags/other/"}]},{"title":"实验吧ctf训练题库","slug":"CTF","date":"2018-10-25T16:53:27.000Z","updated":"2018-11-15T16:09:19.133Z","comments":true,"path":"2018/10/26/CTF/","link":"","permalink":"https://pinksmallfan.github.io/WenChongAndJiaoKou/2018/10/26/CTF/","excerpt":"","text":"WEB密码学变异凯撒题目： 加密密文：afZ_r9VYfScOeO_UL^RWUc格式：flag{ } 解题思路afZ_转字符串：97 102 90 95 flag转字符串：102 108 97 103 规律：5 6 7 8 解题过程（python3）：1234567891011encryptData='afZ_r9VYfScOeO_UL^RWUc'i=5b=''index=0for data in encryptData: b=b[:index]+chr(ord(data)+i) i=i+1 index=index+1b# chr(data):将ASCII转字符串# ord(data):将字符串转ASCII 解题结果 ‘flag{Caesar_variation}’","categories":[],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://pinksmallfan.github.io/WenChongAndJiaoKou/tags/CTF/"}]},{"title":"SQLite的实践与使用","slug":"SQLite3的实践与使用","date":"2018-10-25T03:47:33.000Z","updated":"2018-11-16T15:28:21.615Z","comments":true,"path":"2018/10/25/SQLite3的实践与使用/","link":"","permalink":"https://pinksmallfan.github.io/WenChongAndJiaoKou/2018/10/25/SQLite3的实践与使用/","excerpt":"","text":"概念什么是SQLite3 ​ SQLite is an in-process library that implements a self-contained, serverless, zero-configuration, transactional SQL database engine. The code for SQLite is in the public domain and is thus free for use for any purpose, commercial or private. SQLite is the most widely deployed database in the world with more applications than we can count, including several high-profile projects. ​ SQLite is an embedded SQL database engine. Unlike most other SQL databases, SQLite does not have a separate server process. SQLite reads and writes directly to ordinary disk files. A complete SQL database with multiple tables, indices, triggers, and views, is contained in a single disk file. The database file format is cross-platform - you can freely copy a database between 32-bit and 64-bit systems or between big-endian and little-endian architectures. These features make SQLite a popular choice as an Application File Format. ​ 简单来说，SQLite是一个切入式的，独立的，没有独立服务器进程，零配置的事务性数据库引擎，通过直接读取和写入磁盘文件的方式来操作多个表、索引、触发器和视图的完整 SQL 数据库。 操作读取数据库表​ Linux系统，都基本会自带有SQLite3，直接运行即可。 ​ windows系统，需要上官网下载对应的动态链接库+tool工具进行数据库操作。 ​ 另外，如果安装有python，也会自带有sqlite3模块，引入即可用。 Linux1234567891011# Linux --&gt; 直接运行# 读取数据库sqlite3 /var/tmp/trust.db# 显示数据库信息.databases# 显示表信息.tables# 帮助.help# 读取数据库表select * from table2; Windows123456789101112131415# Windows# 步骤1：官网地址下载：https://www.sqlite.org/download.html# 步骤2：sqlite-dll-win64-xxx-xxxxx.zip、sqlite-tools-win32-x86-xxxxx.zip 并解压到自己本地指定的文件夹# 步骤3：双击sqlite3.exe or cmd命令sqlite3.exe ./trust.db# 步骤4：加载数据库，这里用restore，不是open！详情请看.help.restore c:/tmp/trust.db# 显示数据库信息.databases# 显示表信息.tables# 帮助.help# 读取数据库表select * from table2 python1234567891011# python# 引用sqlite3，并加载数据库，建立连接import sqlite3;conn=sqlite3.connect(\"C:/tmp/trust.db\");cursor=conn.cursor();# 读取数据库表cursor.execute(\"select name from table2;\")values=cursor.fetchall()valuescursor.close()conn.close() 参考 SQLite3的简单操作：https://www.jianshu.com/p/424a8b143bbb 廖雪峰python：https://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000/001388320596292f925f46d56ef4c80a1c9d8e47e2d5711000 sqlite3官网：https://www.sqlite.org/about.html","categories":[],"tags":[{"name":"数据库","slug":"数据库","permalink":"https://pinksmallfan.github.io/WenChongAndJiaoKou/tags/数据库/"}]},{"title":"密钥对的相关操作（keytool、openSSL)","slug":"2018-10-25-密钥对的相关操作（keytool、openSSL)","date":"2018-10-25T02:01:32.000Z","updated":"2018-10-28T14:34:47.525Z","comments":true,"path":"2018/10/25/2018-10-25-密钥对的相关操作（keytool、openSSL)/","link":"","permalink":"https://pinksmallfan.github.io/WenChongAndJiaoKou/2018/10/25/2018-10-25-密钥对的相关操作（keytool、openSSL)/","excerpt":"","text":"cacerts概念cacerts：trusted certificate authority (CA) certificates ​ The cacerts file is a collection of trusted certificate authority (CA) certificates. Sun Microsystems™ includes a cacerts file with its SSL support in the Java™ Secure Socket Extension (JSSE) tool kit and JDK 1.4.x. It contains certificate references for well-known Certificate authorities, such as VeriSign™. Its format is the “keystore” format defined by Sun. An administrator can edit the cacerts file with a command line tool (also provided by Sun) called keytool. For more information about keytool, see the Sun Web site. Note: The default password for the cacerts file supplied by Sun is changeit. You must use this password to view the contents or to import a new certificate. For security reasons, change the default password. The essential requirement is that the certificate authority that signed the HPE Service Manager server’s certificate must be in the list of certificate authorities named in this file. To use a self-issued server certificate created with OpenSSL or a tool such as Microsoft Certificate Server™, you must import the certificate for this private certificate authority into the cacerts file that the client uses for SSL. If you do not import the certificate, SSL connections fail because the Java SSL implementation does not recognize the certificate authority. ​ 简单的来说，cacerts是java用于接受受信任的证书已经证书链，cacerts默认包含有一些众所周知的权威证书，以及证书链。当你需要使用https协议，为你的服务添加ssl的时候，需要将你的证书和证书链导入cacerts（如果已经导入过了，就不需要了）。 keytool查看java自带的cacerts1234567891011# Linuxcd $JAVA_HOME/jre/lib/securitykeytool -list -storepass changeit -keystore \"./cacerts\" # 查询所有的证书keytool -list -storepass changeit -keystore \"./cacerts\" |grep server # 查询alias带有server的证书# Windowscd %JAVA_HOME%/jre/lib/securitykeytool -list -storepass changeit -keystore \"./cacerts\" # 查询所有的证书keytool -list -storepass changeit -keystore \"./cacerts\" |findstr /i server# 查询alias带有server的证书 产生jks密钥对12# 产生一个签名算法为SHA256withRSA的，密钥长度为2048，的RSA密钥对，即软证书server.jkskeytool -keystore server.jks -genkey -alias xxx_server -keyalg RSA -sigalg SHA256withRSA -keysize 2048 导出jks的证书12# 证书，即公钥keytool -export -alias server -keystore server.jks -rfc -file sign.cer 导入证书到cacerts123cd $JAVA_HOME/jre/lib/security# 将证书导入cacerts，并别名为serverkeytool -import -keystore \"./cacerts\" -alias server -trustcacerts -storepass changeit -file /var/tmp/certs/Server.cer 在cacerts上删除证书123cd $JAVA_HOME/jre/lib/security# 删除命名为server的证书keytool -delete -alias server -keystore \"./cacerts\" -storepass changeit 参数分析 -genkey 在用户主目录中创建一个默认文件”.keystore” 的软证书,产生一个mykey的别名，其中包含用户的公钥、私钥和证书(在没有指定生成位置的情况下,keystore会存在用户系统默认目录，如：对于window xp系统，会生成在系统的C:/Documents and Settings/UserName/文件名为“.keystore”)-alias 产生别名，keytool将通过这个别名进行查找-keystore 指定密钥库的名称(产生的各类信息将不在.keystore文件中)-keyalg 指定密钥的算法 (如 RSA DSA（如果不指定默认采用DSA），推荐采用RSA)-validity 指定创建的证书有效期多少天-keysize 指定密钥长度-storepass 指定密钥库的密码(获取keystore信息所需的密码)-keypass 指定别名条目的密码(私钥的密码)-dname 指定证书拥有者信息-list 显示密钥库中的证书信息-v 显示密钥库中的证书详细信息-export 将别名指定的证书导出到文件-file 参数指定导出到文件的文件名-delete 删除密钥库中某条目-printcert 查看导出的证书信息-keypasswd 修改密钥库中指定条目口令-storepasswd 修改keystore口令-import 将已签名数字证书导入密钥库 证书拥有者信息 例如： “CN=名字与姓氏,OU=组织单位名称,O=组织名称,L=城市或区域名称,ST=州或省份名称,C=单位的两字母国家代码” 常用命令： keytool -export -alias 需要导出的别名 -keystore 指定keystore -file 指定导出的证书路径位置，及证书名称 -storepass 密码 keytool -printcert -file yushan.crt keytool -delete -alias 指定需删除的别 -keystore 指定keystore -storepass 密码 keytool -list -v -keystore 指定keystore -storepass 密码 keytool -import -alias 指定导入条目的别名 -keystore 指定keystore -file 需导入的证书 keytool -storepasswd -keystore e:/yushan.keystore(需修改口令的keystore) -storepass 123456(原始密码) -new yushan(新密码) keytool -keypasswd -alias 需修改的别名 -keypass 旧密码 -new 新密码 -storepass keystore密码 -keystore sage 下面是各选项的缺省值。-alias “mykey”-keyalg “DSA”-keysize 1024-validity 90-keystore 用户宿主目录中名为 .keystore 的文件-file 读时为标准输入，写时为标准输出 参考 什么是cacerts： https://docs.microfocus.com/SM/9.50/Hybrid/Content/security/concepts/what_is_a_cacerts_file.htm","categories":[],"tags":[{"name":"密码学","slug":"密码学","permalink":"https://pinksmallfan.github.io/WenChongAndJiaoKou/tags/密码学/"}]},{"title":"PKI技术","slug":"PKI技术","date":"2018-10-24T15:46:06.000Z","updated":"2018-10-24T15:46:34.027Z","comments":true,"path":"2018/10/24/PKI技术/","link":"","permalink":"https://pinksmallfan.github.io/WenChongAndJiaoKou/2018/10/24/PKI技术/","excerpt":"","text":"","categories":[],"tags":[{"name":"密码学","slug":"密码学","permalink":"https://pinksmallfan.github.io/WenChongAndJiaoKou/tags/密码学/"}]},{"title":"json解析","slug":"json解析","date":"2018-10-24T01:34:56.000Z","updated":"2018-11-02T13:02:00.914Z","comments":true,"path":"2018/10/24/json解析/","link":"","permalink":"https://pinksmallfan.github.io/WenChongAndJiaoKou/2018/10/24/json解析/","excerpt":"","text":"JSON结构结构12345678910111213141516&#123; \"workers\":[ &#123; \"id\":\"1\", \"name\":\"programmer\" &#125;, &#123; \"id\":\"2\", \"name\":\"productManager\" &#125;, &#123; \"id\":\"3\", \"name\":\"leader\" &#125; ]&#125; bean实例一个单位对应一个bean123456789101112131415161718public class Worker &#123; private int id; private String name; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125; 一个集合对应一个bean1234567891011public class Workers &#123; private List&lt;Worker&gt; workers; public List&lt;Worker&gt; getWorkers() &#123; return workers; &#125; public void setWorkers(List&lt;Worker&gt; workers) &#123; this.workers = workers; &#125;&#125; 举例12345678910111213141516171819202122public class JSONUtils&#123; /** * * &lt;/p&gt; 说明：&lt;/p&gt; * @param path 读取目录结构的路径，例如：\"/src/workers.json\" * @return 目录结构 * */ public static Workers getMap(String path) throws IOException&#123; InputStream inputStream = JSONUtils.class.getClassLoader().getResourceAsStream(path); String json = readAsString(inputStream); JSONObject jsonObject = JSONObject.fromObject(json); //修改类型，解决JSON net.sf.ezmorph.bean.MorphDynaBean cannot be cast to com.xxx.xxxx.vo.Work的错误 Map classMap = new HashMap(); classMap.put(\"workers\", Worker.class); JSONUtils.getMorpherRegistry().registerMorpher(new DateMorpher(new String[] &#123;\"yyyy-MM-dd\", \"yyyy-MM-dd HH:mm:ss\"&#125;)); Workers workers = (Workers) JSONObject.toBean(jsonObject, Workers.class, classMap); return Workers; &#125; 备注1234567891011121314151617181920212223242526/** * 输出从指定路径+文件名读取到的文件流的字符内容。 * @param inputStream 输入流 * @throws IOException*/public static String readAsString(InputStream inputStream)throws IOException&#123; BufferedReader reader = null; StringBuilder sb = new StringBuilder(); String line; try&#123; reader = new BufferedReader(new InputStreamReader(inputStream, \"utf-8\")); while((line = reader.readLine()) != null)&#123; sb.append(line); sb.append(\"\\r\\n\"); &#125; return sb.toString(); &#125;finally&#123; if(reader != null)&#123; try&#123; reader.close(); &#125;catch (IOException e) &#123; &#125; &#125; &#125; &#125;","categories":[],"tags":[{"name":"java","slug":"java","permalink":"https://pinksmallfan.github.io/WenChongAndJiaoKou/tags/java/"}]},{"title":"kailLinux的使用","slug":"kailLinux的使用","date":"2018-10-22T13:07:50.000Z","updated":"2018-10-22T13:47:33.425Z","comments":true,"path":"2018/10/22/kailLinux的使用/","link":"","permalink":"https://pinksmallfan.github.io/WenChongAndJiaoKou/2018/10/22/kailLinux的使用/","excerpt":"","text":"桌面","categories":[],"tags":[{"name":"ctf","slug":"ctf","permalink":"https://pinksmallfan.github.io/WenChongAndJiaoKou/tags/ctf/"},{"name":"linux","slug":"linux","permalink":"https://pinksmallfan.github.io/WenChongAndJiaoKou/tags/linux/"}]},{"title":"test","slug":"2018-10-21-test","date":"2018-10-21T13:59:00.000Z","updated":"2018-10-21T13:59:15.269Z","comments":true,"path":"2018/10/21/2018-10-21-test/","link":"","permalink":"https://pinksmallfan.github.io/WenChongAndJiaoKou/2018/10/21/2018-10-21-test/","excerpt":"","text":"test！！","categories":[],"tags":[]},{"title":"ssh key应用(git远程服务器)","slug":"ssh-keygen应用","date":"2018-10-21T10:07:27.000Z","updated":"2018-11-15T16:10:25.938Z","comments":true,"path":"2018/10/21/ssh-keygen应用/","link":"","permalink":"https://pinksmallfan.github.io/WenChongAndJiaoKou/2018/10/21/ssh-keygen应用/","excerpt":"","text":"概念什么是公钥、私钥能够解决什么问题本地生成公钥与密钥### 在本地生成密钥对通过git bash的编码 123ssh-keygen -t rsa -b 4096 -C \"xxxx@xx.com\" # 输入密码，生成密钥对：xxxa和xxxa.pubcp xxxa ~/.ssh/ # 将密钥放到指定~/.ssh文件夹下cat xxxa.pub # 打印出公钥文件，这一个可以先拷贝起来，用于服务端使用 将密钥放到指定的ssh路径下（git默认读取的ssh文件路径） 将私钥添加到缓存上1ssh-add ~/.ssh/xxxa # ssh-add的作用主要将密钥添加到 ssh-agent 的高速缓存中，这样在当前会话中就不需要再次输入密码了 建立github的ssh key登录github https://github.com/settings/keys 点击New SSH key，将xxxa.pub公钥文件的拷贝值黏贴进来，title随便填，只是方便看。 在本机测试连接github1ssh -T git@github.com # 因为我们把项目寄托在了github的服务器上了，所以是github.com 建立VPS服务的ssh key拷贝公钥编码1cat xxxa.pub # 打印出公钥文件，这一个可以先拷贝起来，用于服务端使用 在vps服务上存放公钥文件1vi ~/.ssh/git_authorzied_keys # 前提是配置好了ssh服务 在本机测试连接github1ssh -T git@xxxx.com # git是用户，因为我们把项目寄托在了VPS服务器上了，所以是ip地址或者域名 配置多个git服务 可能公司与私用的github不一样，但是我们希望同一个客户端，能够同时同步到两个服务器。 .ssh目录下配置config123456789101112Host github.com User git Hostname github.com #第一个的git地址 IdentityFile ~/.ssh/keyPaira #访问第一个git的SSH KEY Port 9102 #第一个的git端口Host xxxb.com User git Hostname xxxb.com #第二个的github的地址 IdentityFile ~/.ssh/keyPairb #访问第二个的github的SSH KEY Port 22# PS：在git中，因为字符编码的问题，注释含有中文会出错","categories":[],"tags":[{"name":"配置","slug":"配置","permalink":"https://pinksmallfan.github.io/WenChongAndJiaoKou/tags/配置/"}]},{"title":"Namesilp购买域名","slug":"Namesilp购买域名","date":"2018-10-21T01:34:39.000Z","updated":"2018-11-14T15:50:59.039Z","comments":true,"path":"2018/10/21/Namesilp购买域名/","link":"","permalink":"https://pinksmallfan.github.io/WenChongAndJiaoKou/2018/10/21/Namesilp购买域名/","excerpt":"","text":"前提流程namesilo官网 www.namesilo.com 注册过程 姓名、邮箱、国家、地址、手机号 验证邮箱 PS：注册信息尽量真实。没有必要担心你的真实信息被暴露，Namesilo 会提供免费的 Domain Privacy Protection 服务。 domain查找 在home页面上，就是domainSearch啦 选择域名 区别1. com 2. net 3. org 4. club 5. top 顶级、高端、高级、首席、顶端等 6. info 确认订单 设置域名续费规则、自动续费、设置隐私保护、注册时长（1年）、输入优惠码：okoff、go2think 支付 银行卡（推荐） PayPal（绑定银行卡也是比较麻烦的一点） 支付宝（需要用到的注册邮箱，由于本人支付宝找不到注册邮箱，就用银行卡了） bitcoin namesilo Skrill DWOLLA 域名解析设置DNS服务器 点击Manager My Domains 勾选你的域名（这样子才可以勾选ACTIONS for selectede Domains） 点击Changes NameServers（更改域名服务器） 判断是否DNS解析成功 https://www.ipip.net/ip.html 参考 https://www.jianshu.com/p/27b0ebdcec2c","categories":[],"tags":[{"name":"other","slug":"other","permalink":"https://pinksmallfan.github.io/WenChongAndJiaoKou/tags/other/"},{"name":"配置","slug":"配置","permalink":"https://pinksmallfan.github.io/WenChongAndJiaoKou/tags/配置/"}]},{"title":"VPS搭建hexo私人blog","slug":"blog+hexo+vps","date":"2018-10-20T16:01:55.000Z","updated":"2018-10-21T13:23:38.551Z","comments":true,"path":"2018/10/21/blog+hexo+vps/","link":"","permalink":"https://pinksmallfan.github.io/WenChongAndJiaoKou/2018/10/21/blog+hexo+vps/","excerpt":"","text":"前提条件参数VPS Location Los Angeles CPU Cores 1 x 2.1 GHz RAM 512 x MB Space 15 x GB Number of IPs 1 x IPv4 Number of IPv6 Address 1 x IPv6 Bandwidth 500 x GB 准备工作域名Githubhexo博客vps远程工具原理搭建流程安装Git1yum install -y git 安装nodeJs1yum install -y nodejs 安装Nginx1yum install -y nginx 检查安装情况123git --version # 1.8.3.1node -v # v10.12.0 or node --versionnginx -v # nginx/1.12.2 配置Nginx1234# 进入nginx路径，默认为这个路径，如果没有，可以 find / -name \"nginx\" 找一找cd /etc/nginxcp nginx.conf nginx.conf.bak # 习惯性备份vi nginx.conf # 编辑nginx.conf 修改nginx.conf的user节点 1user gui; 修改nginx.conf的server节点 1234567891011121314151617181920server &#123; listen 80 default_server; listen [::]:80 default_server; server_name www.wenchongjiaokou.info wenchongjiaokou.info; root /home/gui/blog/; # Load configuration files for the default server block. include /etc/nginx/default.d/*.conf; location / &#123; &#125; error_page 404 /404.html; location = /40x.html &#123; &#125; error_page 500 502 503 504 /50x.html; location = /50x.html &#123; &#125;&#125; 启动Nginx12service nginx start # 启动nginx or systemctl start nginxservice nginx status # 查看nginx状态 or systemctl status nginx,active(running)就OK 安装Git用户123adduser gitchmod 740 /etc/sudoersvi /etc/sudoers 将git赋予执行sudoers权限的作用 12xxc ALL=(ALL) ALL# 作用：允许系统管理员让普通用户执行一些或者全部的root命令，但是没有root权限访问，依旧是用户的身份 将权限保存回原来的样子 1chmod 400 /etc/sudoers 给Git用户配置ssh12345cd /home/xxcmkdir ~/.sshvi ~/.ssh/git_authorzied_keys # 将本地机子的xxxx.pub公钥文件文本打开，拷贝编码值粘贴此处chmod 600 ~/.ssh/git_authorzied_keyschmod 700 ~/.ssh 本地git访问服务器1ssh -v git@服务器地址 # 服务器地址：ip地址、域名地址 建立git目录12cd /home/xxcgit init --bare xxxd.git # 初始化一个xxxd.init，可通过ls查看创建文件 注意点参考 VPS搭建个人博客：https://www.xksblog.top/use-VPS-to-build-personal-Hexo-blog.html","categories":[],"tags":[{"name":"other","slug":"other","permalink":"https://pinksmallfan.github.io/WenChongAndJiaoKou/tags/other/"},{"name":"配置","slug":"配置","permalink":"https://pinksmallfan.github.io/WenChongAndJiaoKou/tags/配置/"}]},{"title":"锻炼PC肌","slug":"PC肌的锻炼","date":"2018-10-20T11:41:20.000Z","updated":"2018-10-20T15:04:40.054Z","comments":true,"path":"2018/10/20/PC肌的锻炼/","link":"","permalink":"https://pinksmallfan.github.io/WenChongAndJiaoKou/2018/10/20/PC肌的锻炼/","excerpt":"","text":"什么是PC肌PC肌图 上男下女 切面图 PC肌概念​ PC肌，是英文pubococcygeus muscle的缩写，即耻尾肌，通俗的讲，对于男性而言就是靠近尿道和直肠的肌肉，对于女性而言，这个肌肉靠近尿道、阴道、直肠（如上图） PC肌锻炼定位PC肌#### 停止排尿 ​ 假装你正在小便，然后通过快速的肌肉收缩停止排尿。这个过程中，你用于停止膀胱排尿的肌肉就是PC肌。（注意：以下训练中，不可以通过憋尿的方式来练习！） 女生版​ 将两腿打开，用一根手指伸进洞洞，尝试用力收缩夹紧手指，感受发力点。 男生版​ 用力将丁丁动一下（向上顶、颤动一下），感受用力的肌肉。 ​ PC肌锻炼的目标 （女）改善下面松弛问题 （女）预防和治疗尿失禁 （女）防止子宫脱落 （女）增加洞洞弹性 （女）防止顺产时私处撕裂 （女）增加做爱时啪啪啪的摩擦感 （女）增强高潮时的收缩度 （男）锻炼你控制射精的肌肉，避免早泄。 （男）锻炼出具有“肌肉感”的阴茎（也就是充分让它变粗）。 （男）提高射精量和射精频率。 （男）预防前列腺癌 显著改善性能力。 锻炼出具有多次性高潮，而无疲惫感。 PC肌锻炼的基本方法 不停的进行停止排尿感觉的锻炼（不是指排尿的时候锻炼，而是定位PC肌，找到感觉） 直接躺床，两腿伸直 锻炼姿势，躺床版本 锻炼姿势，坐椅版本：坐在椅子上，背靠椅背，两腿双脚岔开八字，PC肌相当于面向正前方 PC肌锻炼的初级方法阶段一（第一周） 每天进行3组。 每组收缩PC肌20下。 每次收缩保持1到2秒。 放松肌肉。 每周进行3到4天。 正常呼吸，避免屏气。 阶段二（第二周） 每天进行3组。 每组收缩PC肌20下。 每组慢速收缩PC肌10下。 非慢速收缩：每次PC肌保持1到2秒。 慢速收缩：5秒时间慢慢对PC肌收缩 直至不能继续收缩为止。 每次收缩保持5秒以上。 尽可能的利用剩下的5秒时间逐渐放松肌肉。 PC肌锻炼的中级方法阶段一（第三周） 每天三组。 每组收缩PC肌50下。 每次收缩PC肌保持5到7秒。 开始感受如何单独或同时收缩你的阴茎和肛门括约肌 阶段二（第四周） 阶段一+锻炼结束后。 进行PC肌交替练习。 非常慢的收缩PC肌（数分钟）。 保持缓和的呼吸。 极限时，开始收缩PC肌20下。 需要收缩到完全收缩的位置点上，并保持30秒。 阶段三（第五周） 阶段一+锻炼结束后。 进行PC肌断续练习。 断断续续的收缩PC肌。 断断续续的放松肌肉。 要点：轻轻的断断续续，直到完全收紧；反过来一样。 阶段四—男生专用版 勃起状态 每组30次 方法一：小毛巾放在勃起的丁丁上（给丁丁施压，举重） 方法一：PC肌收缩举起小毛巾，坚持2到5秒 方法二：手放在丁丁上方1到2英寸（丁丁摸高） 方法二：PC肌收缩顶到手掌位置，坚持2到5秒 方法三：手放在丁丁上方1到2英寸，并往下压（丁丁举重+摸高） 方法三：PC肌收缩到手手掌位置，手掌下压，坚持2到5秒 放松 PC肌锻炼的高级方法阶段一（伴侣款） 勃起状态+湿湿状态 男性勃起、抽插，女性进入状态 男性与女性轮流收缩 阶段二（反复高潮锻炼） 勃起状态 逐渐按摩丁丁，直到高潮 接近高潮，停止按摩，开始收缩PC肌 勃起状态变疲软，重复第2点 再次接近高潮，重复第3点 阶段三（魔鬼级别） 只做1组 热身：50下PC肌收缩 尽可能收缩PC肌，30s 收缩2s，放松2s，100下PC肌收缩 尽可能收缩PC肌，1min 休息2min 50下PC肌收缩，5秒收缩练习。 PC肌锻炼的注意点 PC肌的锻炼，是肌肉的锻炼，所以切不可做过多的量！不然效果相反，只会损伤肌肉，达不到锻炼的作用。 一开始锻炼的时候，尽可能的在安静的地方练习，需要提高注意力，把注意力集中在，进行锻炼！切不可以分心进行PC肌收缩。 练习需要坚持不懈，为了你的xing福，每天都需要训练，逐渐加强。 （男性）这种锻炼会更多偏向于变得有肌肉（充血更充沛） 找不到感觉，需要加强自身的运动（跑步、深蹲等），同时花上1周时间进行PC定位，去感觉，但是切不可通过排尿进行锻炼！ 锻炼感觉，需要有胀热感 参考 PC肌练习：https://zh.wikihow.com/%E9%94%BB%E7%82%BCPC%E8%82%8C 知乎：https://www.zhihu.com/question/21012557 PC肌练习男女版：https://mp.weixin.qq.com/s/Ap7c1o808CE5Z2kLITmPpQ","categories":[],"tags":[{"name":"other","slug":"other","permalink":"https://pinksmallfan.github.io/WenChongAndJiaoKou/tags/other/"}]},{"title":"Gradle与Maven的区别","slug":"Gradle&Maven","date":"2018-10-18T16:51:18.000Z","updated":"2018-10-18T16:51:51.630Z","comments":true,"path":"2018/10/19/Gradle&Maven/","link":"","permalink":"https://pinksmallfan.github.io/WenChongAndJiaoKou/2018/10/19/Gradle&Maven/","excerpt":"","text":"","categories":[],"tags":[{"name":"对比","slug":"对比","permalink":"https://pinksmallfan.github.io/WenChongAndJiaoKou/tags/对比/"}]},{"title":"：常见error","slug":"error","date":"2018-10-18T16:01:30.000Z","updated":"2018-11-15T16:09:08.439Z","comments":true,"path":"2018/10/19/error/","link":"","permalink":"https://pinksmallfan.github.io/WenChongAndJiaoKou/2018/10/19/error/","excerpt":"","text":"Javajar包引用冲突slf4j 错误描述： 12idea SLF4J: Failed to load class &quot;org.slf4j.impl.StaticLoggerBinder&quot;.Defaulting to no-operation (NOP) logger implementation 错误原因：spring-boot自带了slf4j，引起错误的冲突包，是：maven通过依赖导包，而且在jdk-jre-lib-ext下包含了slf4j的包 解决方案：删除maven多余的依赖，删除jdk-jre-lib-ext下包含了slf4j的包","categories":[],"tags":[{"name":"error","slug":"error","permalink":"https://pinksmallfan.github.io/WenChongAndJiaoKou/tags/error/"}]},{"title":"idea下的spring-boot搭建","slug":"idea下spring-boot的搭建","date":"2018-10-18T11:51:01.000Z","updated":"2018-11-15T16:11:42.329Z","comments":true,"path":"2018/10/18/idea下spring-boot的搭建/","link":"","permalink":"https://pinksmallfan.github.io/WenChongAndJiaoKou/2018/10/18/idea下spring-boot的搭建/","excerpt":"","text":"Level 1：helloworld File-&gt;new-&gt;Module-&gt;Spring Initializr-&gt;Default-&gt;Next 填写Group、Artifact、选择Maven project-&gt;Next 选择Web-&gt;Web-&gt;Finish 12345678910&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; 在xxxApplication.java的同级目录下，建立一个controller文件夹，在controller下新建一个HelloController.java 编写控制层 123456789@RestController@EnableAutoConfigurationpublic class HelloController &#123; @RequestMapping(\"/hello\") private String index()&#123; return \"Hello World\"; &#125;&#125; 访问主页：http://localhost:8080/hello Level2：Mysql数据库 yml配置 12345spring: datasource: url: jdbc:mysql://192.168.88.107:3306/mytest?useUnicode=true&amp;characterEncoding=utf8&amp;autoReconnect=true username: root password: 123456 数据库建表 1234567DROP TABLE IF EXISTS `persion`;CREATE TABLE `persion` ( `id` int(11) NOT NULL, `name` varchar(255) NULL DEFAULT NULL, `age` int(11) NULL DEFAULT NULL, PRIMARY KEY (`id`) USING BTREE) ENGINE = InnoDB CHARACTER SET = utf8 bean类 123456789101112131415161718public class Persion &#123; private int id; private String name; private int age; private String description; @Override public String toString() &#123; return \"Person&#123;\" + \"id=\" + id + \", name='\" + name + '\\'' + \", age=\" + age + \", description='\" + description + '\\'' + '&#125;'; &#125;&#125; Level3：Mybatis 添加依赖 12345&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt;&lt;/dependency&gt; 编写mapper 1234567891011import net.aguicode.demo.bo.Persion;import org.apache.ibatis.annotations.Mapper;import org.apache.ibatis.annotations.Param;import org.apache.ibatis.annotations.Select;@Mapperpublic interface PersionMapper &#123; @Select(\"SELECT * FROM PERSION WHERE id = #&#123;id&#125;\") Persion getById(@Param(\"id\") int id);&#125;","categories":[{"name":"微服务","slug":"微服务","permalink":"https://pinksmallfan.github.io/WenChongAndJiaoKou/categories/微服务/"}],"tags":[{"name":"spring boot","slug":"spring-boot","permalink":"https://pinksmallfan.github.io/WenChongAndJiaoKou/tags/spring-boot/"}]},{"title":"浅谈Saas","slug":"浅谈Saas","date":"2018-10-17T08:54:20.000Z","updated":"2018-10-18T00:11:08.843Z","comments":true,"path":"2018/10/17/浅谈Saas/","link":"","permalink":"https://pinksmallfan.github.io/WenChongAndJiaoKou/2018/10/17/浅谈Saas/","excerpt":"","text":"Sass初体验什么是SaasSaas：Software as a server，软件即服务。 ​ 简单一句话，就是“云软件”。 ​ Saas厂商搭建好了设备、平台、软件，将应用程序以及数据库等部署到了云服务上，企业通过“租用”这种软件，而非传统的“买断”、下载即用的方式来获得软件服务。Saas服务提供了软件与服务器等的维护、技术支持。 Saas公司 国际：Salesforce、ORACLE、SAP、微软 国内：北森、纷享销客、销售易、EC、腾讯企点、易企秀、智趣百川、钉钉、企业微信、智齿、Udesk、有赞、微盟 对比Sass、Pass、Iaas​ 前提：有一个用户，需要一个xxx功能的应用。 ​ 方案一：用户什么也没有，需要采购一些设备、购买对应的开发工具、接着开发出这个应用软件供自己使用； ​ 方案二：用户不想购买设备了，直接购买了云服务，享受场外的服务器、存储和网络硬件，但是在云服务上，其他的什么也没有，还需要购买或搭建对应的开发工具、操作系统等，并维护这些平台，接着才能开发对应的应用软件，架在云服务上运行； ​ 方案三：用户直接购买了云服务，并且云服务还提供了中间件，即各种开发和分发应用的工具、OS, 编程语言, 开发库, 部署工具, 帮助软件开发者更快的开发软件服务等，用户可以直接在上面开发应用程序，就行了。 ​ 方案四：用户什么都不想做，直接购买了云服务，这个云服务，提供了设备、支持运行应用的平台、还有想要应用程序，都给你打包好了，你只要直接用就行了，连维护啥的都不需要。 Iaas Paas Saas 主要用户 系统管理员 开发人员 普通用户 主要技术 Virualization、VMware、Virtual Box、Xen Google GFS、BidTable、Hadoop、HDFS、TFS 分布式应用程序、SOAP、Https、Web2.0、Paas API 主要产品 Amazon EC2、IBM Blue Cloud、Digital Ocean Google App Engine、Windows Azure Platform Google Apps、Salesforce Sales Cloud、Facebook 虚拟化、服务器、存储、网络硬件 有 有 有 运行环境、中间件、操作系统 无 有 有 应用、数据 无 无 有 安全性 高 中 低 关注点 设备 软件环境 功能 ​ Saas的四个分级 级别 特点 一级（定制开发） 不可配置、无高性能、不可伸缩 二级（可配置） 可配置、无高性能、不可伸缩 三级（高性能的多租户架构） 可配置、高性能、不可伸缩 四级（可伸缩性的多租户架构） 可配置、高性能、可伸缩 定制开发：软件服务提供商为每个客户定制一套专属软件，不同软件版本有分属的独立代码，并被分别部署在不同的数据库实例和应用服务器实例上 可配置：为每个客户独立部署一个运行实例。只是，与一级成熟度模型中“每个实例专属一份代码”相比，二级成熟度模型中，每个实例共享同一份代码，而客户的个性化需求，仅通过不同的配置来实现。 高性能的多租用架构：隔离不同租户数据，确保不同租户共享同一个运行实例的基础上，为每个租户提供独立的应用体验和数据空间 可伸缩性的多租用架构：将已接入用户数据分配到不同Instance以分担用户访问的方式，解决多租户单实例应用架构下，集中式数据库随租户数量增多而性能受限的问题。一种高效的水平扩展策略，在租户数量大增时，无需更改应用架构，而仅需简单增加硬件设备数量 ，就可实现“支撑应用规模增长，方便实施应用修改”的效果。 Saas 架构Saas 关键点Saas——多用户租赁模式 分布式计算模型 分布式数据存储和访问模型 分布式部署运维模型 分布式数据库 Ocean数据库（阿里巴巴） MHA架构 预定义、行转列、XML扩展字段 工作流程docker——业务流程可配置 java自带工作流程 ### 技术方案 Protal 负载均衡（LVS） 单点登录（opensso、CAS、Josso） 消息中间件（JBoss、ActiveMQ） 分布式文件存储（Hadoop HDFS 、MogleFS） 数据缓存（EH，M） MOSQL（MangoDB） 目录服务（OpenDS、OpenLDAP） 想法云js 云dll 云接口 云数据库 第一站——CA 第二站——？？ 第三站——？？ 第四站——？？ ？？ ？？ 手头有什么资源，有利于自己的发展？？ 建立一个方案的服务与系统应用集成！！ 参考网站 什么是Saas：https://new.qq.com/omn/20180720/20180720A1BAAC.html Saas的窘境与未来：http://www.infoq.com/cn/articles/SaaS-SkyNAS-Synology 阮一峰：http://www.ruanyifeng.com/blog/2017/07/iaas-paas-saas.html Saas的4级成熟度模型：https://www.jianshu.com/p/a401f951d560 电商架构：https://www.afenxi.com/57103.html Saas的4级成熟度模型：https://www.jianshu.com/p/a401f951d560","categories":[],"tags":[{"name":"云服务","slug":"云服务","permalink":"https://pinksmallfan.github.io/WenChongAndJiaoKou/tags/云服务/"}]},{"title":"Zabbix部署细节","slug":"Zabbix部署细节","date":"2018-10-16T15:06:27.000Z","updated":"2018-10-16T15:10:09.882Z","comments":true,"path":"2018/10/16/Zabbix部署细节/","link":"","permalink":"https://pinksmallfan.github.io/WenChongAndJiaoKou/2018/10/16/Zabbix部署细节/","excerpt":"","text":"完成时间部署时间：2018年10月21日 未完待续… 附录 zabbix安装和配置：http://blog.51cto.com/13736286/2150741 CentOS7下的部署：https://www.cnblogs.com/Sungeek/p/9069999.html","categories":[],"tags":[{"name":"配置","slug":"配置","permalink":"https://pinksmallfan.github.io/WenChongAndJiaoKou/tags/配置/"},{"name":"自动化","slug":"自动化","permalink":"https://pinksmallfan.github.io/WenChongAndJiaoKou/tags/自动化/"}]},{"title":"R语言的基本使用","slug":"R_learn","date":"2018-10-16T11:43:39.000Z","updated":"2018-11-04T02:02:53.242Z","comments":true,"path":"2018/10/16/R_learn/","link":"","permalink":"https://pinksmallfan.github.io/WenChongAndJiaoKou/2018/10/16/R_learn/","excerpt":"","text":"读取数据操作路径1234567setwd('path') # 设置当前路径getwd() # 查看当前目录# 举例：# macsetwd('/Users/zoeZhang/R')# windowssetwd('C:/Users/zoeZhang/Destop/R') 加载与操作工具包12345678910library(survival) # 加载survival工具包biocLite('package') # 安装package工具包install.packages('package') # 安装package工具包remove.packages('package') # 删除package工具包update.packages() # 更新所有工具包source('https://bioconductor.org/biocLite.R') # 根据URL的方式来下载对应的工具包packages(all.available=T) # 查看所有packagesearch() # 查看已经加载的 packagedetach(package:package1) # 移除不需要的package1包 数据类型转换123456data&lt;-as.character(number); # 将数字类型的数据，number转为字符串的datadata&lt;-as.numeric(string); # 将数字符串的数据，string转为数字类型的datadata&lt;-as.array(original); # 将original转为数组类型的datadata&lt;-as.data.frame(array); # 将矩阵类型的数据，original转为数据框类型的datadata&lt;-as.matrix(original); # 将original转为矩阵类型的datais.character(data); # 判断data是什么类型 加载数据1234#创建一个example变量，读取example.txt到example上example&lt;-read.table('example.txt',fill=TRUE,head=TRUE) head(example) # 显示example变量的前行数据os&lt;-example[,'survival'] # 将example变量的surival相关数据输出到os变量 生存分析关键函数12Surv(time,event) # time:时间发生的跟踪时间、event：预期事件的发生状态survfit(formula) # formula：预测变量之间的关系 举例1234567891011121314fit&lt;-survfit(Surv(time,event)~group,type='kaplan-meier')# 获取数据的统计摘要和性质summary(fit) #其中formula是Surv(time,event)~group,type='kaplan-meier'# 开始画图，画点，fit：生存分析的数值向量 lty：线条类型plot(fit,lty=1:3) # list(a,b)，存放两个元素的列表， c(a,b),创建一个有2个元素的向量，lty：线条类型# 添加图例，即坐标轴这些legend(list(x=0.2,y=0.2), c(\"Group1\", \"Group2\"), lty = 1:3) # 用于不同组的统计检验survdiff(Surv(os,event)~group,rho=0) 核苷酸芯片数据的分析关键函数(affy)123456789# 读取当前目录raw_data文件的细胞文件，将值赋予给affy.data对象# 当前目录可以通过getwd()和setwd('xxxx/x/xx/')来获取与设置affy.data = ReadAffy(celfile.path=\"raw_data\") # 查看芯片基本的数据信息show(affy.data)# 查看芯片的样品名sampleNames(affy.data)# 读取affy.data数据中的A.CEL/B.CEL/C.CEL/D.CEL数据，并赋值到affy.data.E上affy.data.E=affy.data[,c(\"A.CEL\", \"B.CEL\", \"C.CEL\", \"D.CEL\")] 关键函数（affyPLM）123456library(gcrma)library(preprocessCore)# 导入affyPLM需要导入以上两个包library(affyPLM)# Pset &lt;- fitPLM(affy.data.E) 参考网站 生存分析函数小结：https://blog.csdn.net/shmilyringpull/article/details/17529637","categories":[],"tags":[{"name":"R语言","slug":"R语言","permalink":"https://pinksmallfan.github.io/WenChongAndJiaoKou/tags/R语言/"}]},{"title":"删除github的历史记录","slug":"deleteGitHubHistory","date":"2018-10-15T18:07:14.000Z","updated":"2018-10-15T18:29:12.907Z","comments":true,"path":"2018/10/16/deleteGitHubHistory/","link":"","permalink":"https://pinksmallfan.github.io/WenChongAndJiaoKou/2018/10/16/deleteGitHubHistory/","excerpt":"","text":"准备 打开git 仓库地址，[URL], 例：https://github.com/githubUsername/repositories 一个存放临时git仓库的本地地址，例：C:/tmp 更新本地先将本地的代码提交（这里我已hexo项目为例） 12hexo cleanhexo d -g 克隆、进入仓库123456789cd C:/tmp #进入一个本地地址git clone https://github.com/githubUsername/repositories #克隆git仓库到本地某一个位置cd ./repositories #进入仓库,repositories即你实际的仓库名git checkout --orphan new_branch #创建一个new_branch的空分支git add -A #添加所有文件到这个new_branch空分支git commit -am 'commit' #commit，即提交的备注信息git branch -D master #先将主干分支删了git branch -m master #将当前所在分支（new_branch）重命名为mastergit push origin master --force #强行推送到github仓库，完成删除提交的历史记录","categories":[],"tags":[{"name":"配置","slug":"配置","permalink":"https://pinksmallfan.github.io/WenChongAndJiaoKou/tags/配置/"}]},{"title":"给VPS加固安全设置","slug":"VPS设置安全加固","date":"2018-10-13T17:02:15.000Z","updated":"2018-10-21T12:41:30.537Z","comments":true,"path":"2018/10/14/VPS设置安全加固/","link":"","permalink":"https://pinksmallfan.github.io/WenChongAndJiaoKou/2018/10/14/VPS设置安全加固/","excerpt":"","text":"参数 系统：CentOS 7 运行内存：500M 内存：500G 默认端口 修改默认的端口 账户安全管理修改密码长度12vi /etc/login.defs#PASS_MIN_LEN 18 修改加密密码算法12vi /etc/login.defs#ENCRYPT_METHOD SHA512 denyhosts减缓暴力试错错误12345678yum install epel-release # 安装Epel存储库来安装denyhosts软件包yum install denyhosts vi /etc/denyhosts.conf# 参考修改如下：# DENY_THRESHOLD_INVALID = 5# DENY_THRESHOLD_VALID = 10# DENY_THRESHOLD_ROOT = 10# DENY_THRESHOLD_RESTRICTED = 1 创建普通用户账户12useradd pinksmallfanpasswd pinksmallfan 禁用不用的账号123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354who /var/log/wtmp #查看用户登录的状态vi /etc/passwd #查看账号vi /etc/group #查看系统的用户组# /etc/passwd # /sbin/nologin的用户就不要删啦！不然会重启会导致进不去登录页面，以下#的执行# userdel bin # userdel daemonuserdel admuserdel lpuserdel syncuserdel shutdownuserdel operatoruserdel ftp# userdel mail# userdel nobody# userdel systemd-bus-proxy# userdel system-network# userdel dbususerdel tssuserdel sshd# userdel postix# userdel chrony# /etc/groupgroupdel admgroupdel lpgroupdel newsgroupdel uucp# groupdel sys# groupdel tty# groupdel disk# groupdel mem# groupdel kmem# groupdel wheel# groupdel cdrom# # groupdel mail# groupdel man# groupdel dialout# groupdel floppygroupdel games# groupdel tape# groupdel video# groupdel lock# groupdel audio# groupdel users# groupdel utmp# groupdel utempter# groupdel input# groupdel systemd-journal# groupdel ssh_keysgroupdel dip# groupdel postdropgroupdel pppusers 禁用非授权用户获得权限1234chattr +i /etc/passwdchattr +i /etc/shadowchattr +i /etc/groupchattr +i /etc/gshadow ps: 如果想要创建用户or修改密码，就用chattr -i命令来恢复 禁用ctrl+alt+delete命令12vi /etc/inittab# ca::ctrlaltdel:/sbin/shutdown -t3 -r now # 注释 设置/etc/profile123echo \"TIMEOUT=3600\" &gt;&gt;/etc/profilesed -i \"s/HISTSIZE=1000/HISTSIZE=10/\" /etc/profilesource /etc/profile 设置/etc/rcd/init.d/文件的许可权限1chmod -R 700 /etc/rcd/init.d/* ssh 安全配置1234567yum install sshcp /etc/ssh/sshd_config /etc/ssh/sshd_config.bakvi /etc/ssh/sshd_config# Port 22 # 修改默认参考# PermitRootLogin no# PermitEmptyPasswords no# UseDns no 防止攻击防止ping12345# 临时改防止pingecho 1 &gt;/proc/sys/net/ipv4/icmp_echo_ignore_all# 永久改防止pingvi /etc/rc.d/rc.local # echo 1 /proc/sys/net/ipv4/icmp_echo_ignore_all #添加 防止IP欺骗攻击1234vi /etc/host.conf# order bind, hosts# multi off# nospoof on 防止Dos攻击1234567vi /etc/security/limits.conf# hard core 0 #禁止文件的调试# hard rss 5000 #限制内存的使用，设定值为5MB# hard nproc 20 #限制进程为20vi /etc/pam.d/login# session required /lib64/security/pam_limits.so #添加，如果是32位系统用lib（不然可能会出现重启登录不上的问题，显示module is unknown，可以采用救援模式来修改回来，后面章节会讲）！64位用lib64 系统配置+性能调优使用ntp服务更新服务器时间12345yum -y install ntpntpdate ntp.aliyun.comcrontab -e# * */12 * * * ntpdate tp.aliyun.com #将会根据vps所在地址更新时间源，比如上海17点，vps在美国，显示的是05点cp /usr/share/zoneinfo/Asia/Shanghai/etc/localtime # 设置上海时间 删除系统相关信息12echo \"helloworld!\" &gt;/etc/issueecho \"helloworld!\" &gt;/etc/redhat-release 系统备份与应急处理设置系统镜像123456# 备份镜像tar cvpzf back_up.tgz --exclude=/proc --exclude=/lost+found --exclude=/mnt --exclude=/sys --exclude=back_up.tgz /# 将proc、lost+found、mnt、sys、back_up.tgz自身都排除掉，不列入备份的一部分#还原镜像tar xvpzf back_up.tgz -C / rescue mode进入原系统123456789101112131415# rescue mode（救援模式）# 进入系统后，查看原系统的挂载路径# 会出现一个大的，和一个小的boot，其中通常小的boot即救援模式的linux# 比如，我的vps下，进入救援模式，会有两个设备，/dev/vda和/dev/vdb，与对应boot的/dev/vda1和/dev/vdb1,另外也可以通过df -h查看当前的挂载情况fdisk -l# 创建两个路径用来挂载mkdir /mnt/linuxmkdir /mnt/linux/boot# 将设备vdb挂载在linux下，boot的vdb1挂载在linux/boot下mount /dev/vdb/ /mnt/linux/mount /dev/vdb1/ /mnt/linux/bootchroot /mnt/linux/boot# /mnt/linux/root/目录下就是对应原系统的/ls -l /mnt/linux/boot/ 参考资料 https://blog.csdn.net/shentianzhi2009/article/details/40340941 解决Module is notknow https://blog.csdn.net/lzx_bupt/article/details/6792335 镜像备份：https://www.jianshu.com/p/69ce20effe7d?utm_campaign=maleskine&amp;utm_content=note&amp;utm_medium=seo_notes&amp;utm_source=recommendation","categories":[],"tags":[{"name":"other","slug":"other","permalink":"https://pinksmallfan.github.io/WenChongAndJiaoKou/tags/other/"},{"name":"配置","slug":"配置","permalink":"https://pinksmallfan.github.io/WenChongAndJiaoKou/tags/配置/"}]},{"title":"mvn的使用","slug":"mvn的使用","date":"2018-10-12T07:07:08.000Z","updated":"2018-10-16T16:55:29.589Z","comments":true,"path":"2018/10/12/mvn的使用/","link":"","permalink":"https://pinksmallfan.github.io/WenChongAndJiaoKou/2018/10/12/mvn的使用/","excerpt":"","text":"mvn 打包本地打包jar测试，跳过test1mvn clean install package -Dmaven.test.skip=true # mvn打包跳过test例程。 测试+test12#在含有pom的目录上输入mvn pacakge，既可以打包，其中包括Test例程（JUnit会运行进行测试）mvn package 打包到nexusmvn命令打包​ 设置 ​ DgroupId Group ​ DartifactId Artifact ​ Dversion 版本信息 ​ Dpackaging 发布类型 ​ Dfile 本地文件路径 ​ Durl 发布url ​ DrepositoryId 仓库id （可以参考setting里边的server节点的id） ​ 运行下命令就OK ​ mvn deploy:deploy-file -DgroupId=net.netca.xxx -DartifactId=NetcaXXX -Dversion=1.0.3 -Dpackaging=jar -Dfile=C:/tmp/jar/NetcaXXX-1.0.3.jar -Durl=http://192.168.XX.XX:XX/nexus/content/repositories/thirdparty/ -DrepositoryId=nexus-thirdparty nexus界面打包1. Sonatype侧边栏：Views/Respositories-Responsitories 2. 页面栏：Respositories-3rd party 3. 功能栏：3rd party-Artifact Upload 4. 操作： ​ 1. Select GAV Definition Source：选择From POM ​ 2. Select POM to Upload(button)：选择本地项目需要打包成jar，依赖的pom文件 ​ 3. Select Artifact(s) for Upload(button)：选择本地项目打包好的jar包 ​ 4. Add Artifact：将jar包进行添加到上传列表 ​ 5. Upload Aritifact(s)：上传jar包 常见错误jar依赖冲突​ 当引用第三方服务的时候，第三方服务的A.jar引用放置在了jdk的jre-lib-ext下，但是项目为maven项目，maven项目同时也包含了有A.jar。 解决方案： 1. 换一个没有A.jar的jdk，通过maven来引用A.jar。 2. 如果jdk不能替换，那么可以尝试maven的exclusions，去除自带的引用。 举例如下： 1234567891011&lt;dependency&gt; &lt;groupId&gt;org.apache.axis2&lt;/groupId&gt; &lt;artifactId&gt;axis2-kernel&lt;/artifactId&gt; &lt;version&gt;1.7.6&lt;/version&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt; Unauthorized1. 描述：当你想上传jar包到仓库nexus-thirdparty时，却发现，通过mvn命令行的方式上传失败，出现&quot;Unauthorized&quot;（没有权限）的错误。 2. 原因：本地setting配置文件（一般是C:\\Users\\用户名\\\\.m2\\settings.xml），没有配置好对应server id为nexus-thirdparty的账号密码 3. 解决方案：在setting.xml文件添加server节点 12345&lt;server&gt; &lt;id&gt;nexus-thirdparty&lt;/id&gt; &lt;username&gt;username&lt;/username&gt; &lt;password&gt;password&lt;/password&gt;&lt;/server&gt; pom.xml详解","categories":[],"tags":[{"name":"配置","slug":"配置","permalink":"https://pinksmallfan.github.io/WenChongAndJiaoKou/tags/配置/"},{"name":"mvn","slug":"mvn","permalink":"https://pinksmallfan.github.io/WenChongAndJiaoKou/tags/mvn/"}]},{"title":"idea使用技巧大放送","slug":"idea-use-tips","date":"2018-10-11T15:00:00.000Z","updated":"2018-11-15T16:08:56.791Z","comments":true,"path":"2018/10/11/idea-use-tips/","link":"","permalink":"https://pinksmallfan.github.io/WenChongAndJiaoKou/2018/10/11/idea-use-tips/","excerpt":"","text":"将普通的项目转为maven项目 解决步骤： 项目（右键）- Add Framework Support - 弹框勾选maven - OK 配置pom","categories":[],"tags":[{"name":"idea","slug":"idea","permalink":"https://pinksmallfan.github.io/WenChongAndJiaoKou/tags/idea/"},{"name":"工具","slug":"工具","permalink":"https://pinksmallfan.github.io/WenChongAndJiaoKou/tags/工具/"}]},{"title":"高并发测试","slug":"highConcurrencyTest","date":"2018-10-11T13:36:24.000Z","updated":"2018-10-18T14:47:09.821Z","comments":true,"path":"2018/10/11/highConcurrencyTest/","link":"","permalink":"https://pinksmallfan.github.io/WenChongAndJiaoKou/2018/10/11/highConcurrencyTest/","excerpt":"","text":"高并发代码123456789101112131415161718192021222324252627282930@Test public void testConcurrency() throws Exception&#123; final int threadSize = 100; final CountDownLatch countDownLatch = new CountDownLatch(1); // 创建一个刚好有100个线程槽的线程池 final ExecutorService executorService = Executors.newFixedThreadPool(threadSize); for(int i = 0;i&lt;threadSize; i++)&#123; final int number = i+1; Runnable runnable = new Runnable() &#123; public void run() &#123; try &#123; countDownLatch.await(); // TODO 需要进行并发测试的函数 &#125; catch (Exception e)&#123; e.printStackTrace(); &#125; &#125; &#125;; // 线程池的申请线程 executorService.submit(runnable); &#125; System.out.println(\"Start!!\"); // 开始执行并发测试 countDownLatch.countDown(); // 等待之前申请线程的时间 executorService.awaitTermination(1000,TimeUnit.MILLISECONDS); &#125; ### 任务 通过IDEA构建一个spring-boot的maven项目 连接mysql数据库，能够进行简单的增删改查，搭建为一个模板项目[Spring-boot_mysql] 进行高并发sql的查询测试 添加mybatis模块 nexus私服搭建 添加redis模块 添加zookeeper模块 添加dubbo模块 添加webSocket模块 添加netty模块-&gt;与tomcat切入（对比） 未完待续 idea 项目搭建、部署的流程步骤 技术原理的执行步骤 业务的流程步骤 ​","categories":[],"tags":[{"name":"测试","slug":"测试","permalink":"https://pinksmallfan.github.io/WenChongAndJiaoKou/tags/测试/"},{"name":"高并发","slug":"高并发","permalink":"https://pinksmallfan.github.io/WenChongAndJiaoKou/tags/高并发/"},{"name":"代码","slug":"代码","permalink":"https://pinksmallfan.github.io/WenChongAndJiaoKou/tags/代码/"}]},{"title":"故事化应用","slug":"tellAYarn","date":"2018-10-10T15:39:29.000Z","updated":"2018-10-10T16:41:02.728Z","comments":true,"path":"2018/10/10/tellAYarn/","link":"","permalink":"https://pinksmallfan.github.io/WenChongAndJiaoKou/2018/10/10/tellAYarn/","excerpt":"","text":"简介 创建一个笔记，收集灵感，收集有用的学习知识点 共同点：这些博客内容都有一个点，故事化 通过故事来讲明白一个技术点，需要对技术深刻的了解、具有很强的表达能力 需要多读多看，多反复多琢磨，寻找与形成属于自己语言的表达方式 重点：扩展自己表达方面的思维能力，做一个会讲故事的专业人员 格言：日积月累就是超越，一点一滴就是实力的见证。 RESTful故事化： https://blog.csdn.net/hzy38324/article/details/78360525 阮一峰：http://www.ruanyifeng.com/blog/2018/10/restful-api-best-practices.html 持续更新中…","categories":[],"tags":[{"name":"other","slug":"other","permalink":"https://pinksmallfan.github.io/WenChongAndJiaoKou/tags/other/"},{"name":"知识框架","slug":"知识框架","permalink":"https://pinksmallfan.github.io/WenChongAndJiaoKou/tags/知识框架/"}]},{"title":"Spring boot","slug":"Spring-boot","date":"2018-10-10T13:54:55.000Z","updated":"2018-10-18T16:53:19.249Z","comments":true,"path":"2018/10/10/Spring-boot/","link":"","permalink":"https://pinksmallfan.github.io/WenChongAndJiaoKou/2018/10/10/Spring-boot/","excerpt":"","text":"简介 创建一个笔记，收集灵感，收集有用的学习知识点 方便以后开始学习一样技术的时候，能够快速定位 写下学习计划，制定学习方向、模板，做好二次学习的准备 需要记录技术点的详细的官网地址，知识点参考的网址 定位：这里的文章大多不是原创，以收集资料为主 重点：扩展自己的知识面 要求：标题、简单的概括、简单的示例（可选）、应用场景（可选） 格言：日积月累就是超越，一点一滴就是实力的见证。 Spring boot亮点 简单 变简单 自动配置 简化依赖 概述 采用了Spring boot，能够解决什么问题呢？ Spring boot能够使编码变精简、配置变简单、部署变快捷、监控变容易 Spring boot默认快速启动一个web容器，不需要外置web容器，将注意力集中在编码上，而不是配置容器等方面上。 Spring boot是Spring框架扬长避短的杰作，简化了spring冗余的配置，从xml配置到java Config配置，从setBean的方式配置到自动注解，从多个properties+xml到只要一个yml就完成了配置。 Spring boot 默认配置；额很多框架的使用方式，整合了所有框架 Spring boot能够对主流开发的框架，进行无配置集成，提高了开发、部署的效率，不用再花额外的时间，研究不同框架的整合与集成上 Spring boot支持的配置文件application.yml，减少了传统的properties的链式麻烦 Spring boot提供了热部署，实时刷新后台服务，能将服务改动后的效果，呈现出来 Spring boot一键启动，只需要一个jar、war，甚至一段代码就可以了，不需要预部署应用服务器 configprops：属性配置、dump：线程工作状态、env/name：环境变量、metrics/name：JVM性能指标、mapping：RESTful path与服务类的映射关系 Spring boot有什么不足？ 缺少服务注册、发现等外围方案、配套功能 缺少外围监控集成方案，自身的acturator所提供的监控功能，还没有集成与现有的监控对接 缺少外围安全管理方案、缺少REST落地的URI规划方案 内置tomcat和Jetty容器 比较适合做微服务，而不太适合做比较大型的项目。 Spring boot 相关技术（以下关键词都可以另外写一章进行记录） Mock 测试，用来模拟不容易构造、比较复杂的对象，方便并行的开发工作，可以用来极速演示、隔离系统（避免数据库污染）、模拟驱动开发、无法访问的资源、提高测试的覆盖率 Docker 装满需要应用程序的容器，让更多的应用只需要在同一个硬件运行，即连即用，让开发人员易于快速构建可随时运行的容器化应用程序，大大简化了管理和部署应用程序的任务。 RESTful API 设计规范，用于 Web 数据接口的设计。让客户端发出的数据操作指令都是”动词 + 宾语”的结构 MicroService 部署流程关键点附录 Spring Boot 浅谈：https://blog.csdn.net/fly_zhyu/article/details/76407830 自动配置：https://www.jianshu.com/p/3d788198efab 极简的Spring boot：https://www.jianshu.com/p/1936a23d6a56 未完待续…","categories":[],"tags":[{"name":"Spring-boot","slug":"Spring-boot","permalink":"https://pinksmallfan.github.io/WenChongAndJiaoKou/tags/Spring-boot/"},{"name":"知识框架","slug":"知识框架","permalink":"https://pinksmallfan.github.io/WenChongAndJiaoKou/tags/知识框架/"}]},{"title":"日积月累就是超越，一点一滴就是实力的见证","slug":"inspiration","date":"2018-10-09T15:08:42.000Z","updated":"2018-10-16T15:55:05.877Z","comments":true,"path":"2018/10/09/inspiration/","link":"","permalink":"https://pinksmallfan.github.io/WenChongAndJiaoKou/2018/10/09/inspiration/","excerpt":"","text":"简介 创建一个笔记，收集灵感，收集有用的学习知识点 方便以后开始学习一样技术的时候，能够快速定位 写下学习计划，制定学习方向、模板，做好二次学习的准备 需要记录技术点的详细的官网地址，知识点参考的网址 定位：这里的文章大多不是原创，以收集资料为主 重点：扩展自己的知识面 要求：标题、简单的概括、简单的示例（可选）、应用场景（可选） 格言：日积月累就是超越，一点一滴就是实力的见证。 pythonunitest是什么​ 单元测试框架 简单的测试用例12345678910111213141516171819202122232425262728293031import unittestclass MyTest(unittest.TestCase): # 继承unittest.TestCase # 每个测试用例执行之后做操作 def tearDown(self): print('111') # 每个测试用例执行之前做操作 def setUp(self): print('22222') # 必须使用 @ classmethod装饰器, 所有test运行完后运行一次 @classmethod def tearDownClass(self): print('4444444') # 必须使用@classmethod 装饰器,所有test运行前运行一次 @classmethod def setUpClass(self): print('33333') # 测试用例 def test_a_run(self): self.assertEqual(1, 1) # 测试用例 def test_b_run(self): self.assertEqual(2, 2) #运行所有的测试用例 if __name__ == '__main__': unittest.main() 常用断言12345678assertEqual(a, b) # a == b assertNotEqual(a, b) # a != b assertTrue(x) # bool(x) is True assertFalse(x) # bool(x) is False assertIsNone(x) # x is None assertIsNotNone(x) # x is not None assertIn(a, b) # a in b assertNotIn(a, b) # a not in b HTMLTestRunner介绍：测试报告，引用模板 12345678910111213if __name__ == '__main__': #创建一个测试集合 test_suite = unittest.TestSuite() #测试套件中添加测试用例 test_suite.addTest(MyTest('test_run1')) #使用makeSuite方法添加所有的测试方法 #test_suite.addTest(unittest.makeSuite(MyTest)) #打开一个保存结果的html文件 fp = open('res.html','wb') #生成执行用例的对象 runner = HTMLTestRunner.HTMLTestRunner(stream=fp,title='api测试报告',description='测试情况') #执行测试套件 runner.run(test_suite) xmlrunner介绍：jenkins识别的测试报告，引用模板 123456if __name__=='__main__': test_suite = unittest.TestSuite() test_suite.addTest(unittest.makeSuite(My)) #指定报告放的目录 runner = xmlrunner.XMLTestRunner(output='report') runner.run(test_suite) testsuite介绍：组织测试模块 12345678if __name__=='__main__': #创建模块管理 test_suite=unittest.TestSuite() test_suite.addTest(Test1('Test1')) test_suite.addTest(Test2('Test2')) #使用run()方法运行测试套件 runner=unittest.TextTestRunner() runner.run(test_suite) 官网https://docs.python.org/2/library/unittest.html xrld、xlwt是什么​ python的excel操作 12345678910111213141516171819202122import xlrd#打开excel表excel=xlrd.open_workbook(u\"excel.xlsx\")#获取sheet表格（索引、顺序、表名）sheet=excel.sheets()[0]sheet=excel.sheet_by_index(0)sheet=excel.sheet_by_name(u\"Sheet1\")#获取行数rowsCount=sheet.nrows#获取列数columnsCount=sheet.ncols#获取行内容rowsContent=sheet.row_values(0)#获取列内容rowsContent=sheet.col_values(0)#返回单元格对象table.cell(rowx,colx)#返回单元格中的数据类型table.cell_type(rowx,colx)#返回单元格中的数据table.cell_value(rowx,colx) 官网https://xlrd.readthedocs.io/en/latest/api.html ConfigParser介绍​ 读取写入配置文件 12345[my_config]host=192.168.88.107user=root[com_config]host=10.119.10.13 config.ini配置文件如上 基本使用12345678910111213141516import ConfigParserimport osconfig=ConfigParser()config.read('/usr/local/config.ini')# 打印所有节点标题print config.sections() # ['my_config','com_config']# 删除指定节点config.remove_sections('my_config') # True# 打印所有键值对print config.items('my_config') # [('host','192.168.88.107'),('user','root')]# 添加新的节点config.add_section('new_config')# 写入指定的节点，添加键值对config.set('new_config','host','192.168.88.102')# 写入实际的配置文件config.write(open('/usr/local/config.ini','w')) 官网https://docs.python.org/2/library/configparser.html Jenkins是什么 能够驱动其他软件一起工作，可以持续、自动地构建的一个集成工具 能够执行定时的任务，并进行监控，跟踪版本的发布，生成对应的日志 能够进行持续集成、交付、部署，能够配置RSS或者邮件等进行通知发送 能够构建测试软件，生成对应的测试报告 使用流程 版本控制、集成工具、运行环境的安装 ​ 插件：git、maven、svn、jdk、tomcat yum安装jenkins，安装目录、配置文件、日志目录， ​ 形式有三种：yum、war包、docker安装 jenkins部署（部署在tomcat上等web容器） 在web主页，配置maven、GIT、jdk、svn 邮件配置、ssh配置、插件安装 项目构建 官网​ https://jenkins.io/ smtplib是什么​ SMTP协议，即发送邮件的协议；python支持通过smtplib模块进行邮件发送。 ​ 它工作的方式是：通过与src地址到dir地址传送邮件的规则，通过smtplib来控制邮件的中转方式。 ​ 并且支持：纯文本、带附件、html格式的邮件发送 ​ 官网​ https://docs.python.org/2/library/smtplib.html Selenium是什么​ Selenium是一系列基于Web的自动化工具，提供一套测试函数，用于支持Web自动化测试。 参考网址 自动化测试：https://blog.csdn.net/huilan_same/article/details/52559711 unitest： https://www.cnblogs.com/feng0815/p/8045850.html unitest： https://www.jianshu.com/p/a5550835f361 xrld： https://www.cnblogs.com/insane-Mr-Li/p/9092619.html ConfigParser： https://www.cnblogs.com/snifferhu/p/4368904.html ConfigParser：https://blog.csdn.net/miner_k/article/details/77857292 Jenkins：https://www.jianshu.com/p/6aa1c9b9ae01 jenkins详细部署：https://blog.csdn.net/qq_26848099/article/details/78901240 smtplib：https://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000/001386832745198026a685614e7462fb57dbf733cc9f3ad000 smtplib：http://www.runoob.com/python/python-email.html Selenium：https://blog.csdn.net/wanglian2017/article/details/72843984 PlusUltra","categories":[],"tags":[{"name":"python","slug":"python","permalink":"https://pinksmallfan.github.io/WenChongAndJiaoKou/tags/python/"},{"name":"知识框架","slug":"知识框架","permalink":"https://pinksmallfan.github.io/WenChongAndJiaoKou/tags/知识框架/"}]},{"title":"外币银行卡的区别","slug":"BankCard","date":"2018-10-08T17:10:00.000Z","updated":"2018-10-09T15:35:35.782Z","comments":true,"path":"2018/10/09/BankCard/","link":"","permalink":"https://pinksmallfan.github.io/WenChongAndJiaoKou/2018/10/09/BankCard/","excerpt":"","text":"信用卡，国际有六大信用卡公司： 美国：VISA（威士国际）、MasterCard（万事达卡国际）、AE blue（美国运通国际）、Diners Club（大来） 中国：UnionPay（银联） 日本：JCB 区别： Visa：第一大卡，在亚洲和澳大利亚的受理商户比较多 MasterCard：第二大卡，在欧洲和北美较多","categories":[],"tags":[{"name":"other","slug":"other","permalink":"https://pinksmallfan.github.io/WenChongAndJiaoKou/tags/other/"}]}]}