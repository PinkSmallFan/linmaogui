{"title":"实践路线（微服务预习）","date":"2018-11-15T16:08:08.000Z","slug":"微服务预习","tags":["计划"],"categories":["微服务"],"updated":"2018-11-15T16:11:31.038Z","content":"<h2 id=\"实践路线（github）\"><a href=\"#实践路线（github）\" class=\"headerlink\" title=\"实践路线（github）\"></a>实践路线（github）</h2><p>github管理项目，呈现一个项目学习路线的面貌。打造个人品牌</p>\n<ul>\n<li><p>[x] 【宿舍】使用SpringBoot快速构建RESTful API应用</p>\n</li>\n<li><p>[ ] 【公司】业务平台Spring改为SpringBoot项目</p>\n</li>\n<li><p>[ ] 【公司】SpringBoot的单元测试</p>\n</li>\n<li><p>[x] 【宿舍】SpringBoot的热部署等配置</p>\n</li>\n<li><p>[ ] 【宿舍】SpringCloud的初体验</p>\n</li>\n<li><p>[ ] 【公司】建立activeMQ，并与redis做结合</p>\n</li>\n<li><p>[ ] 【公司】将SpringBoot项目拆分为微服务</p>\n</li>\n<li><p>[ ] 【宿舍】实现将微服务注册到EurkaServer上</p>\n</li>\n<li><p>[ ] 【宿舍】SpringBoot容错处理搭建Hystrix</p>\n</li>\n<li><p>[ ] 【宿舍】使用Ribbin实现客户端负载均衡</p>\n</li>\n<li><p>[ ] 【宿舍】实现Hystrix Dashboard可视化监控数据</p>\n</li>\n<li><p>[ ] 【公司】Elasticsearch日志存储系统搭建</p>\n</li>\n<li><p>[ ] 【公司】Logstash日志收集系统搭建</p>\n</li>\n<li><p>[ ] 【公司】Kiaabna日志查询系统搭建</p>\n</li>\n<li><p>[ ] 【宿舍】ELK日志中心搭建</p>\n</li>\n<li><p>[ ] 【宿舍】自主搭建系统监控中心</p>\n</li>\n<li><p>[ ] 【宿舍】Dubbo的初体验</p>\n</li>\n<li><p>[ ] 【宿舍】jenkins的持续集成搭建</p>\n</li>\n<li><p>[ ] 【宿舍】Docker镜像下载与构建</p>\n</li>\n<li><p>[ ] 【宿舍】使用Docker Registry打造私有镜像仓库</p>\n</li>\n<li><p>[ ] 【宿舍】使用Spring Cloud Bus实现配置的自动刷新</p>\n</li>\n</ul>\n<h3 id=\"方式\"><a href=\"#方式\" class=\"headerlink\" title=\"方式\"></a>方式</h3><ol>\n<li>3天制实现以上功能的每一个点</li>\n<li>第一天，学习理论知识，并找如何搭建（前提：在公司也需要储备学习资源）</li>\n<li>第二天，实践为主，完成以上的搭建任务（前提：在公司查看其他人怎么实现）</li>\n<li>第三天，完善实践，标注学习日期，课本回顾（前提：完成实践内容）</li>\n</ol>\n<h2 id=\"传统单体架构及其面临的挑战\"><a href=\"#传统单体架构及其面临的挑战\" class=\"headerlink\" title=\"传统单体架构及其面临的挑战\"></a><strong>传统单体架构及其面临的挑战</strong></h2><h3 id=\"传统单体架构分析\"><a href=\"#传统单体架构分析\" class=\"headerlink\" title=\"传统单体架构分析\"></a>传统单体架构分析</h3><p>​    一个典型的单体应用就是将所有的业务场景的表示层、业务逻辑层和数据访问层放在一个工程中，最终经过编译、打包，部署在一台服务器上。例如典型的J2EE工程，它是将表示层的JSP、业务逻辑层的Service、Controller和数据访问层的Dao，打成war包，部署在Tomcat、Jetty或者其他Servlet容器中运行。</p>\n<p>​    在一个小型应用的初始阶段，访问量较小，应用只需要一台服务器就能够部署所有的资源，例如将应用程序、数据库、文件资源等部署在同一台服务器上。最典型的就是LAMP系统，即服务器采用Linux系统，开发应用程序的语言为PHP，部署在Apache服务器上，采用MySQL数据库。在应用程序的初始阶段，采用这种架构的性价比是非常高的，开发速度快，开发成本低，只需要一台廉价的服务器。</p>\n<h3 id=\"单体架构的优势\"><a href=\"#单体架构的优势\" class=\"headerlink\" title=\"单体架构的优势\"></a>单体架构的优势</h3><ol>\n<li>开发特别快</li>\n<li>开发初期，成本低，性价比高</li>\n<li>根据MVC等标准风格，功能层次拆分清楚 </li>\n<li>部署简单，直接一个war包就能解决</li>\n<li>技术单一，项目不需要复杂的技术栈，往往一套就可以开发完</li>\n</ol>\n<h3 id=\"单体架构局限性与面临的挑战\"><a href=\"#单体架构局限性与面临的挑战\" class=\"headerlink\" title=\"单体架构局限性与面临的挑战\"></a>单体架构局限性与面临的挑战</h3><ol>\n<li><p>复杂性</p>\n<p>​    整个项目包含的模块非常多，模块的边界模糊，依赖关系不清晰，代码质量参差不齐……整个项目非常复杂。每次修改代码都心惊胆战，甚至添加一个简单的功能，或者修改一个BUG都会造成隐含的缺陷。</p>\n</li>\n<li><p>开发效率</p>\n<p>​    单体式架构下的组织通常来说技术选型非常单一，团队技术能力相对单薄，团队的吸引力一般。</p>\n<p>​    整个系统一个团队。如果系统变得庞大，成员就需要学习大量的代码和领域知识，团队内的沟通和协作也变得低效。</p>\n</li>\n<li><p>稳定性</p>\n<p>​    某个功能模块出现bug，或者某个库出现问题，都可能导致整个进程宕机，影响整体的应用。</p>\n</li>\n<li><p>部署与运维成本</p>\n<p>​    传统的单体架构，一长串的本地接口或者方法调用，冗长而臃肿，往往是一个人负责整个的开发和维护。随着业务的发展和需求的变化，本地代码的不断迭代和变更，会导致只有原来的开发者才能理解接口的逻辑顺序，调用关系和功能需求，一旦开发者离职，那么功能模块运维就会非常困难。</p>\n<p>​    测试、部署成本高，系统中任何功能的改变，都需要整个系统重新测试并部署。</p>\n</li>\n<li><p>新功能交付</p>\n<p>​    直接本地API接口调用，不存在业务的拆分和相互调用，不需要依赖其他功能模块，这样子，开发只需要对自己开发的模块负责。这会导致代码重复率变高，功能变更或者新需求的加入会变得困难。</p>\n</li>\n<li><p>扩展能力</p>\n<p>​    单体应用作为一个强耦合的整体，无法根据业务功能伸缩。只能再整体的系统进行扩展，而无法针对某一个功能模块按照需求扩展，比如计算密集型服务，IO密集型服务。</p>\n<p>​    单体应用往往使用统一的技术平台或方案解决所有问题，团队的每个成员都必须使用相同的开发语言和架构，想要引入新的框架或技术平台非常困难。</p>\n</li>\n</ol>\n<h3 id=\"如何解决上述问题？\"><a href=\"#如何解决上述问题？\" class=\"headerlink\" title=\"如何解决上述问题？\"></a>如何解决上述问题？</h3><ol>\n<li><p>拆分</p>\n<p>​    将应用进行水平和垂直的拆分，可以按照功能、技术群进行拆分（例如：商品中心、订单中心、审计）。</p>\n</li>\n<li><p>解耦</p>\n<p>​    通过服务化和订阅、发布机制对应用调用关系解耦，支持服务的自动注册和发现</p>\n</li>\n<li><p>透明</p>\n<p>​    通过服务注册中心管理服务的发布和消费、调用关系</p>\n</li>\n<li><p>独立</p>\n<p>​    服务可以独立打包、发布、部署、启停、扩容和升级，核心服务独立集群部署</p>\n</li>\n<li><p>分层</p>\n<p>​    梳理和抽取核心应用、公共应用，作为独立的服务下沉到核心和公共能力层，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求</p>\n</li>\n</ol>\n<h3 id=\"结合某案例分析传统单体架构面临问题【案例】\"><a href=\"#结合某案例分析传统单体架构面临问题【案例】\" class=\"headerlink\" title=\"结合某案例分析传统单体架构面临问题【案例】\"></a>结合某案例分析传统单体架构面临问题【案例】</h3><h2 id=\"单体架构拆分\"><a href=\"#单体架构拆分\" class=\"headerlink\" title=\"单体架构拆分\"></a>单体架构拆分</h2><h3 id=\"服务水平拆分\"><a href=\"#服务水平拆分\" class=\"headerlink\" title=\"服务水平拆分\"></a>服务水平拆分</h3><p>​    按照数据的查询、存储、展示、采集的方向来进行拆分。</p>\n<ol>\n<li><p>数据模型能否彻底分开，决定了微服务的边界功能是否彻底划清。</p>\n</li>\n<li><p>实践过程中强烈推荐的原则是<strong>一个微服务对应一个库</strong></p>\n</li>\n<li><p>随着微服务规模壮大，可以针对性的做读写分离；如果单表数据庞大，可以分表来解决。</p>\n</li>\n</ol>\n<h3 id=\"服务水平拆分面临问题\"><a href=\"#服务水平拆分面临问题\" class=\"headerlink\" title=\"服务水平拆分面临问题\"></a>服务水平拆分面临问题</h3><ol>\n<li>对于无法修改的遗留系统，推荐采用绞杀者模式：在遗留系统外面增加新的功能做成微服务方式，而不是直接修改原有系统，逐步的实现对老系统替换</li>\n<li>规范整个系统而非微服务的日志体系，采用标准的日志格式非常便于后续的日志聚合检索，便于整体的视角分析、监控、查看系统；</li>\n<li>同时做两件不可控的事情（微服务改造、新技术的冲击）注定项目成功概率较低，千万避免自己重复发明轮子，尽量选择市面上成熟的开源技术框架进行支撑，比如Spring Boot、Spring Cloud、Netflix、WildFly Swarm、Docker、Kubernetes等框架；</li>\n</ol>\n<h3 id=\"服务垂直拆分\"><a href=\"#服务垂直拆分\" class=\"headerlink\" title=\"服务垂直拆分\"></a>服务垂直拆分</h3><p>​    按照展示层、应用层、领域层、基础设施层进行拆分。</p>\n<h3 id=\"服务拆分之后各模块间通信与交互\"><a href=\"#服务拆分之后各模块间通信与交互\" class=\"headerlink\" title=\"服务拆分之后各模块间通信与交互\"></a>服务拆分之后各模块间通信与交互</h3><h3 id=\"服务的设计原则\"><a href=\"#服务的设计原则\" class=\"headerlink\" title=\"服务的设计原则\"></a>服务的设计原则</h3><ol>\n<li><p>复用性</p>\n</li>\n<li><p>耦合性</p>\n</li>\n<li><p>服务编排</p>\n</li>\n<li><p>自治</p>\n</li>\n<li><p>无状态</p>\n</li>\n<li><p>自动发现</p>\n</li>\n</ol>\n<h3 id=\"服务拆分后面临挑战\"><a href=\"#服务拆分后面临挑战\" class=\"headerlink\" title=\"服务拆分后面临挑战\"></a>服务拆分后面临挑战</h3><ol>\n<li><p>调用性能</p>\n<p>​    在服务化之前，业务通常都是本地API调用，本地方法调用性能损耗较小。服务化之后，服务提供者和消费者之间采用远程网络通信，增加了额外的性能损耗。</p>\n</li>\n<li><p>线性扩展</p>\n<p>​    </p>\n</li>\n<li><p>服务监控</p>\n</li>\n<li><p>故障定位</p>\n<p>​    在分布式环境下，如何快速有效的进行故障问题定界定位</p>\n</li>\n<li><p>日志搜索</p>\n<p>​    在分布式环境下，如何方便的进行对服务调用日志做高效的检索</p>\n</li>\n<li><p>流控</p>\n<p>​    服务化、分布式部署之后，有逻辑关联关系的多个数据库操作被打散成各自独立的服务实例上去，引入分布式环境下的事务一致性问题</p>\n<ol>\n<li>客户端需求和每个微服务暴露的细粒度API不匹配</li>\n<li>微服务使用的RPC私有协议，不是浏览器友好或防火墙友好的</li>\n<li>微服务难以重构。随着时间推移，我们可能想要更改系统划分成服务的方式。如果客户端与微服务直接通信，那么执行这类重构就非常困难了</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"微服务架构综述\"><a href=\"#微服务架构综述\" class=\"headerlink\" title=\"微服务架构综述\"></a><strong>微服务架构综述</strong></h2><h3 id=\"什么是微服务？\"><a href=\"#什么是微服务？\" class=\"headerlink\" title=\"什么是微服务？\"></a>什么是微服务？</h3><p>​<br>​     简而言之，微服务架构风格的开发方法，是以开发一组小型服务的方式来开发一个独立的应用系统的。其中每个小型服务都运行在自己的进程中，并经常采用HTTP资源API轻量的机制来相互通信。</p>\n<p>​    这些服务围绕业务功能进行构建，并能通过全自动的部署机制来进行独立部署。这些微服务可以使用不同的语言来编写，并且可以使用不同的数据存储技术。对这些微服务我们仅做最低限度的集中管理。    </p>\n<p>​    每个微服务可独立运行在自己的进程里；</p>\n<p>​    一系列独立运行的微服务共同构建起整个系统；</p>\n<p>​    服务为独立的业务开发，一个微服务只关注某个特定的功能，如订单管理、用户管理等；</p>\n<p>​    微服务之间通过一些轻量的通信机制进行通信，如REST API进行调用；</p>\n<p>​    使用不同的语言与存储技术；</p>\n<p>​    全自动的部署机制；    </p>\n<h3 id=\"微服务架构\"><a href=\"#微服务架构\" class=\"headerlink\" title=\"微服务架构\"></a>微服务架构</h3><p>出处：<a href=\"https://www.jianshu.com/p/ae55e444c3a7\" target=\"_blank\" rel=\"noopener\">微服务架构</a></p>\n<div class=\"article-img\"><p><img src=\"E:\\blog\\lmg\\PinkSmallFan\\project\\source\\uploads\\9005929-6919de42324fe107.webp\" alt=\"img\"></p></div>\n<p>网关集群：数据的聚合、实现对接入客户端的身份认证、防报文重放与防数据篡改、功能调用的业务鉴权、响应数据的脱敏、流量与并发控制等</p>\n<p>业务集群：一般情况下移动端访问和浏览器访问的网关需要隔离，防止业务耦合</p>\n<p>Local Cache：由于客户端访问业务可能需要调用多个服务聚合，所以本地缓存有效的降低了服务调用的频次，同时也提示了访问速度。本地缓存一般使用自动过期方式，业务场景中允许有一定的数据延时。</p>\n<p>服务层：原子服务层，实现基础的增删改查功能，如果需要依赖其他服务需要在Service层主动调用</p>\n<p>Remote Cache：访问DB前置一层分布式缓存，减少DB交互次数，提升系统的TPS</p>\n<p>DAL：数据访问层，如果单表数据量过大则需要通过DAL层做数据的分库分表处理。</p>\n<p>MQ：消息队列用来解耦服务之间的依赖，异步调用可以通过MQ的方式来执行</p>\n<p>数据库主从：服务化过程中毕竟的阶段，用来提升系统的TPS</p>\n<h3 id=\"微服务架构优点\"><a href=\"#微服务架构优点\" class=\"headerlink\" title=\"微服务架构优点\"></a>微服务架构优点</h3><p>​    易于开发和维护。一个微服务只关注一个特定的业务功能，所以它的业务清晰、代码量较少。开发和维护单个微服务相对比较简单，整个应用是由若干个微服务构建而成，所以整个应用也会维持在可控状态；</p>\n<p>​    单个微服务启动较快。单个微服务代码量较少，所以启动会比较快；<br>​    修改容易部署。单体应用只要有修改，就要重新部署整个应用，微服务解决了这样的问题。一般来说，对某个微服务进行修改，只需要重新部署这个服务即可；</p>\n<p>​    技术栈不受限。在微服务中，我们可以结合项目业务及团队的特点，合理地选择技术栈；</p>\n<p><a href=\"https://www.jianshu.com/p/ae55e444c3a7\" target=\"_blank\" rel=\"noopener\">出处：微服务优势</a></p>\n<p><strong>1、降低复杂度</strong></p>\n<p>将原来偶合在一起的复杂业务拆分为单个服务，规避了原本复杂度无止境的积累。每一个微服务专注于单一功能，并通过定义良好的接口清晰表述服务边界。每个服务开发者只专注服务本身，通过使用缓存、DAL等各种技术手段来提升系统的性能，而对于消费方来说完全透明。</p>\n<p><strong>2、可独立部署</strong></p>\n<p>由于微服务具备独立的运行进程，所以每个微服务可以独立部署。当业务迭代时只需要发布相关服务的迭代即可，降低了测试的工作量同时也降低了服务发布的风险。</p>\n<p><strong>3、容错</strong></p>\n<p>在微服务架构下，当某一组件发生故障时，故障会被隔离在单个服务中。 通过限流、熔断等方式降低错误导致的危害，保障核心业务正常运行。</p>\n<p><strong>4、扩展</strong></p>\n<p>单块架构应用也可以实现横向扩展，就是将整个应用完整的复制到不同的节点。当应用的不同组件在扩展需求上存在差异时，微服务架构便体现出其灵活性，因为每个服务可以根据实际需求独立进行扩展。</p>\n<h3 id=\"微服务架构面临的挑战有哪些？\"><a href=\"#微服务架构面临的挑战有哪些？\" class=\"headerlink\" title=\"微服务架构面临的挑战有哪些？\"></a>微服务架构面临的挑战有哪些？</h3><p>​    <img src=\"E:\\blog\\lmg\\PinkSmallFan\\project\\source\\uploads\\24015312f806d3b5ff5b6d45711f5df1\" alt=\"img\"></p>\n<p>​    运维要求较高。更多的服务意味着更多的运维投入。在单体架构中只需要保证一个应用的正常运行；而在微服务中，需要保证几十甚至几百个服务的正常运行与协作，带来了巨大的挑战；</p>\n<p>​    分布式固有的复杂性。使用微服务构建的是分布式系统。对于一个分布式系统，系统容错、网络延迟、分布式事务等都带来了巨大的挑战；<br>​    成本高。微服务之间通过接口进行通信。如果修改某个微服务的API，可能所有使用了该接口的微服务都需要做调整；</p>\n<p>​    重复劳动。很多服务可能都会使用到相同的功能。而这个功能并没有达到分解为一个微服务的程度，这个时候，可能各个服务都会开发这一功能，导致代码重复。</p>\n<h3 id=\"微服务生命周期与交付流程\"><a href=\"#微服务生命周期与交付流程\" class=\"headerlink\" title=\"微服务生命周期与交付流程\"></a><strong>微服务生命周期与交付流程</strong></h3><div class=\"article-img\"><p><img src=\"E:\\blog\\lmg\\PinkSmallFan\\project\\source\\uploads\\7c1bd0d58a7a1a356b905110bff67cd9\" alt=\"img\"></p></div>\n<div class=\"article-img\"><p><img src=\"E:\\blog\\lmg\\PinkSmallFan\\project\\source\\uploads\\b5a87249002f4b0201f1f4ebf9ec71f1\" alt=\"img\"></p></div>\n<h3 id=\"微服务管理规范\"><a href=\"#微服务管理规范\" class=\"headerlink\" title=\"微服务管理规范\"></a>微服务管理规范</h3><p>​    微服务带来的依赖管理问题，我们可以通过平台提供的API管理能力来解决。说到API管理，那首先就用提到服务契约。平台开发工具中提供了方便的服务发布能力，能够快速的将业务功能对外发布，生成服务的规格契约，当然也可以先设计服务契约，在根据契约来生成服务的默认实现代码。</p>\n<p>​    这里强调一下，我们提到的服务契约是一个很重要的东西，他有点类似web service的wsdl描述，主要描述服务接口的输入输出规格标准和其他一些服务调用集成相关的规格内容。</p>\n<h3 id=\"微服务框架对比\"><a href=\"#微服务框架对比\" class=\"headerlink\" title=\"微服务框架对比\"></a><strong>微服务框架对比</strong></h3><p>Spring Cloud与Dubbo</p>\n<h4 id=\"性能对比\"><a href=\"#性能对比\" class=\"headerlink\" title=\"性能对比\"></a>性能对比</h4><p><a href=\"https://cloud.tencent.com/developer/article/1177574\" target=\"_blank\" rel=\"noopener\">图片出处</a></p>\n<div class=\"article-img\"><p><img src=\"E:\\blog\\lmg\\PinkSmallFan\\project\\source\\uploads\\6jmlhrz2to.jpeg\" alt=\"img\"></p></div>\n<p>​    Spring Cloud 抛弃了 Dubbo 的 RPC 通信，采用的是基于 HTTP 的 REST 方式。严格来说，这两种方式各有优劣。虽然从一定程度上来说，基于 HTTP 的 REST 方式牺牲了服务调用的性能，但也避免了上面提到的原生 RPC 带来的问题。而且 REST 相比 RPC 更为灵活，服务提供方和调用方的依赖只依靠一纸契约，不存在代码级别的强依赖，这在强调快速演化的微服务环境下，显得更加合适。</p>\n<h4 id=\"服务对比\"><a href=\"#服务对比\" class=\"headerlink\" title=\"服务对比\"></a>服务对比</h4><p><a href=\"https://cloud.tencent.com/developer/article/1177574\" target=\"_blank\" rel=\"noopener\">图片出处</a></p>\n<div class=\"article-img\"><p><img src=\"E:\\blog\\lmg\\PinkSmallFan\\project\\source\\uploads\\gy1tppfw1d.jpeg\" alt=\"img\"></p></div>\n<p><strong>Dubbo 专注 RPC 和服务治理，Spring Cloud 则是一个微服务架构生态</strong></p>\n<h4 id=\"组件对比\"><a href=\"#组件对比\" class=\"headerlink\" title=\"组件对比\"></a>组件对比</h4><p>出处：<a href=\"https://www.jianshu.com/p/ae55e444c3a7\" target=\"_blank\" rel=\"noopener\">组件对比</a></p>\n<p>Dubbo组件运行流程</p>\n<div class=\"article-img\"><p><img src=\"E:\\blog\\lmg\\PinkSmallFan\\project\\source\\uploads\\9005929-c7db3aef000f1927-1540943395067.webp\" alt=\"img\"></p></div>\n<p>gateWay:前置网关，具体业务操作，gateWay通过dubbo提供的负载均衡机制自动完成</p>\n<p>Service：原子服务，只提供该业务相关的原子服务</p>\n<p>Zookeeper：原子服务注册到zk上</p>\n<p>Spring Could组件运行流程</p>\n<div class=\"article-img\"><p><img src=\"E:\\blog\\lmg\\PinkSmallFan\\project\\source\\uploads\\9005929-5bf161de38a9a62d.webp\" alt=\"img\"></p></div>\n<p>所有请求都统一通过 API 网关（Zuul）来访问内部服务。</p>\n<p>网关接收到请求后，从注册中心（Eureka）获取可用服务。</p>\n<p>由 Ribbon 进行均衡负载后，分发到后端的具体实例。</p>\n<p>微服务之间通过 Feign 进行通信处理业务。</p>\n<h4 id=\"服务依赖方式\"><a href=\"#服务依赖方式\" class=\"headerlink\" title=\"服务依赖方式\"></a>服务依赖方式</h4><p>出处：<a href=\"https://www.jianshu.com/p/ae55e444c3a7\" target=\"_blank\" rel=\"noopener\">服务依赖方式</a></p>\n<p>Dubbo：</p>\n<p>​    因此需要为每个微服务定义了各自的interface接口，并通过持续集成发布到私有仓库中，调用方应用对微服务提供的抽象接口存在强依赖关系，开发、测试、集成环境都需要严格的管理版本依赖。</p>\n<p>通过maven的install &amp; deploy命令把interface和Model层发布到仓库中，服务调用方只需要依赖interface和model层即可。在开发调试阶段只发布Snapshot版本。等到服务调试完成再发布Release版本，通过版本号来区分每次迭代的版本。通过xml配置方式即可方面接入dubbo，对程序无入侵。</p>\n<div class=\"article-img\"><p><img src=\"E:\\blog\\lmg\\PinkSmallFan\\project\\source\\uploads\\9005929-e1cd60672c7a3c21.webp\" alt=\"img\"></p></div>\n<p>Spring Cloud：</p>\n<p>​    服务提供方和服务消费方通过json方式交互，因此只需要定义好相关json字段即可，消费方和提供方无接口依赖。通过注解方式来实现服务配置，对于程序有一定入侵。</p>\n<div class=\"article-img\"><p><img src=\"E:\\blog\\lmg\\PinkSmallFan\\project\\source\\uploads\\9005929-e798a5a86e2da786.webp\" alt=\"img\"></p></div>\n<p>对比：</p>\n<p>​    Dubbo服务依赖略重，需要有完善的版本管理机制，但是程序入侵少。而Spring Cloud通过Json交互，省略了版本管理的问题，但是具体字段含义需要统一管理，自身Rest API方式交互，为跨平台调用奠定了基础。</p>\n<h3 id=\"微服务架构及常用组件\"><a href=\"#微服务架构及常用组件\" class=\"headerlink\" title=\"微服务架构及常用组件\"></a><strong>微服务架构及常用组件</strong></h3><h2 id=\"微服务开发之Dubbo\"><a href=\"#微服务开发之Dubbo\" class=\"headerlink\" title=\"微服务开发之Dubbo\"></a><strong>微服务开发之Dubbo</strong></h2><h3 id=\"Dubbo介绍\"><a href=\"#Dubbo介绍\" class=\"headerlink\" title=\"Dubbo介绍\"></a>Dubbo介绍</h3><p>Dubbo 是一个分布式服务框架，是国内互联网公司开源做的比较不错的阿里开放的微服务化治理框架，致力于提供高性能和透明化的RPC远程服务调用方案，以及SOA服务治理方案。 其核心部分包含（官网）:</p>\n<ul>\n<li><p>远程通讯: 提供对多种基于长连接的NIO框架抽象封装，包括多种线程模型，序列化，以及“请求-响应”模式的信息交换方式；</p>\n</li>\n<li><p>集群容错: 提供基于接口方法的透明远程过程调用，包括多协议支持，以及软负载均衡，失败容错，地址路由，动态配置等集群支持；</p>\n</li>\n<li><p>自动发现: 基于注册中心目录服务，使服务消费方能动态的查找服务提供方，使地址透明，使服务提供方可以平滑增加或减少机器。</p>\n</li>\n</ul>\n<h3 id=\"为什么选择Dubbo\"><a href=\"#为什么选择Dubbo\" class=\"headerlink\" title=\"为什么选择Dubbo?\"></a>为什么选择Dubbo?</h3><ul>\n<li><p>Dubbo 支持 <strong>RPC 调用</strong>，服务之间的调用性能会很好。</p>\n</li>\n<li><p><strong>支持多种序列化协议</strong>，如 Hessian、HTTP、WebService。</p>\n</li>\n<li><p><strong>Dobbo Admin后台管理功能强大</strong>，提供了路由规则、动态配置、访问控制、权重调节、均衡负载等功能。</p>\n</li>\n<li><p>在国内影响力比较大，<strong>中文社区文档较为全面</strong>。</p>\n</li>\n<li><p>阿里最近<strong>重启维护</strong>。</p>\n</li>\n</ul>\n<h3 id=\"Dubbo架构剖析\"><a href=\"#Dubbo架构剖析\" class=\"headerlink\" title=\"Dubbo架构剖析\"></a><strong>Dubbo架构剖析</strong></h3><p>出处：<a href=\"https://cloud.tencent.com/developer/article/1177574\" target=\"_blank\" rel=\"noopener\">结构剖析</a></p>\n<p>Dubbo 核心部件（如下图）:</p>\n<p>Provider： 暴露服务的提供方，可以通过jar或者容器的方式启动服务</p>\n<p>Consumer：调用远程服务的服务消费方。</p>\n<p>Registry： 服务注册中心和发现中心。</p>\n<p>Monitor： 统计服务和调用次数，调用时间监控中心。（dubbo的控制台页面中可以显示，目前只有一个简单版本）</p>\n<p>Container：服务运行的容器。</p>\n<div class=\"article-img\"><p><img src=\"E:\\blog\\lmg\\PinkSmallFan\\project\\source\\uploads\\nxfywqs12h.jpeg\" alt=\"img\"></p></div>\n<p>流程详解：</p>\n<ul>\n<li>0 服务容器负责启动，加载，运行服务提供者（Standalone 容器）。</li>\n<li>1 服务提供者在启动时，向注册中心注册自己提供的服务（Zookeeper/Redis）。</li>\n<li>2 服务消费者在启动时，向注册中心订阅自己所需的服务。</li>\n<li>3 注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。</li>\n<li>4 服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。</li>\n<li>5 服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心（根据数据可以动态调整权重）。</li>\n</ul>\n<h3 id=\"Dubbo优缺点分析\"><a href=\"#Dubbo优缺点分析\" class=\"headerlink\" title=\"Dubbo优缺点分析\"></a><strong>Dubbo优缺点分析</strong></h3><p>出处：<a href=\"https://cloud.tencent.com/developer/article/1177574\" target=\"_blank\" rel=\"noopener\">Dubbo 优缺点分析</a></p>\n<ul>\n<li><p><strong>Registry 严重依赖第三方组件</strong>（zookeeper 或者 redis），当这些组件出现问题时，服务调用很快就会中断。</p>\n</li>\n<li><p>Dubbo 只支持 RPC 调用。使得服务提供方（抽象接口）与调用方在代码上产生了<strong>强依赖</strong>，服务提供者需要不断将包含抽象接口的 jar 包打包出来供消费者使用。一旦打包出现问题，就会导致服务调用出错，并且以后发布部署会成很大问题（太强的依赖关系）。</p>\n</li>\n<li><p>另外，以后要兼容 .NET Core 服务，<strong>Dubbo RPC 本身不支持跨语言</strong>（可以用跨语言 RPC 框架解决，比如 Thrift、gRPC（重复封装了），或者自己再包一层 REST 服务，提供跨平台的服务调用实现，但相对麻烦很多）</p>\n</li>\n<li><p>Dubbo <strong>只是实现了服务治理</strong>，其他微服务框架并未包含，如果需要使用，需要结合第三方框架实现（比如分布式配置用淘宝的 Diamond、服务跟踪用京东的 Hydra，但使用相对麻烦些），开发成本较高，且风险较大。</p>\n</li>\n<li><p>社区更新不及时（虽然最近在疯狂更新），但也难免阿里以后又不更新了，就尴尬了。</p>\n</li>\n<li><p>主要是国内公司使用，但阿里内部使用 HSF，相对于 Spring Cloud，企业应用会差一些。</p>\n</li>\n</ul>\n<h3 id=\"Dubbo调用地址与负载均衡\"><a href=\"#Dubbo调用地址与负载均衡\" class=\"headerlink\" title=\"Dubbo调用地址与负载均衡\"></a><strong>Dubbo调用地址与负载均衡</strong></h3><p>出处：<a href=\"https://blog.csdn.net/li_xiao_dai/article/details/80077181\" target=\"_blank\" rel=\"noopener\">Dubbo的URL参数</a></p>\n<div class=\"article-bounded\"><div class=\"article-table\"><table>\n<thead>\n<tr>\n<th>name</th>\n<th>desc</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>mock</td>\n<td>配置此method在客户端调用时是直接调用，还是强制使用mock，还是调用失败后使用mock</td>\n</tr>\n<tr>\n<td>mock</td>\n<td>配置此method在客户端调用时是直接调用，还是强制使用mock，还是调用失败后使用mock</td>\n</tr>\n<tr>\n<td>retries</td>\n<td>调用Provider失败后的重试其他Provider的次数</td>\n</tr>\n<tr>\n<td>forks</td>\n<td>并发调用时Provider的个数</td>\n</tr>\n<tr>\n<td>timeout</td>\n<td>调用的Provider的超时时间，毫秒</td>\n</tr>\n<tr>\n<td>merger</td>\n<td>MergeableClusterInvoker调用时，指定的merge方式或者merge方法</td>\n</tr>\n<tr>\n<td>reference.filter</td>\n<td>用于Consumer端控制、指定过滤器名称</td>\n</tr>\n<tr>\n<td>service.filter</td>\n<td>用于Provider端控制、指定过滤器名称</td>\n</tr>\n<tr>\n<td>accesslog</td>\n<td>用于控制AccessLogFilter是否加载进FilterChain中</td>\n</tr>\n<tr>\n<td>actives</td>\n<td>用于控制ActiveLimitFilter是否加载进FilterChain中</td>\n</tr>\n<tr>\n<td>cache</td>\n<td>用于控制CacheFilter是否加载进FilterChain中</td>\n</tr>\n<tr>\n<td>deprecated</td>\n<td>用于控制DeprecatedFilter是否加载进FilterChain中</td>\n</tr>\n<tr>\n<td>executes</td>\n<td>用于控制ExecuteLimitFilter是否加载进FilterChain中，以及指定信号量初始值单个Provider最大可并发数</td>\n</tr>\n<tr>\n<td>generic</td>\n<td>用于控制GenericImplFilter是否加载进FilterChain中</td>\n</tr>\n<tr>\n<td>token</td>\n<td>用于控制TokenFilter是否加载进FilterChain中</td>\n</tr>\n<tr>\n<td>tps</td>\n<td>用于控制TpsLimitFilter是否加载进FilterChain中</td>\n</tr>\n<tr>\n<td>validation</td>\n<td>用于控制ValidationFilter是否加载进FilterChain中</td>\n</tr>\n<tr>\n<td>invoker.listener</td>\n<td>用于控制invoker过程中的监听器名称</td>\n</tr>\n<tr>\n<td>exporter.listener</td>\n<td>用于控制export过程中的监听器名称</td>\n</tr>\n<tr>\n<td>async</td>\n<td>Consumer端控制本地调用是否是异步调用</td>\n</tr>\n<tr>\n<td>return</td>\n<td>Consumer端控制本地调用是否不需要调用返回值</td>\n</tr>\n<tr>\n<td>connections</td>\n<td>用于控制Consumer在调用多个Provider时，自身的connneticon是否共享或最大个数</td>\n</tr>\n<tr>\n<td>codec</td>\n<td>指定编码器</td>\n</tr>\n<tr>\n<td>heartbeat</td>\n<td>指定是否发送心跳，以及心跳的发送间隔</td>\n</tr>\n<tr>\n<td>exchanger</td>\n<td>指定exchanger扩展点的实现类</td>\n</tr>\n<tr>\n<td>heartbeat.timeout</td>\n<td>心跳超时时间</td>\n</tr>\n<tr>\n<td>sent</td>\n<td>Consumer端发送时，Consumer的等待超时时间</td>\n</tr>\n<tr>\n<td>codec</td>\n<td>指定编码器</td>\n</tr>\n<tr>\n<td>dispather</td>\n<td>指定分发器</td>\n</tr>\n<tr>\n<td>channel.handler</td>\n<td>控制、指定handler处理器</td>\n</tr>\n<tr>\n<td>threadname</td>\n<td>Provider端指定的线程池扩展点中线程名称</td>\n</tr>\n<tr>\n<td>threads</td>\n<td>Provider端指定的线程池扩展点中核心线程数和最大线程数的数量</td>\n</tr>\n<tr>\n<td>queues</td>\n<td>Provider端指定的线程池扩展点中队列的大小，0为使用SynchronousQueue，小于0为无限</td>\n</tr>\n<tr>\n<td>dump.directory</td>\n<td>Provider端线程池线程越界时，jstack命令dump线程文件快照存储的路径</td>\n</tr>\n<tr>\n<td>corethreads</td>\n<td>Provider端指定的线程池扩展点中cache/limited线程池核心线程数</td>\n</tr>\n<tr>\n<td>alive</td>\n<td>Provider端指定的线程池扩展点中cache线程池线程空闲时间，毫秒</td>\n</tr>\n<tr>\n<td>connect.queue.capacity</td>\n<td>Provider端dispatcher为connection时，指定线程池队列容量</td>\n</tr>\n<tr>\n<td>connect.queue.warning.size</td>\n<td>Provider端dispatcher为connection时，指定线程池队列容量告警阈值</td>\n</tr>\n</tbody>\n</table></div></div>\n<p>出处：<a href=\"https://blog.csdn.net/jnqqls/article/details/46702103\" target=\"_blank\" rel=\"noopener\">负载均衡策略</a></p>\n<p>Dubbo提供了多种均衡策略，缺省为random随机调用。</p>\n<div class=\"article-bounded\"><div class=\"article-table\"><table>\n<thead>\n<tr>\n<th>均衡策略</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Random LoadBalance</td>\n<td>随机，按权重设置随机概率。<br>在一个截面上碰撞的概率高，但调用量越大分布越均匀，而且按概率使用权重后也比较均匀，有利于动态调整提供者权重。</td>\n</tr>\n<tr>\n<td>RoundRobin LoadBalance</td>\n<td>轮循，按公约后的权重设置轮循比率。<br>存在慢的提供者累积请求问题，比如：第二台机器很慢，但没挂，当请求调到第二台时就卡在那，久而久之，所有请求都卡在调到第二台上。</td>\n</tr>\n<tr>\n<td>LeastActive LoadBalance</td>\n<td>最少活跃调用数，相同活跃数的随机，活跃数指调用前后计数差。<br>使慢的提供者收到更少请求，因为越慢的提供者的调用前后计数差会越大。</td>\n</tr>\n<tr>\n<td>ConsistentHash LoadBalance</td>\n<td>一致性Hash，相同参数的请求总是发到同一提供者。<br>当某一台提供者挂时，原本发往该提供者的请求，基于虚拟节点，平摊到其它提供者，不会引起剧烈变动</td>\n</tr>\n</tbody>\n</table></div></div>\n<h3 id=\"Dubbo高可用机制\"><a href=\"#Dubbo高可用机制\" class=\"headerlink\" title=\"Dubbo高可用机制\"></a>Dubbo高可用机制</h3><h3 id=\"Dubbo管控台与监控\"><a href=\"#Dubbo管控台与监控\" class=\"headerlink\" title=\"Dubbo管控台与监控\"></a>Dubbo管控台与监控</h3><p>出处：<a href=\"https://blog.csdn.net/shangmingtao/article/details/78049479\" target=\"_blank\" rel=\"noopener\">Dubbo管控台和监控中心</a></p>\n<h4 id=\"管理控制台\"><a href=\"#管理控制台\" class=\"headerlink\" title=\"管理控制台\"></a>管理控制台</h4><p>Dubbo-Admin管理控制台是一个可以直观看到并管理生产者消费者的平台.Dubbo-Admin本身就是一个java项目.</p>\n<p>下载地址: <a href=\"https://github.com/alibaba/dubbo\" target=\"_blank\" rel=\"noopener\">https://github.com/alibaba/dubbo</a> 在dubbo-admin上用mvn package就可以了</p>\n<p>打好包后我们需要将war包解压缩到tomcat webapps的ROOT目录下.并更改配置文件,启动tomcat</p>\n<p>配置文件:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#zookeeper地址</span><br><span class=\"line\">dubbo.registry.address=zookeeper://127.0.0.1:2181 </span><br><span class=\"line\">#管理员密码 管理账号root</span><br><span class=\"line\">dubbo.admin.root.password=root</span><br><span class=\"line\">#访客密码</span><br><span class=\"line\">dubbo.admin.guest.password=guest</span><br></pre></td></tr></table></figure>\n<p>验证是否安装成功,访问<a href=\"http://localhost:8080/\" target=\"_blank\" rel=\"noopener\">http://localhost:8080</a> 出现如下页面证明安装成功 </p>\n<div class=\"article-img\"><p><img src=\"E:\\blog\\lmg\\PinkSmallFan\\project\\source\\uploads\\dubbo管理控制台.png\" alt=\"dubbo管理控制台.png\"></p></div>\n<h4 id=\"Dubbo监控中心\"><a href=\"#Dubbo监控中心\" class=\"headerlink\" title=\"Dubbo监控中心\"></a>Dubbo监控中心</h4><p>Dubbo监控中心monitor主要是用来计数的,它所处的位置如下图,比如某个生产者被访问了多少次,当然官方提供的是一个简易的监控中心,我们也可以利用官方给出的api定制自己的监控中心.</p>\n<div class=\"article-img\"><p><img src=\"E:\\blog\\lmg\\PinkSmallFan\\project\\source\\uploads\\nxfywqs12h.jpeg\" alt=\"img\"></p></div>\n<h3 id=\"基于Dubbo的项目应用案例分析【案例】\"><a href=\"#基于Dubbo的项目应用案例分析【案例】\" class=\"headerlink\" title=\"基于Dubbo的项目应用案例分析【案例】\"></a>基于Dubbo的项目应用案例分析【案例】</h3><p>安装</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tar -xzvf dubbo-monitor-simple-2.5.3-assembly.tar.gz</span><br></pre></td></tr></table></figure>\n<p>更改dubbo-monitor-simple-2.5.3-assembly/dubbo-monitor-simple-2.5.3/conf下的dubbo.properties</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dubbo.container=log4j,spring,registry,jetty</span><br><span class=\"line\">dubbo.application.name=simple-monitor</span><br><span class=\"line\">dubbo.application.owner=</span><br><span class=\"line\">#dubbo.registry.address=multicast://224.5.6.7:1234</span><br><span class=\"line\">#zookeeper地址</span><br><span class=\"line\">dubbo.registry.address=zookeeper://127.0.0.1:2181 </span><br><span class=\"line\">#dubbo.registry.address=redis://127.0.0.1:6379</span><br><span class=\"line\">#dubbo.registry.address=dubbo://127.0.0.1:9090</span><br><span class=\"line\">dubbo.protocol.port=7070</span><br><span class=\"line\">#注意这里,因为我们的管理控制台用tomcat启动,tomcat默认端口8080,所以这里我们用8090,可以看出官方给的简易监控中心使用jetty启动的.</span><br><span class=\"line\">dubbo.jetty.port=8090 </span><br><span class=\"line\">dubbo.jetty.directory=$&#123;user.home&#125;/monitor</span><br><span class=\"line\">dubbo.charts.directory=$&#123;dubbo.jetty.directory&#125;/charts</span><br><span class=\"line\">dubbo.statistics.directory=$&#123;user.home&#125;/monitor/statistics</span><br><span class=\"line\">dubbo.log4j.file=logs/dubbo-monitor-simple.log</span><br><span class=\"line\">dubbo.log4j.level=WARN</span><br></pre></td></tr></table></figure>\n<p>接下来我们启动,进入dubbo-monitor-simple-2.5.3-assembly/dubbo-monitor-simple-2.5.3/bin目录,通过如下命令启动</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">start.sh #linux</span><br><span class=\"line\">start.bat #windows</span><br></pre></td></tr></table></figure>\n<p>访问:<a href=\"http://localhost:8090/\" target=\"_blank\" rel=\"noopener\">http://localhost:8090</a> 如下页面启动成功: </p>\n<div class=\"article-img\"><p><img src=\"E:\\blog\\lmg\\PinkSmallFan\\project\\source\\uploads\\监控中心.png\" alt=\"监控中心\"></p></div>\n<h2 id=\"微服务之Spring-Cloud\"><a href=\"#微服务之Spring-Cloud\" class=\"headerlink\" title=\"微服务之Spring Cloud\"></a><strong>微服务之Spring Cloud</strong></h2><h3 id=\"Spring-Cloud介绍\"><a href=\"#Spring-Cloud介绍\" class=\"headerlink\" title=\"Spring Cloud介绍\"></a>Spring Cloud介绍</h3><p>​    基于 Spring boot</p>\n<p>​    云服务、分布式框架集合</p>\n<p>​    Spring Cloud，来源于 Spring Source ，具有 Spring 社区的强大背书外，还有 Netflix 强大的后盾与技术输出。Netflix 作为一家成功实践微服务架构的互联网公司，在几年前就把几乎整个微服务框架栈开源贡献给了社区，这些框架开源的整套微服务架构套件是 Spring Cloud 的核心。</p>\n<h3 id=\"为什么选择Spring-Cloud？\"><a href=\"#为什么选择Spring-Cloud？\" class=\"headerlink\" title=\"为什么选择Spring Cloud？\"></a>为什么选择Spring Cloud？</h3><p>出处：<a href=\"https://cloud.tencent.com/developer/article/1177574\" target=\"_blank\" rel=\"noopener\">Spring Cloud优缺点</a></p>\n<ul>\n<li><p>有强大的 Spring 社区、Netflix 等公司支持，并且<strong>开源社区贡献非常活跃</strong>。</p>\n</li>\n<li><p><strong>标准化</strong>的将微服务的成熟产品和框架结合一起，Spring Cloud 提供<strong>整套的微服务解决方案，开发成本较低，且风险较小</strong>。</p>\n</li>\n<li><p><strong>基于 Spring Boot</strong>，具有简单配置、快速开发、轻松部署、方便测试的特点。</p>\n</li>\n<li><p>支持 REST 服务调用，相比于 RPC，更加<strong>轻量化和灵活</strong>（服务之间只依赖一纸契约，不存在代码级别的强依赖），有利于<strong>跨语言服务的实现</strong>，以及<strong>服务的发布部署</strong>。另外，结合 Swagger，也使得<strong>服务的文档一体化</strong>。</p>\n</li>\n<li><p>提供了 Docker 及 Kubernetes 微服务编排支持。</p>\n</li>\n<li><p>国内外企业应用非常多，经受了大公司的应用考验（比如 Netfilx 公司），以及强大的开源社区支持。</p>\n</li>\n</ul>\n<h3 id=\"Spring-Cloud架构剖析\"><a href=\"#Spring-Cloud架构剖析\" class=\"headerlink\" title=\"Spring Cloud架构剖析\"></a>Spring Cloud架构剖析</h3><p>出处：<a href=\"https://www.jianshu.com/p/ae55e444c3a7\" target=\"_blank\" rel=\"noopener\">Spring Colud完整技术与组件架构</a></p>\n<div class=\"article-img\"><p><img src=\"E:\\blog\\lmg\\PinkSmallFan\\project\\source\\uploads\\pe0rv90aoc.jpeg\" alt=\"img\"></p></div>\n<div class=\"article-img\"><p><img src=\"E:\\blog\\lmg\\PinkSmallFan\\project\\source\\uploads\\0gc7v2gapy.jpeg\" alt=\"img\"></p></div>\n<ul>\n<li>常用组件：<ul>\n<li>Eureka:　服务注册发现框架；</li>\n<li>Zuul:　服务网关；</li>\n<li>Karyon:　服务端框架；</li>\n<li>Ribbon:　客户端框架；</li>\n<li>Hystrix: 服务容错组件；</li>\n<li>Archaius: 服务配置组件；</li>\n<li>Servo: Metrics组件；</li>\n<li>Blitz4j: 日志组件</li>\n</ul>\n</li>\n<li>流程：<ul>\n<li>请求统一通过 API 网关（Zuul）来访问内部服务。</li>\n<li>网关接收到请求后，从注册中心（Eureka）获取可用服务。</li>\n<li>由 Ribbon 进行均衡负载后，分发到后端具体实例。</li>\n<li>微服务之间通过 Feign 进行通信处理业务。</li>\n<li>Hystrix 负责处理服务超时熔断。</li>\n<li>Turbine 监控服务间的调用和熔断相关指标。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Spring-Cloud的工具框架\"><a href=\"#Spring-Cloud的工具框架\" class=\"headerlink\" title=\"Spring Cloud的工具框架\"></a>Spring Cloud的工具框架</h3><p>出处：<a href=\"https://cloud.tencent.com/developer/article/1177574\" target=\"_blank\" rel=\"noopener\">工具框架</a></p>\n<ul>\n<li><strong>Spring Cloud Config 配置中心</strong>，利用 Git 集中管理程序的配置。</li>\n<li>Spring Cloud Netflix 集成众多Netflix的开源软件。</li>\n<li><strong>Spring Cloud Netflix Eureka 服务中心</strong>（类似于管家的概念，需要什么直接从这里取，就可以了），一个基于 REST 的服务，用于定位服务，以实现云端中间层服务发现和故障转移。</li>\n<li><strong>Spring Cloud Netflix Hystrix 熔断器</strong>，容错管理工具，旨在通过熔断机制控制服务和第三方库的节点，从而对延迟和故障提供更强大的容错能力。</li>\n<li><strong>Spring Cloud Netflix Zuul 网关</strong>，是在云平台上提供动态路由，监控，弹性，安全等边缘服务的框架。Web 网站后端所有请求的前门。</li>\n<li>Spring Cloud Netflix Archaius 配置管理 API，包含一系列配置管理API，提供动态类型化属性、线程安全配置操作、轮询框架、回调机制等功能。</li>\n<li><strong>Spring Cloud Netflix Ribbon 负载均衡</strong>。</li>\n<li><strong>Spring Cloud Netflix Fegin REST客户端</strong>。</li>\n<li><strong>Spring Cloud Bus 消息总线</strong>，利用分布式消息将服务和服务实例连接在一起，用于在一个集群中传播状态的变化。</li>\n<li>Spring Cloud for Cloud Foundry 利用 Pivotal Cloudfoundry 集成你的应用程序。</li>\n<li>Spring Cloud Cloud Foundry Service Broker 为建立管理云托管服务的服务代理提供了一个起点。</li>\n<li><strong>Spring Cloud Cluster 集群工具</strong>，基于 Zookeeper, Redis, Hazelcast, Consul 实现的领导选举和平民状态模式的抽象和实现。</li>\n<li>Spring Cloud Consul 基于 Hashicorp Consul 实现的服务发现和配置管理。</li>\n<li><strong>Spring Cloud Security 安全控制</strong>，在 Zuul 代理中为 OAuth2 REST 客户端和认证头转发提供负载均衡。</li>\n<li><strong>Spring Cloud Sleuth 分布式链路监控</strong>，SpringCloud 应用的分布式追踪系统，和 Zipkin，HTrace，ELK 兼容。</li>\n<li>Spring Cloud Data Flow 一个云本地程序和操作模型，组成数据微服务在一个结构化的平台上。</li>\n<li><strong>Spring Cloud Stream 消息组件</strong>，基于 Redis，Rabbit，Kafka 实现的消息微服务，简单声明模型用以在 Spring Cloud 应用中收发消息。</li>\n<li>Spring Cloud Stream App Starters 基于 Spring Boot 为外部系统提供 Spring 的集成。</li>\n<li>Spring Cloud Task 短生命周期的微服务，为 Spring Booot 应用简单声明添加功能和非功能特性。</li>\n<li>Spring Cloud Task App Starters。</li>\n<li>Spring Cloud Zookeeper 服务发现和配置管理基于 Apache Zookeeper。</li>\n<li>Spring Cloud for Amazon Web Services 快速和亚马逊网络服务集成。</li>\n<li>Spring Cloud Connectors 便于PaaS应用在各种平台上连接到后端像数据库和消息经纪服务。</li>\n<li>Spring Cloud Starters （项目已经终止并且在 Angel.SR2 后的版本和其他项目合并）</li>\n<li><strong>Spring Cloud CLI 命令行工具</strong>，插件用 Groovy 快速的创建 Spring Cloud 组件应用。</li>\n</ul>\n<h3 id=\"Spring-Cloud优缺点分析\"><a href=\"#Spring-Cloud优缺点分析\" class=\"headerlink\" title=\"Spring Cloud优缺点分析\"></a>Spring Cloud优缺点分析</h3><p>出处：<a href=\"https://cloud.tencent.com/developer/article/1177574\" target=\"_blank\" rel=\"noopener\">Spring Cloud优缺点</a></p>\n<ul>\n<li><p>支持 REST 服务调用，可能因为<strong>接口定义过轻</strong>，导致定义文档与实际实现不一致导致服务集成时的问题（可以使用统一文档和版本管理解决，比如 Swagger）。</p>\n</li>\n<li><p>另外，<strong>REST 服务调用性能会比 RPC 低一些</strong>（但也不是强绑定）</p>\n</li>\n<li><p>Spring Cloud 整合了大量组件，<strong>相关文档比较复杂</strong>，需要针对性的进行阅读。</p>\n</li>\n</ul>\n<h3 id=\"Spring-Cloud负载均衡\"><a href=\"#Spring-Cloud负载均衡\" class=\"headerlink\" title=\"Spring Cloud负载均衡\"></a>Spring Cloud负载均衡</h3><p>出处：<a href=\"https://www.jianshu.com/p/d815f0c3820d\" target=\"_blank\" rel=\"noopener\">SppringCloud负载均衡实践</a></p>\n<p>出处：<a href=\"https://blog.csdn.net/u012702547/article/details/77978845\" target=\"_blank\" rel=\"noopener\">SpringCloud负载均衡策略</a></p>\n<div class=\"article-bounded\"><div class=\"article-table\"><table>\n<thead>\n<tr>\n<th>策略接口</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>IRule</td>\n<td>这是所有负载均衡策略的父接口，里边的核心方法就是choose方法，用来选择一个服务实例。</td>\n</tr>\n<tr>\n<td>AbstractLoad<br>BalancerRule</td>\n<td>AbstractLoadBalancerRule是一个抽象类，里边主要定义了一个ILoadBalancer，就是我们上文所说的负载均衡器，负载均衡器的功能我们在上文已经说的很详细了，这里就不再赘述，这里定义它的目的主要是辅助负责均衡策略选取合适的服务端实例。</td>\n</tr>\n<tr>\n<td>RandomRule</td>\n<td>看名字就知道，这种负载均衡策略就是随机选择一个服务实例，看源码我们知道，在RandomRule的无参构造方法中初始化了一个Random对象，然后在它重写的choose方法又调用了choose(ILoadBalancer lb, Object key)这个重载的choose方法，在这个重载的choose方法中，每次利用random对象生成一个不大于服务实例总数的随机数，并将该数作为下标所以获取一个服务实例。</td>\n</tr>\n<tr>\n<td>RoundRobinRule</td>\n<td>RoundRobinRule这种负载均衡策略叫做线性负载均衡策略，也就是我们在上文所说的BaseLoadBalancer负载均衡器中默认采用的负载均衡策略。这个类的choose(ILoadBalancer lb, Object key)函数整体逻辑是这样的：开启一个计数器count，在while循环中遍历服务清单，获取清单之前先通过incrementAndGetModulo方法获取一个下标，这个下标是一个不断自增长的数先加1然后和服务清单总数取模之后获取到的（所以这个下标从来不会越界），拿着下标再去服务清单列表中取服务，每次循环计数器都会加1，如果连续10次都没有取到服务，则会报一个警告No available alive servers after 10 tries from load balancer: XXXX。</td>\n</tr>\n<tr>\n<td>RetryRule</td>\n<td>看名字就知道这种负载均衡策略带有重试功能。首先RetryRule中又定义了一个subRule，它的实现类是RoundRobinRule，然后在RetryRule的choose(ILoadBalancer lb, Object key)方法中，每次还是采用RoundRobinRule中的choose规则来选择一个服务实例，如果选到的实例正常就返回，如果选择的服务实例为null或者已经失效，则在失效时间deadline之前不断的进行重试（重试时获取服务的策略还是RoundRobinRule中定义的策略），如果超过了deadline还是没取到则会返回一个null。</td>\n</tr>\n<tr>\n<td>WeightedResponse<br>TimeRule</td>\n<td>WeightedResponseTimeRule是RoundRobinRule的一个子类，在WeightedResponseTimeRule中对RoundRobinRule的功能进行了扩展，WeightedResponseTimeRule中会根据每一个实例的运行情况来给计算出该实例的一个权重，然后在挑选实例的时候则根据权重进行挑选，这样能够实现更优的实例调用。WeightedResponseTimeRule中有一个名叫DynamicServerWeightTask的定时任务，默认情况下每隔30秒会计算一次各个服务实例的权重，权重的计算规则也很简单，如果一个服务的平均响应时间越短则权重越大，那么该服务实例被选中执行任务的概率也就越大。</td>\n</tr>\n<tr>\n<td>ClientConfigEnabled<br>RoundRobinRule</td>\n<td>ClientConfigEnabledRoundRobinRule选择策略的实现很简单，内部定义了RoundRobinRule，choose方法还是采用了RoundRobinRule的choose方法，所以它的选择策略和RoundRobinRule的选择策略一致，不赘述。</td>\n</tr>\n<tr>\n<td>BestAvailableRule</td>\n<td>BestAvailableRule继承自ClientConfigEnabledRoundRobinRule，它在ClientConfigEnabledRoundRobinRule的基础上主要增加了根据loadBalancerStats中保存的服务实例的状态信息来过滤掉失效的服务实例的功能，然后顺便找出并发请求最小的服务实例来使用。然而loadBalancerStats有可能为null，如果loadBalancerStats为null，则BestAvailableRule将采用它的父类即ClientConfigEnabledRoundRobinRule的服务选取策略（线性轮询）。</td>\n</tr>\n<tr>\n<td>PredicateBasedRule</td>\n<td>PredicateBasedRule是ClientConfigEnabledRoundRobinRule的一个子类，它先通过内部定义的一个过滤器过滤出一部分服务实例清单，然后再采用线性轮询的方式从过滤出来的结果中选取一个服务实例。</td>\n</tr>\n<tr>\n<td>ZoneAvoidanceRule</td>\n<td>ZoneAvoidanceRule是PredicateBasedRule的一个实现类，只不过这里多一个过滤条件，ZoneAvoidanceRule中的过滤条件是以ZoneAvoidancePredicate为主过滤条件和以AvailabilityPredicate为次过滤条件组成的一个叫做CompositePredicate的组合过滤条件，过滤成功之后，继续采用线性轮询的方式从过滤结果中选择一个出来。</td>\n</tr>\n</tbody>\n</table></div></div>\n<h3 id=\"Spring-Cloud管理与监控\"><a href=\"#Spring-Cloud管理与监控\" class=\"headerlink\" title=\"Spring Cloud管理与监控\"></a>Spring Cloud管理与监控</h3><p>出处：<a href=\"https://blog.csdn.net/Axela30W/article/details/81117788\" target=\"_blank\" rel=\"noopener\">SpringCloud管理与监控的实践</a></p>\n<h2 id=\"微服务开发之Spring-Boot\"><a href=\"#微服务开发之Spring-Boot\" class=\"headerlink\" title=\"微服务开发之Spring Boot\"></a><strong>微服务开发之Spring Boot</strong></h2><h3 id=\"什么是SpringBoot？\"><a href=\"#什么是SpringBoot？\" class=\"headerlink\" title=\"什么是SpringBoot？\"></a>什么是SpringBoot？</h3><p>出处：<a href=\"https://jimmysong.io/posts/spring-boot-quick-start-guide/\" target=\"_blank\" rel=\"noopener\">SpringBoot概念</a></p>\n<p>Spring boot的技术栈</p>\n<div class=\"article-img\"><p><img src=\"E:\\blog\\lmg\\PinkSmallFan\\project\\source\\uploads/spring-stack.png\" alt=\"spring-stack\"> </p></div>\n<div class=\"article-img\"><p><img src=\"E:\\blog\\lmg\\PinkSmallFan\\project\\source\\uploads/spring-boot-note-spots.png\" alt=\"spring-boot-note-spots\"></p></div>\n<h3 id=\"SpringBoot适应场景\"><a href=\"#SpringBoot适应场景\" class=\"headerlink\" title=\"SpringBoot适应场景\"></a><strong>SpringBoot适应场景</strong></h3><p>出处：<a href=\"https://juejin.im/entry/598951d76fb9a03c350a58d9\" target=\"_blank\" rel=\"noopener\">SpringBoot应用场景</a></p>\n<div class=\"article-img\"><p><img src=\"E:\\blog\\lmg\\PinkSmallFan\\project\\source\\uploads\\SpringBoot应用场景.jpg\" alt=\"SpringBoot应用场景\"></p></div>\n<h3 id=\"SpringBoot优势\"><a href=\"#SpringBoot优势\" class=\"headerlink\" title=\"SpringBoot优势\"></a>SpringBoot优势</h3><p>出处：<a href=\"https://blog.csdn.net/fly_zhyu/article/details/76407830\" target=\"_blank\" rel=\"noopener\">Spring boot浅谈</a></p>\n<ul>\n<li><p>Spring boot能够使编码变精简、配置变简单、部署变快捷、监控变容易</p>\n</li>\n<li><p>Spring boot默认快速启动一个web容器，不需要外置web容器，将注意力集中在编码上，而不是配置容器等方面上。</p>\n</li>\n<li><p>Spring boot是Spring框架扬长避短的杰作，简化了spring冗余的配置，从xml配置到java Config配置，从setBean的方式配置到自动注解，从多个properties+xml到只要一个yml就完成了配置。</p>\n</li>\n<li><p>Spring boot 默认配置；额很多框架的使用方式，整合了所有框架</p>\n</li>\n<li><p>Spring boot能够对主流开发的框架，进行无配置集成，提高了开发、部署的效率，不用再花额外的时间，研究不同框架的整合与集成上</p>\n</li>\n<li><p>Spring boot支持的配置文件application.yml，减少了传统的properties的链式麻烦</p>\n</li>\n<li><p>Spring boot提供了热部署，实时刷新后台服务，能将服务改动后的效果，呈现出来</p>\n</li>\n<li><p>Spring boot一键启动，只需要一个jar、war，甚至一段代码就可以了，不需要预部署应用服务器</p>\n</li>\n<li><p>configprops：属性配置、dump：线程工作状态、env/name：环境变量、metrics/name：JVM性能指标、mapping：RESTful path与服务类的映射关系</p>\n</li>\n</ul>\n<h3 id=\"SpringBoot的包版本管理\"><a href=\"#SpringBoot的包版本管理\" class=\"headerlink\" title=\"SpringBoot的包版本管理\"></a>SpringBoot的包版本管理</h3><p>pom??</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">spring-boot-dependencies</span><br><span class=\"line\">spring-boot-parent</span><br><span class=\"line\">spring-boot-tools</span><br><span class=\"line\">spring-boot</span><br><span class=\"line\">spring-boot-test</span><br><span class=\"line\">spring-boot-autoconfigure</span><br><span class=\"line\">spring-boot-test-autoconfigure</span><br><span class=\"line\">spring-boot-actuator</span><br><span class=\"line\">spring-boot-devtools</span><br><span class=\"line\">spring-boot-docs</span><br><span class=\"line\">spring-boot-starters</span><br><span class=\"line\">spring-boot-actuator-docs</span><br><span class=\"line\">spring-boot-cli</span><br></pre></td></tr></table></figure>\n<p>出处：<a href=\"https://www.jianshu.com/p/346cac67bfcc\" target=\"_blank\" rel=\"noopener\">SpringBoot Module</a></p>\n<h4 id=\"spring-boot\"><a href=\"#spring-boot\" class=\"headerlink\" title=\"spring-boot\"></a>spring-boot</h4><p>SpringBoot核心工程。</p>\n<h4 id=\"spring-boot-starters\"><a href=\"#spring-boot-starters\" class=\"headerlink\" title=\"spring-boot-starters\"></a>spring-boot-starters</h4><p>是SpringBoot的启动服务工程。</p>\n<h4 id=\"spring-boot-autoconfigure\"><a href=\"#spring-boot-autoconfigure\" class=\"headerlink\" title=\"spring-boot-autoconfigure\"></a>spring-boot-autoconfigure</h4><p>是SpringBoot实现自动配置的核心工程。</p>\n<h4 id=\"spring-boot-actuator\"><a href=\"#spring-boot-actuator\" class=\"headerlink\" title=\"spring-boot-actuator\"></a>spring-boot-actuator</h4><p>提供SpringBoot应用的外围支撑性功能。 比如：</p>\n<ul>\n<li>Endpoints，SpringBoot应用状态监控管理</li>\n<li>HealthIndicator，SpringBoot应用健康指示表</li>\n<li>提供metrics支持</li>\n<li>提供远程shell支持</li>\n</ul>\n<h4 id=\"spring-boot-tools\"><a href=\"#spring-boot-tools\" class=\"headerlink\" title=\"spring-boot-tools\"></a>spring-boot-tools</h4><p>提供了SpringBoot开发者的常用工具集。诸如，spring-boot-gradle-plugin，spring-boot-maven-plugin就是这个工程里面的。</p>\n<h4 id=\"spring-boot-cli\"><a href=\"#spring-boot-cli\" class=\"headerlink\" title=\"spring-boot-cli\"></a>spring-boot-cli</h4><p>是Spring Boot命令行交互工具，可用于使用Spring进行快速原型搭建。你可以用它直接运行Groovy脚本。如果你不喜欢Maven或Gradle，Spring提供了CLI（Command Line Interface）来开发运行Spring应用程序。你可以使用它来运行Groovy脚本，甚至编写自定义命令。</p>\n<h3 id=\"SpringBoot自动配置\"><a href=\"#SpringBoot自动配置\" class=\"headerlink\" title=\"SpringBoot自动配置\"></a><strong>SpringBoot自动配置</strong></h3><p>出处：<a href=\"https://www.bysocket.com/?p=2001\" target=\"_blank\" rel=\"noopener\">SpringBoot自动部署</a> 、<a href=\"http://ifeve.com/spring-boot-autoconfiguration/\" target=\"_blank\" rel=\"noopener\">SpringBoot官方文档</a></p>\n<p>​    Spring Boot <code>spring-boot-autoconfigure</code> 依赖做了很多默认的配置项，即应用默认值。这种模式叫做 “自动配置”。Spring Boot 自动配置会根据添加的依赖，自动加载依赖相关的配置属性并启动依赖。例如默认用的内嵌式容器是 Tomcat ，端口默认设置为 8080。</p>\n<p>​    为什么需要自动配置？顾名思义，自动配置的意义是利用这种模式代替了配置 XML 繁琐模式。以前使用 Spring MVC ，需要进行配置组件扫描、调度器、视图解析器等，使用 Spring Boot 自动配置后，只需要添加 MVC 组件即可自动配置所需要的 Bean。所有自动配置的实现都在 <code>spring-boot-autoconfigure</code> 依赖中，包括 Spring MVC 、Data 和其它框架的自动配置。</p>\n<p>​    Spring Boot的自动配置会尝试根据你添加进来的jar依赖来自动配置你的Spring应用。例如，如果HSQLDB在你的classpath路径上，你没有手动配置任何数据库连接实体类，我们还会自动配置内存数据库。</p>\n<p>你可以有选择的实现自动配置，可以向 @Configuration上添加@EnableAutoConfiguration或者@SpringBootApplication注解来实现。</p>\n<p>逐步覆盖自动配置</p>\n<p>​    自动配置是非入侵式的，任何时候你都可以使用你自定义的配置来覆盖自动配置的特定部分。例如，如果你要添加自己的DataSource bean，默认的内嵌数据库会无效。</p>\n<p>​    如果你需要查找当前应用的自动配置，你可以启动应用时加上–debug开关。它会为核心日志记录器开启debug日志记录，并且会打印自动配置日志信息到控制台。</p>\n<p><strong>禁用特定自动配置</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@EnableAutoConfiguration</span>的排除属性来禁用它们。</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.boot.autoconfigure.*;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.boot.autoconfigure.jdbc.*;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.*;</span><br><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"meta\">@EnableAutoConfiguration</span>(exclude=&#123;DataSourceAutoConfiguration.class&#125;) <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyConfiguration</span> </span>&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果这个类不在classpath路径下，你可以使用该注解的excludeName属性以及指定全限定名 来替代。最终，你也可以控制自动配置类的列表来额除spring.autoconfigure.exclude属性。</p>\n<p>你可以通过注解级别以及使用属性来定义排除项。</p>\n<p>Starter 组件</p>\n<p>Spring Boot 提供了很多 “开箱即用” 的 Starter 组件。Starter 组件是可被加载在应用中的 Maven 依赖项。只需要在 Maven 配置中添加对应的依赖配置，即可使用对应的 Starter 组件。例如，添加 <code>spring-boot-starter-web</code> 依赖，就可用于构建 REST API 服务，其包含了 Spring MVC 和 Tomcat 内嵌容器等。</p>\n<p>一个完整的 Starter 组件包括以下两点：</p>\n<ul>\n<li>提供自动配置功能的自动配置模块。</li>\n<li>提供依赖关系管理功能的组件模块，即封装了组件所有功能，开箱即用</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">spring-boot-starter</span><br><span class=\"line\">spring-boot-starter-activemq</span><br><span class=\"line\">spring-boot-starter-actuator</span><br><span class=\"line\">spring-boot-starter-amqp</span><br><span class=\"line\">spring-boot-starter-aop</span><br><span class=\"line\">spring-boot-starter-artemis</span><br><span class=\"line\">spring-boot-starter-batch</span><br><span class=\"line\">spring-boot-starter-cache</span><br><span class=\"line\">spring-boot-starter-cloud-connectors</span><br><span class=\"line\">spring-boot-starter-data-cassandra</span><br><span class=\"line\">spring-boot-starter-data-couchbase</span><br><span class=\"line\">spring-boot-starter-data-elasticsearch</span><br><span class=\"line\">spring-boot-starter-data-jpa</span><br><span class=\"line\">spring-boot-starter-data-ldap</span><br><span class=\"line\">spring-boot-starter-data-mongodb</span><br><span class=\"line\">spring-boot-starter-data-mongodb-reactive</span><br><span class=\"line\">spring-boot-starter-data-neo4j</span><br><span class=\"line\">spring-boot-starter-data-redis</span><br><span class=\"line\">spring-boot-starter-data-rest</span><br><span class=\"line\">spring-boot-starter-data-solr</span><br><span class=\"line\">spring-boot-starter-freemarker</span><br><span class=\"line\">spring-boot-starter-groovy-templates</span><br><span class=\"line\">spring-boot-starter-hateoas</span><br><span class=\"line\">spring-boot-starter-integration</span><br><span class=\"line\">spring-boot-starter-jdbc</span><br><span class=\"line\">spring-boot-starter-jersey</span><br><span class=\"line\">spring-boot-starter-jetty</span><br><span class=\"line\">spring-boot-starter-jooq</span><br><span class=\"line\">spring-boot-starter-jta-atomikos</span><br><span class=\"line\">spring-boot-starter-jta-bitronix</span><br><span class=\"line\">spring-boot-starter-jta-narayana</span><br><span class=\"line\">spring-boot-starter-log4j2</span><br><span class=\"line\">spring-boot-starter-logging</span><br><span class=\"line\">spring-boot-starter-mail</span><br><span class=\"line\">spring-boot-starter-mobile</span><br><span class=\"line\">spring-boot-starter-mustache</span><br><span class=\"line\">spring-boot-starter-parent</span><br><span class=\"line\">spring-boot-starter-reactor-netty</span><br><span class=\"line\">spring-boot-starter-security</span><br><span class=\"line\">spring-boot-starter-social-facebook</span><br><span class=\"line\">spring-boot-starter-social-linkedin</span><br><span class=\"line\">spring-boot-starter-social-twitter</span><br><span class=\"line\">spring-boot-starter-test</span><br><span class=\"line\">spring-boot-starter-thymeleaf</span><br><span class=\"line\">spring-boot-starter-tomcat</span><br><span class=\"line\">spring-boot-starter-undertow</span><br><span class=\"line\">spring-boot-starter-validation</span><br><span class=\"line\">spring-boot-starter-web</span><br><span class=\"line\">spring-boot-starter-web-services</span><br><span class=\"line\">spring-boot-starter-webflux</span><br><span class=\"line\">spring-boot-starter-websocket</span><br></pre></td></tr></table></figure>\n<p>自动部署的一些不足：</p>\n<p>​    Spring Boot 工程添加某些 Starter 组件依赖，但不想触发组件自动配置<br>​    Spring Boot 配置多个不同数据源配置时，比如使用 XML 配置多数据源，但其默认数据源配置会触发自动配置出现问题。    </p>\n<h3 id=\"SpringBoot热部署机制\"><a href=\"#SpringBoot热部署机制\" class=\"headerlink\" title=\"SpringBoot热部署机制\"></a><strong>SpringBoot热部署机制</strong></h3><p>出处：<a href=\"https://www.jianshu.com/p/31440633f967\" target=\"_blank\" rel=\"noopener\">SpringBoot热部署</a></p>\n<p>原理：</p>\n<p>​    spring-boot-devtools 是一个为开发者服务的模块，其中最重要的功能就是自动应用代码更改到最新的App上面去。原理 是在发现代码有更改之后，重新启动应用，但是速度比手动停止后再启动还要更快，更快指的不是节省出来的手动操作的时间。</p>\n<p>​    其深层原理是使用了两个ClassLoader，一个Classloader加载那些不会改变的类（第三方的jar包），另外一个ClassLoader加载会更改的类，称为restart ClassLoader</p>\n<p>​    这样在有代码更改的时候，，原来的restart ClassLoader被丢弃，重新创建一个restart ClassLoader，由于需要加载的类相比较少，所以实现了更快的重启时间（5秒左右）</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- 添加spring boot devtools --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-devtools<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">optional</span>&gt;</span>true<span class=\"tag\">&lt;/<span class=\"name\">optional</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">scope</span>&gt;</span>true<span class=\"tag\">&lt;/<span class=\"name\">scope</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 添加plugin --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">build</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">plugins</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">plugin</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">configuration</span>&gt;</span></span><br><span class=\"line\">                    <span class=\"comment\">&lt;!-- fork:如果没有该配置，这个devtools不会起作用，即应用不会restart --&gt;</span></span><br><span class=\"line\">                    <span class=\"tag\">&lt;<span class=\"name\">fork</span>&gt;</span>true<span class=\"tag\">&lt;/<span class=\"name\">fork</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;/<span class=\"name\">configuration</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">plugin</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">plugins</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">build</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>出处：<a href=\"https://www.cnblogs.com/jiangbei/p/8438733.html\" target=\"_blank\" rel=\"noopener\">热部署与热加载的区别</a></p>\n<p>​    热部署就是在服务器运行时重新部署项目，——生产环境</p>\n<p>​    热加载即在在运行时重新加载class，从而升级应用。——开发环境</p>\n<p>　    热加载的实现原理主要依赖java的类加载机制，在实现方式可以概括为在容器启动的时候起一条后台线程，定时的检测类文件的时间戳变化，如果类的时间戳变掉了，则将类重新载入。</p>\n<p>　　对比反射机制，反射是在运行时获取类信息，通过动态的调用来改变程序行为； 热加载则是在运行时通过重新加载改变类信息，直接改变程序行为。</p>\n<p>　　热部署原理类似，但它是直接重新加载整个应用，这种方式会释放内存，比热加载更加干净彻底，但同时也更费时间。</p>\n<h3 id=\"如何自定义配置参数？\"><a href=\"#如何自定义配置参数？\" class=\"headerlink\" title=\"如何自定义配置参数？\"></a>如何自定义配置参数？</h3><p>出处：<a href=\"https://www.jianshu.com/p/fbb32298d1fa\" target=\"_blank\" rel=\"noopener\">SpringBoot自定义配置参数</a></p>\n<p>yml</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 测试中使用的作者信息</span></span><br><span class=\"line\"><span class=\"attr\">author:</span></span><br><span class=\"line\">  <span class=\"comment\"># 姓名</span></span><br><span class=\"line\"><span class=\"attr\">  name:</span> <span class=\"string\">xxx</span></span><br><span class=\"line\">  <span class=\"comment\"># 性别</span></span><br><span class=\"line\">  <span class=\"comment\"># gender: man</span></span><br><span class=\"line\">  <span class=\"comment\"># 年龄</span></span><br><span class=\"line\"><span class=\"attr\">  age:</span> <span class=\"number\">22</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"外部化配置\"><a href=\"#外部化配置\" class=\"headerlink\" title=\"外部化配置\"></a>外部化配置</h3><p>出处：<a href=\"https://www.jianshu.com/p/fbb32298d1fa\" target=\"_blank\" rel=\"noopener\">SpringBoot自定义配置参数</a></p>\n<p>实体类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 配置文件对应的实体</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AuthorValue</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 用户名</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">     * 通过 value 注解获取 properties 文件中的内容</span></span><br><span class=\"line\"><span class=\"comment\">     * $&#123;属性的全称&#125;</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Value</span>(<span class=\"string\">\"$&#123;author.name&#125;\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">     * 若配置文件中没有配置相应的属性, 而在类中又通过 @Value的形式获取, 系统启动时会报错</span></span><br><span class=\"line\"><span class=\"comment\">     * 所以, 我们可以通过设定默认值的形式避免这样的问题</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Value</span>(<span class=\"string\">\"$&#123;author.age:10&#125;\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Integer age;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// getter and setter</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>测试类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 通过 value 的方式获取配置文件内容的测试方法</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@RunWith</span>(SpringRunner.class)</span><br><span class=\"line\"><span class=\"meta\">@SpringBootTest</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AuthorValueTest</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> AuthorValue authorValue;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">getUserMessage</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        Integer age = <span class=\"number\">10</span>;</span><br><span class=\"line\">        Assert.assertEquals(authorValue.getName(), <span class=\"string\">\"xxx\"</span>);</span><br><span class=\"line\">        Assert.assertEquals(authorValue.getAge(), age);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>@ConfigurationProperties 直接封装对象</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 配置文件对应的实体</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"meta\">@ConfigurationProperties</span>(prefix = <span class=\"string\">\"author\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AuthorObject</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 用户名</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 年龄</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Integer age;</span><br><span class=\"line\">    <span class=\"comment\">// getter and setter</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"多环境配置\"><a href=\"#多环境配置\" class=\"headerlink\" title=\"多环境配置\"></a>多环境配置</h3><p>出处：<a href=\"https://blog.csdn.net/yy756127197/article/details/78193398\" target=\"_blank\" rel=\"noopener\">SpringBoot多环境配置</a></p>\n<p>一个yml文件</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">spring:</span></span><br><span class=\"line\"><span class=\"attr\">  profiles:</span></span><br><span class=\"line\"><span class=\"attr\">    active:</span> <span class=\"string\">dev</span></span><br><span class=\"line\"><span class=\"meta\">---</span></span><br><span class=\"line\"><span class=\"comment\">#开发环境配置</span></span><br><span class=\"line\"><span class=\"attr\">spring:</span></span><br><span class=\"line\"><span class=\"attr\">  profiles:</span> <span class=\"string\">dev</span></span><br><span class=\"line\"><span class=\"attr\">server:</span></span><br><span class=\"line\"><span class=\"attr\">  port:</span> <span class=\"number\">1000</span></span><br><span class=\"line\"><span class=\"meta\">---</span></span><br><span class=\"line\"><span class=\"comment\">#测试环境配置</span></span><br><span class=\"line\"><span class=\"attr\">spring:</span></span><br><span class=\"line\"><span class=\"attr\">  profiles:</span> <span class=\"string\">stg</span></span><br><span class=\"line\"><span class=\"attr\">server:</span></span><br><span class=\"line\"><span class=\"attr\">  port:</span> <span class=\"number\">1001</span></span><br><span class=\"line\"><span class=\"meta\">---</span></span><br><span class=\"line\"><span class=\"comment\">#生产环境配置</span></span><br><span class=\"line\"><span class=\"attr\">spring:</span></span><br><span class=\"line\"><span class=\"attr\">  profiles:</span> <span class=\"string\">prd</span></span><br><span class=\"line\"><span class=\"attr\">server:</span></span><br><span class=\"line\"><span class=\"attr\">  port:</span> <span class=\"number\">1002</span></span><br></pre></td></tr></table></figure>\n<p>多个yml文件（比较实用）</p>\n<p>application.yml</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">spring:</span></span><br><span class=\"line\"><span class=\"attr\">  profiles:</span></span><br><span class=\"line\"><span class=\"attr\">    active:</span> <span class=\"string\">dev</span></span><br></pre></td></tr></table></figure>\n<p>application-dev.yml</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">server:</span></span><br><span class=\"line\"><span class=\"attr\">  port:</span> <span class=\"number\">1000</span></span><br></pre></td></tr></table></figure>\n<p>application-test.yml</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">server:</span></span><br><span class=\"line\"><span class=\"attr\">  port:</span> <span class=\"number\">1001</span></span><br></pre></td></tr></table></figure>\n<p>application-prd.yml</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">server:</span></span><br><span class=\"line\"><span class=\"attr\">  port:</span> <span class=\"number\">1002</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"Spring-Boot常用注解\"><a href=\"#Spring-Boot常用注解\" class=\"headerlink\" title=\"Spring Boot常用注解\"></a>Spring Boot常用注解</h3><p>出处：<a href=\"https://www.jianshu.com/p/e335923270f0\" target=\"_blank\" rel=\"noopener\">SprintBoot常用注解</a></p>\n<div class=\"article-img\"><p><img src=\"E:\\blog\\lmg\\PinkSmallFan\\project\\source\\uploads\\SpringBoot常用注解1.png\" alt=\"SpringBoot常用注解1\"></p></div>\n<div class=\"article-img\"><p><img src=\"E:\\blog\\lmg\\PinkSmallFan\\project\\source\\uploads\\SpringBoot常用注解2.png\" alt=\"SpringBoot常用注2\"></p></div>\n<h3 id=\"Spring-Boot发布之jar与war\"><a href=\"#Spring-Boot发布之jar与war\" class=\"headerlink\" title=\"Spring Boot发布之jar与war\"></a>Spring Boot发布之jar与war</h3><p>出处：<a href=\"https://blog.csdn.net/qq_38623459/article/details/80790859\" target=\"_blank\" rel=\"noopener\">SpringBoot发布中jar与war的区别</a></p>\n<p>jar包：直接通过内置tomcat运行，不需要额外安装tomcat。如需修改内置tomcat的配置，只需要在spring boot的配置文件中配置。内置tomcat没有自己的日志输出，全靠jar包应用输出日志。但是比较方便，快速，比较简单。</p>\n<p>war包：传统的应用交付方式，需要安装tomcat，然后放到waeapps目录下运行war包，可以灵活选择tomcat版本，可以直接修改tomcat的配置，有自己的tomcat日志输出，可以灵活配置安全策略。相对打成jar包来说没那么快速方便</p>\n<h3 id=\"生产级特性\"><a href=\"#生产级特性\" class=\"headerlink\" title=\"生产级特性\"></a>生产级特性</h3><p>出处：<a href=\"https://www.jianshu.com/p/c785764c7c80\" target=\"_blank\" rel=\"noopener\">SpringBoot生产级特性</a></p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"comment\">&lt;!-- 监控 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"endpoint\"><a href=\"#endpoint\" class=\"headerlink\" title=\"endpoint\"></a>endpoint</h4><p>我们可以通过一系列的HTTP请求获得应用程序的相关信息，这些请求就是endpoint，具体有如下几个</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">autoconfig  : 获取自动配置信息</span><br><span class=\"line\">beans  ：获取Spring Bean基本信息</span><br><span class=\"line\">configprops ：获取配置项信息</span><br><span class=\"line\">dump ： 获取当前线程基本信息</span><br><span class=\"line\">env ：获取环境变量信息</span><br><span class=\"line\">health ： 获取健康检查信息</span><br><span class=\"line\">info ： 获取应用的基本信息</span><br><span class=\"line\">metrics ： 获取性能指标信息</span><br><span class=\"line\">mappings ： 获取请求映射信息</span><br><span class=\"line\">trace ： 获取请求调用信息</span><br></pre></td></tr></table></figure>\n<p>可以通过application.properties配置文件进行精准控制</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 放弃安全限制</span><br><span class=\"line\">management.security.enabled=false</span><br><span class=\"line\"># 关闭一个endpoint：beans</span><br><span class=\"line\">endpoints.beans.enabled=false</span><br><span class=\"line\"># 关闭所有endpoint，仅打开beans</span><br><span class=\"line\">endpoints.enable=false</span><br><span class=\"line\">endpoints.beans.enabled=false</span><br><span class=\"line\"># 修改endpoint名称</span><br><span class=\"line\">endpoints.beans.id=mybeans</span><br><span class=\"line\"># 修改请求路径</span><br><span class=\"line\">endpoints.beans.path=/endpoints/mybeans</span><br></pre></td></tr></table></figure>\n<h4 id=\"信息聚合\"><a href=\"#信息聚合\" class=\"headerlink\" title=\"信息聚合\"></a>信息聚合</h4><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- actuator聚合插件 /actuator --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-starter-hateoas<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- actuator聚合图形化插件 /actuator --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.data<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-data-rest-hal-browser<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"应用信息\"><a href=\"#应用信息\" class=\"headerlink\" title=\"应用信息\"></a>应用信息</h4><p>通过/info可以查看应用信息，信息可以在application.properties文件中配置</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">info.app.name=应用名称，使用POM中的信息，@project.modelVersion@</span><br><span class=\"line\">info.app.description=对应用的描述</span><br><span class=\"line\">info.app.version=1.0.0</span><br><span class=\"line\"># 自定义用户信息</span><br><span class=\"line\">info.user.name=hutou</span><br><span class=\"line\">info.user.sex=男</span><br><span class=\"line\">info.user.age=22</span><br></pre></td></tr></table></figure>\n<h4 id=\"健康检查\"><a href=\"#健康检查\" class=\"headerlink\" title=\"健康检查\"></a>健康检查</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 暴露磁盘空间信息</span><br><span class=\"line\">endpoints.health.sensitive=true</span><br><span class=\"line\"># 健康信息缓存时间，设置太短会影响性能</span><br><span class=\"line\">endpoints.health.time-to-live=500</span><br></pre></td></tr></table></figure>\n<p>spring boot提供了很多内置的监控检查功能，都放置在：org.springframework.boot.actuate.health包下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ApplicationHealthIndicator</span><br><span class=\"line\">DiskSpaceHealthIndicator</span><br><span class=\"line\">DataSourceHealthIndicator    检查数据库连接</span><br><span class=\"line\">MailHealthIndicator                检查邮件服务器</span><br><span class=\"line\">MongoHealthIndicator            检查MongoDB数据库</span><br><span class=\"line\">....</span><br></pre></td></tr></table></figure>\n<h4 id=\"跨域访问\"><a href=\"#跨域访问\" class=\"headerlink\" title=\"跨域访问\"></a>跨域访问</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">## 跨域访问</span><br><span class=\"line\">endpoints.cors.allowed-origins=http://www.baidu.com</span><br><span class=\"line\">endpoints.cors.allowed-methods=GET,PUT,POST,DELETE</span><br></pre></td></tr></table></figure>\n<p>在应用中增加@CrossOrigin注解来实现跨域</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** 自定义配置</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"meta\">@EnableWebMvc</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WebConfig</span> <span class=\"keyword\">extends</span> <span class=\"title\">WebMvcConfigurerAdapter</span></span>&#123;</span><br><span class=\"line\"> <span class=\"meta\">@Override</span></span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">addCorsMappings</span><span class=\"params\">(CorsRegistry registry)</span> </span>&#123;</span><br><span class=\"line\">     registry.addMapping(<span class=\"string\">\"/**\"</span>)</span><br><span class=\"line\">         .allowedOrigins(<span class=\"string\">\"http://www.baidu.com\"</span>)</span><br><span class=\"line\">         .allowedMethods(<span class=\"string\">\"GET\"</span>,<span class=\"string\">\"PUT\"</span>,<span class=\"string\">\"POST\"</span>,<span class=\"string\">\"DELETE\"</span>);</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"监控\"><a href=\"#监控\" class=\"headerlink\" title=\"监控\"></a>监控</h3><p>出处：<a href=\"https://blog.csdn.net/wh_ouyangshuang/article/details/48048111\" target=\"_blank\" rel=\"noopener\">SpringBoot监控</a></p>\n<p>spring-boot-actuator模块提供了一个监控和管理生产环境的模块，可以使用http、jmx、ssh、telnet等拉管理和监控应用。审计（Auditing）、<br>健康（health）、数据采集（metrics gathering）会自动加入到应用里面。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- 添加依赖 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<div class=\"article-img\"><p><img src=\"E:\\blog\\lmg\\PinkSmallFan\\project\\source\\uploads\\SpringBoot监控.png\" alt=\"SpringBoot监控\"></p></div>\n<h3 id=\"【实战】使用SpringBoot快速构建RESTful-API应用\"><a href=\"#【实战】使用SpringBoot快速构建RESTful-API应用\" class=\"headerlink\" title=\"【实战】使用SpringBoot快速构建RESTful API应用\"></a>【实战】使用SpringBoot快速构建RESTful API应用</h3><h2 id=\"微服务之注册中心\"><a href=\"#微服务之注册中心\" class=\"headerlink\" title=\"微服务之注册中心\"></a><strong>微服务之注册中心</strong></h2><h3 id=\"服务调用端与服务提供端之间透明通信\"><a href=\"#服务调用端与服务提供端之间透明通信\" class=\"headerlink\" title=\"服务调用端与服务提供端之间透明通信\"></a>服务调用端与服务提供端之间透明通信</h3><h3 id=\"如何实现服务的动态注册与发现\"><a href=\"#如何实现服务的动态注册与发现\" class=\"headerlink\" title=\"如何实现服务的动态注册与发现\"></a>如何实现服务的动态注册与发现</h3><h3 id=\"注册中心引入\"><a href=\"#注册中心引入\" class=\"headerlink\" title=\"注册中心引入\"></a>注册中心引入</h3><h3 id=\"注册中心之zookeeper\"><a href=\"#注册中心之zookeeper\" class=\"headerlink\" title=\"注册中心之zookeeper\"></a><strong>注册中心之zookeeper</strong></h3><h3 id=\"注册中心底层实现剖析\"><a href=\"#注册中心底层实现剖析\" class=\"headerlink\" title=\"注册中心底层实现剖析\"></a>注册中心底层实现剖析</h3><h3 id=\"SpringCloud之注册中心Eurka\"><a href=\"#SpringCloud之注册中心Eurka\" class=\"headerlink\" title=\"SpringCloud之注册中心Eurka\"></a><strong>SpringCloud之注册中心Eurka</strong></h3><h3 id=\"Eurka介绍与原理分析\"><a href=\"#Eurka介绍与原理分析\" class=\"headerlink\" title=\"Eurka介绍与原理分析\"></a>Eurka介绍与原理分析</h3><h3 id=\"【实战】实现将微服务注册到EurkaServer上\"><a href=\"#【实战】实现将微服务注册到EurkaServer上\" class=\"headerlink\" title=\"【实战】实现将微服务注册到EurkaServer上\"></a>【实战】实现将微服务注册到EurkaServer上</h3><h2 id=\"微服务之负载均衡\"><a href=\"#微服务之负载均衡\" class=\"headerlink\" title=\"微服务之负载均衡\"></a><strong>微服务之负载均衡</strong></h2><h3 id=\"负载均衡应用场景\"><a href=\"#负载均衡应用场景\" class=\"headerlink\" title=\"负载均衡应用场景\"></a>负载均衡应用场景</h3><h3 id=\"常用的负载均衡实现方案\"><a href=\"#常用的负载均衡实现方案\" class=\"headerlink\" title=\"常用的负载均衡实现方案\"></a>常用的负载均衡实现方案</h3><h3 id=\"客户端负载均衡\"><a href=\"#客户端负载均衡\" class=\"headerlink\" title=\"客户端负载均衡\"></a><strong>客户端负载均衡</strong></h3><h3 id=\"服务端负载均衡\"><a href=\"#服务端负载均衡\" class=\"headerlink\" title=\"服务端负载均衡\"></a><strong>服务端负载均衡</strong></h3><h3 id=\"【实战】使用Ribbin实现客户端负载均衡\"><a href=\"#【实战】使用Ribbin实现客户端负载均衡\" class=\"headerlink\" title=\"【实战】使用Ribbin实现客户端负载均衡\"></a>【实战】使用Ribbin实现客户端负载均衡</h3><h2 id=\"微服务之容错处理\"><a href=\"#微服务之容错处理\" class=\"headerlink\" title=\"微服务之容错处理\"></a><strong>微服务之容错处理</strong></h2><h3 id=\"雪崩效应场景分析\"><a href=\"#雪崩效应场景分析\" class=\"headerlink\" title=\"雪崩效应场景分析\"></a>雪崩效应场景分析</h3><h3 id=\"如何应对雪崩效应下的容错处理\"><a href=\"#如何应对雪崩效应下的容错处理\" class=\"headerlink\" title=\"如何应对雪崩效应下的容错处理\"></a>如何应对雪崩效应下的容错处理</h3><h3 id=\"Spring-Cloud体系下之容错处理解决方案断路器Hystrix\"><a href=\"#Spring-Cloud体系下之容错处理解决方案断路器Hystrix\" class=\"headerlink\" title=\"Spring Cloud体系下之容错处理解决方案断路器Hystrix\"></a><strong>Spring Cloud体系下之容错处理解决方案断路器Hystrix</strong></h3><h3 id=\"应用如何接入Hystrix\"><a href=\"#应用如何接入Hystrix\" class=\"headerlink\" title=\"应用如何接入Hystrix\"></a>应用如何接入Hystrix</h3><h3 id=\"如何监控Hystrix状态\"><a href=\"#如何监控Hystrix状态\" class=\"headerlink\" title=\"如何监控Hystrix状态\"></a>如何监控Hystrix状态</h3><h3 id=\"【实战】实现Hystrix-Dashboard可视化监控数据\"><a href=\"#【实战】实现Hystrix-Dashboard可视化监控数据\" class=\"headerlink\" title=\"【实战】实现Hystrix Dashboard可视化监控数据\"></a>【实战】实现Hystrix Dashboard可视化监控数据</h3><h2 id=\"微服务之网关\"><a href=\"#微服务之网关\" class=\"headerlink\" title=\"微服务之网关\"></a><strong>微服务之网关</strong></h2><h3 id=\"微服务网关定义\"><a href=\"#微服务网关定义\" class=\"headerlink\" title=\"微服务网关定义\"></a>微服务网关定义</h3><h3 id=\"微服务网关引入能解决什么问题\"><a href=\"#微服务网关引入能解决什么问题\" class=\"headerlink\" title=\"微服务网关引入能解决什么问题\"></a>微服务网关引入能解决什么问题</h3><h3 id=\"SpringCloud之微服务网关zuul\"><a href=\"#SpringCloud之微服务网关zuul\" class=\"headerlink\" title=\"SpringCloud之微服务网关zuul\"></a>SpringCloud之微服务网关zuul</h3><h3 id=\"如何编写zuul微服务网关\"><a href=\"#如何编写zuul微服务网关\" class=\"headerlink\" title=\"如何编写zuul微服务网关\"></a>如何编写zuul微服务网关</h3><h3 id=\"zuul过滤器的应用\"><a href=\"#zuul过滤器的应用\" class=\"headerlink\" title=\"zuul过滤器的应用\"></a>zuul过滤器的应用</h3><h3 id=\"zuul的容错与回退处理\"><a href=\"#zuul的容错与回退处理\" class=\"headerlink\" title=\"zuul的容错与回退处理\"></a>zuul的容错与回退处理</h3><h3 id=\"【实战】使用zuul聚合微服务\"><a href=\"#【实战】使用zuul聚合微服务\" class=\"headerlink\" title=\"【实战】使用zuul聚合微服务\"></a>【实战】使用zuul聚合微服务</h3><h2 id=\"微服务之配置中心\"><a href=\"#微服务之配置中心\" class=\"headerlink\" title=\"微服务之配置中心\"></a>微服务之配置中心</h2><h3 id=\"服务配置中心介绍与应用场景分析\"><a href=\"#服务配置中心介绍与应用场景分析\" class=\"headerlink\" title=\"服务配置中心介绍与应用场景分析\"></a>服务配置中心介绍与应用场景分析</h3><h3 id=\"微服务配置之Ansible\"><a href=\"#微服务配置之Ansible\" class=\"headerlink\" title=\"微服务配置之Ansible\"></a>微服务配置之Ansible</h3><h3 id=\"如何管理微服务中的配置\"><a href=\"#如何管理微服务中的配置\" class=\"headerlink\" title=\"如何管理微服务中的配置\"></a>如何管理微服务中的配置</h3><h3 id=\"Spring-Cloud下之微服务配置解决方案Spring-Cloud-Config\"><a href=\"#Spring-Cloud下之微服务配置解决方案Spring-Cloud-Config\" class=\"headerlink\" title=\"Spring Cloud下之微服务配置解决方案Spring Cloud Config\"></a>Spring Cloud下之微服务配置解决方案Spring Cloud Config</h3><h3 id=\"Config-Server与Config-Client的实现\"><a href=\"#Config-Server与Config-Client的实现\" class=\"headerlink\" title=\"Config Server与Config Client的实现\"></a>Config Server与Config Client的实现</h3><h3 id=\"Config-Server仓库配置与应用流程\"><a href=\"#Config-Server仓库配置与应用流程\" class=\"headerlink\" title=\"Config Server仓库配置与应用流程\"></a>Config Server仓库配置与应用流程</h3><h3 id=\"如何实现配置端点的刷新\"><a href=\"#如何实现配置端点的刷新\" class=\"headerlink\" title=\"如何实现配置端点的刷新\"></a>如何实现配置端点的刷新</h3><h3 id=\"如何确保配置中心内容的安全性？\"><a href=\"#如何确保配置中心内容的安全性？\" class=\"headerlink\" title=\"如何确保配置中心内容的安全性？\"></a>如何确保配置中心内容的安全性？</h3><h3 id=\"如何实现配置刷新后自动下发？\"><a href=\"#如何实现配置刷新后自动下发？\" class=\"headerlink\" title=\"如何实现配置刷新后自动下发？\"></a>如何实现配置刷新后自动下发？</h3><h3 id=\"【实战】使用Spring-Cloud-Config打造微服务配置中心\"><a href=\"#【实战】使用Spring-Cloud-Config打造微服务配置中心\" class=\"headerlink\" title=\"【实战】使用Spring Cloud Config打造微服务配置中心\"></a>【实战】使用Spring Cloud Config打造微服务配置中心</h3><h2 id=\"微服务之封装\"><a href=\"#微服务之封装\" class=\"headerlink\" title=\"微服务之封装\"></a>微服务之封装</h2><h3 id=\"容器化技术\"><a href=\"#容器化技术\" class=\"headerlink\" title=\"容器化技术\"></a><strong>容器化技术</strong></h3><h3 id=\"Docker简介\"><a href=\"#Docker简介\" class=\"headerlink\" title=\"Docker简介\"></a>Docker简介</h3><h3 id=\"Docker架构剖析\"><a href=\"#Docker架构剖析\" class=\"headerlink\" title=\"Docker架构剖析\"></a>Docker架构剖析</h3><h3 id=\"虚拟机与Docker的对比\"><a href=\"#虚拟机与Docker的对比\" class=\"headerlink\" title=\"虚拟机与Docker的对比\"></a><strong>虚拟机与Docker的对比</strong></h3><h3 id=\"Docker的优点\"><a href=\"#Docker的优点\" class=\"headerlink\" title=\"Docker的优点\"></a>Docker的优点</h3><h3 id=\"Docker安装系统要求\"><a href=\"#Docker安装系统要求\" class=\"headerlink\" title=\"Docker安装系统要求\"></a>Docker安装系统要求</h3><h3 id=\"Docker的安装与卸载\"><a href=\"#Docker的安装与卸载\" class=\"headerlink\" title=\"Docker的安装与卸载\"></a>Docker的安装与卸载</h3><h3 id=\"Docker镜像常用命令\"><a href=\"#Docker镜像常用命令\" class=\"headerlink\" title=\"Docker镜像常用命令\"></a><strong>Docker镜像常用命令</strong></h3><h3 id=\"Docker容器常用命令\"><a href=\"#Docker容器常用命令\" class=\"headerlink\" title=\"Docker容器常用命令\"></a><strong>Docker容器常用命令</strong></h3><h3 id=\"如何配置Docker镜像地址\"><a href=\"#如何配置Docker镜像地址\" class=\"headerlink\" title=\"如何配置Docker镜像地址\"></a>如何配置Docker镜像地址</h3><h3 id=\"Docker镜像下载与构建\"><a href=\"#Docker镜像下载与构建\" class=\"headerlink\" title=\"Docker镜像下载与构建\"></a>Docker镜像下载与构建</h3><h3 id=\"使用Docker-Registry打造私有镜像仓库\"><a href=\"#使用Docker-Registry打造私有镜像仓库\" class=\"headerlink\" title=\"使用Docker Registry打造私有镜像仓库\"></a>使用Docker Registry打造私有镜像仓库</h3><h2 id=\"微服务部署\"><a href=\"#微服务部署\" class=\"headerlink\" title=\"微服务部署\"></a>微服务部署</h2><h3 id=\"持续集成\"><a href=\"#持续集成\" class=\"headerlink\" title=\"持续集成\"></a>持续集成</h3><h3 id=\"Jenkins简介\"><a href=\"#Jenkins简介\" class=\"headerlink\" title=\"Jenkins简介\"></a>Jenkins简介</h3><h3 id=\"使用Jenkins实现自动化发布\"><a href=\"#使用Jenkins实现自动化发布\" class=\"headerlink\" title=\"使用Jenkins实现自动化发布\"></a>使用Jenkins实现自动化发布</h3><h3 id=\"搭建版本控制系统\"><a href=\"#搭建版本控制系统\" class=\"headerlink\" title=\"搭建版本控制系统\"></a>搭建版本控制系统</h3><h3 id=\"搭建Jenkins持续集成系统\"><a href=\"#搭建Jenkins持续集成系统\" class=\"headerlink\" title=\"搭建Jenkins持续集成系统\"></a>搭建Jenkins持续集成系统</h3><h3 id=\"持续集成实现自动化构建\"><a href=\"#持续集成实现自动化构建\" class=\"headerlink\" title=\"持续集成实现自动化构建\"></a>持续集成实现自动化构建</h3><h2 id=\"微服务日志\"><a href=\"#微服务日志\" class=\"headerlink\" title=\"微服务日志\"></a>微服务日志</h2><h3 id=\"为什么需要搭建应用日志中心\"><a href=\"#为什么需要搭建应用日志中心\" class=\"headerlink\" title=\"为什么需要搭建应用日志中心\"></a>为什么需要搭建应用日志中心</h3><h3 id=\"开源日志中心ELK介绍\"><a href=\"#开源日志中心ELK介绍\" class=\"headerlink\" title=\"开源日志中心ELK介绍\"></a><strong>开源日志中心ELK介绍</strong></h3><h3 id=\"日志存储系统之Elasticsearch\"><a href=\"#日志存储系统之Elasticsearch\" class=\"headerlink\" title=\"日志存储系统之Elasticsearch\"></a><strong>日志存储系统之Elasticsearch</strong></h3><h3 id=\"日志收集系统之Logstash\"><a href=\"#日志收集系统之Logstash\" class=\"headerlink\" title=\"日志收集系统之Logstash\"></a><strong>日志收集系统之Logstash</strong></h3><h3 id=\"日志查询系统之Kibana\"><a href=\"#日志查询系统之Kibana\" class=\"headerlink\" title=\"日志查询系统之Kibana\"></a><strong>日志查询系统之Kibana</strong></h3><h3 id=\"ELK日志中心搭建\"><a href=\"#ELK日志中心搭建\" class=\"headerlink\" title=\"ELK日志中心搭建\"></a>ELK日志中心搭建</h3><h2 id=\"微服务监控\"><a href=\"#微服务监控\" class=\"headerlink\" title=\"微服务监控\"></a>微服务监控</h2><h3 id=\"Spring-Boot自带的开源监控系统Spring-Boot-Admin\"><a href=\"#Spring-Boot自带的开源监控系统Spring-Boot-Admin\" class=\"headerlink\" title=\"Spring Boot自带的开源监控系统Spring Boot Admin\"></a>Spring Boot自带的开源监控系统Spring Boot Admin</h3><h3 id=\"自主搭建系统监控中心\"><a href=\"#自主搭建系统监控中心\" class=\"headerlink\" title=\"自主搭建系统监控中心\"></a><strong>自主搭建系统监控中心</strong></h3><h3 id=\"分布式调用链中心\"><a href=\"#分布式调用链中心\" class=\"headerlink\" title=\"分布式调用链中心\"></a><strong>分布式调用链中心</strong></h3><h3 id=\"开源调用链中心Zipkin\"><a href=\"#开源调用链中心Zipkin\" class=\"headerlink\" title=\"开源调用链中心Zipkin\"></a><strong>开源调用链中心Zipkin</strong></h3><h3 id=\"微服务调用链追踪\"><a href=\"#微服务调用链追踪\" class=\"headerlink\" title=\"微服务调用链追踪\"></a>微服务调用链追踪</h3><h3 id=\"Spring-Cloud-Sleuth简介\"><a href=\"#Spring-Cloud-Sleuth简介\" class=\"headerlink\" title=\"Spring Cloud Sleuth简介\"></a>Spring Cloud Sleuth简介</h3><h3 id=\"Spring-Cloud-Sleuth与Zipkin结合应用\"><a href=\"#Spring-Cloud-Sleuth与Zipkin结合应用\" class=\"headerlink\" title=\"Spring Cloud Sleuth与Zipkin结合应用\"></a>Spring Cloud Sleuth与Zipkin结合应用</h3><h2 id=\"微服务之异步化\"><a href=\"#微服务之异步化\" class=\"headerlink\" title=\"微服务之异步化\"></a><strong>微服务之异步化</strong></h2><h3 id=\"使用MQ实现异步调用\"><a href=\"#使用MQ实现异步调用\" class=\"headerlink\" title=\"使用MQ实现异步调用\"></a><strong>使用MQ实现异步调用</strong></h3><h3 id=\"分布式事务解决方案剖析\"><a href=\"#分布式事务解决方案剖析\" class=\"headerlink\" title=\"分布式事务解决方案剖析\"></a>分布式事务解决方案剖析</h3><h3 id=\"Spring-Cloud-Bus的应用\"><a href=\"#Spring-Cloud-Bus的应用\" class=\"headerlink\" title=\"Spring Cloud Bus的应用\"></a><strong>Spring Cloud Bus的应用</strong></h3><h3 id=\"【实战】使用Spring-Cloud-Bus实现配置的自动刷新\"><a href=\"#【实战】使用Spring-Cloud-Bus实现配置的自动刷新\" class=\"headerlink\" title=\"【实战】使用Spring Cloud Bus实现配置的自动刷新\"></a>【实战】使用Spring Cloud Bus实现配置的自动刷新</h3><h2 id=\"微服务测试\"><a href=\"#微服务测试\" class=\"headerlink\" title=\"微服务测试\"></a>微服务测试</h2><h3 id=\"Spring-Boot单元测试\"><a href=\"#Spring-Boot单元测试\" class=\"headerlink\" title=\"Spring Boot单元测试\"></a>Spring Boot单元测试</h3><h3 id=\"Service层测试\"><a href=\"#Service层测试\" class=\"headerlink\" title=\"Service层测试\"></a><strong>Service层测试</strong></h3><h3 id=\"REST-API测试\"><a href=\"#REST-API测试\" class=\"headerlink\" title=\"REST API测试\"></a><strong>REST API测试</strong></h3><h3 id=\"【综合案例】-某大型的跨境电商项目\"><a href=\"#【综合案例】-某大型的跨境电商项目\" class=\"headerlink\" title=\"【综合案例】 某大型的跨境电商项目\"></a>【综合案例】 某大型的跨境电商项目</h3><h3 id=\"【综合案例】-某服务治理平台\"><a href=\"#【综合案例】-某服务治理平台\" class=\"headerlink\" title=\"【综合案例】 某服务治理平台\"></a>【综合案例】 某服务治理平台</h3><h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ol>\n<li>单体架构简介：<a href=\"http://book.51cto.com/art/201803/567370.htm\" target=\"_blank\" rel=\"noopener\">http://book.51cto.com/art/201803/567370.htm</a></li>\n<li>单体架构到微服务的演进：<a href=\"https://my.oschina.net/zhanghaiyang/blog/725728\" target=\"_blank\" rel=\"noopener\">https://my.oschina.net/zhanghaiyang/blog/725728</a></li>\n<li>从单体架构迁移微服务：<a href=\"http://www.infoq.com/cn/news/2016/08/Monomer-architecture-Micro-servi\" target=\"_blank\" rel=\"noopener\">http://www.infoq.com/cn/news/2016/08/Monomer-architecture-Micro-servi</a></li>\n<li>单体与微服务架构：<a href=\"https://blog.csdn.net/hu_zhiting/article/details/77036914\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/hu_zhiting/article/details/77036914</a> </li>\n<li>微服务的4大设计原则和19个解决方案：<a href=\"https://juejin.im/entry/59bf30876fb9a00a583176a1\" target=\"_blank\" rel=\"noopener\">https://juejin.im/entry/59bf30876fb9a00a583176a1</a></li>\n<li>微服务对比：<a href=\"https://segmentfault.com/a/1190000010953144\" target=\"_blank\" rel=\"noopener\">https://segmentfault.com/a/1190000010953144</a></li>\n</ol>\n","prev":{"title":"SQLite的实践与使用","slug":"SQLite3的实践与使用"},"next":{"title":"","slug":"换位思考"},"link":"http://wenchongjiaokou.info./2018/11/16/微服务预习/","toc":[{"title":"实践路线（github）","id":"实践路线（github）","index":"1","children":[{"title":"方式","id":"方式","index":"1.1"}]},{"title":"<strong>传统单体架构及其面临的挑战</strong>","id":"传统单体架构及其面临的挑战","index":"2","children":[{"title":"传统单体架构分析","id":"传统单体架构分析","index":"2.1"},{"title":"单体架构的优势","id":"单体架构的优势","index":"2.2"},{"title":"单体架构局限性与面临的挑战","id":"单体架构局限性与面临的挑战","index":"2.3"},{"title":"如何解决上述问题？","id":"如何解决上述问题？","index":"2.4"},{"title":"服务水平拆分","id":"服务水平拆分","index":"2.5"},{"title":"服务水平拆分面临问题","id":"服务水平拆分面临问题","index":"2.6"},{"title":"服务垂直拆分","id":"服务垂直拆分","index":"2.7"},{"title":"服务的设计原则","id":"服务的设计原则","index":"2.8"},{"title":"服务拆分后面临挑战","id":"服务拆分后面临挑战","index":"2.9"}]},{"title":"<strong>微服务架构综述</strong>","id":"微服务架构综述","index":"3","children":[{"title":"什么是微服务？","id":"什么是微服务？","index":"3.1"},{"title":"微服务架构","id":"微服务架构","index":"3.2"},{"title":"微服务架构优点","id":"微服务架构优点","index":"3.3"},{"title":"微服务架构面临的挑战有哪些？","id":"微服务架构面临的挑战有哪些？","index":"3.4"},{"title":"<strong>微服务生命周期与交付流程</strong>","id":"微服务生命周期与交付流程","index":"3.5"},{"title":"微服务管理规范","id":"微服务管理规范","index":"3.6"},{"title":"<strong>微服务框架对比</strong>","id":"微服务框架对比","index":"3.7","children":[{"title":"性能对比","id":"性能对比","index":"3.7.1"},{"title":"服务对比","id":"服务对比","index":"3.7.2"},{"title":"组件对比","id":"组件对比","index":"3.7.3"},{"title":"服务依赖方式","id":"服务依赖方式","index":"3.7.4"}]},{"title":"Dubbo介绍","id":"Dubbo介绍","index":"3.8"},{"title":"为什么选择Dubbo?","id":"为什么选择Dubbo","index":"3.9"},{"title":"<strong>Dubbo架构剖析</strong>","id":"Dubbo架构剖析","index":"3.10"},{"title":"<strong>Dubbo优缺点分析</strong>","id":"Dubbo优缺点分析","index":"3.11"},{"title":"<strong>Dubbo调用地址与负载均衡</strong>","id":"Dubbo调用地址与负载均衡","index":"3.12"},{"title":"Dubbo管控台与监控","id":"Dubbo管控台与监控","index":"3.13","children":[{"title":"管理控制台","id":"管理控制台","index":"3.13.1"},{"title":"Dubbo监控中心","id":"Dubbo监控中心","index":"3.13.2"}]},{"title":"基于Dubbo的项目应用案例分析【案例】","id":"基于Dubbo的项目应用案例分析【案例】","index":"3.14"}]},{"title":"<strong>微服务之Spring Cloud</strong>","id":"微服务之Spring-Cloud","index":"4","children":[{"title":"Spring Cloud介绍","id":"Spring-Cloud介绍","index":"4.1"},{"title":"为什么选择Spring Cloud？","id":"为什么选择Spring-Cloud？","index":"4.2"},{"title":"Spring Cloud架构剖析","id":"Spring-Cloud架构剖析","index":"4.3"},{"title":"Spring Cloud的工具框架","id":"Spring-Cloud的工具框架","index":"4.4"},{"title":"Spring Cloud优缺点分析","id":"Spring-Cloud优缺点分析","index":"4.5"},{"title":"Spring Cloud负载均衡","id":"Spring-Cloud负载均衡","index":"4.6"},{"title":"Spring Cloud管理与监控","id":"Spring-Cloud管理与监控","index":"4.7"}]},{"title":"<strong>微服务开发之Spring Boot</strong>","id":"微服务开发之Spring-Boot","index":"5","children":[{"title":"什么是SpringBoot？","id":"什么是SpringBoot？","index":"5.1"},{"title":"<strong>SpringBoot适应场景</strong>","id":"SpringBoot适应场景","index":"5.2"},{"title":"SpringBoot优势","id":"SpringBoot优势","index":"5.3"},{"title":"SpringBoot的包版本管理","id":"SpringBoot的包版本管理","index":"5.4","children":[{"title":"spring-boot","id":"spring-boot","index":"5.4.1"},{"title":"spring-boot-starters","id":"spring-boot-starters","index":"5.4.2"},{"title":"spring-boot-autoconfigure","id":"spring-boot-autoconfigure","index":"5.4.3"},{"title":"spring-boot-actuator","id":"spring-boot-actuator","index":"5.4.4"},{"title":"spring-boot-tools","id":"spring-boot-tools","index":"5.4.5"},{"title":"spring-boot-cli","id":"spring-boot-cli","index":"5.4.6"}]},{"title":"<strong>SpringBoot自动配置</strong>","id":"SpringBoot自动配置","index":"5.5"},{"title":"<strong>SpringBoot热部署机制</strong>","id":"SpringBoot热部署机制","index":"5.6"},{"title":"如何自定义配置参数？","id":"如何自定义配置参数？","index":"5.7"},{"title":"外部化配置","id":"外部化配置","index":"5.8"},{"title":"多环境配置","id":"多环境配置","index":"5.9"},{"title":"Spring Boot常用注解","id":"Spring-Boot常用注解","index":"5.10"},{"title":"Spring Boot发布之jar与war","id":"Spring-Boot发布之jar与war","index":"5.11"},{"title":"生产级特性","id":"生产级特性","index":"5.12","children":[{"title":"endpoint","id":"endpoint","index":"5.12.1"},{"title":"信息聚合","id":"信息聚合","index":"5.12.2"},{"title":"应用信息","id":"应用信息","index":"5.12.3"},{"title":"健康检查","id":"健康检查","index":"5.12.4"},{"title":"跨域访问","id":"跨域访问","index":"5.12.5"}]},{"title":"监控","id":"监控","index":"5.13"},{"title":"【综合案例】 某服务治理平台","id":"【综合案例】-某服务治理平台","index":"5.14"}]},{"title":"参考","id":"参考","index":"6"}]}